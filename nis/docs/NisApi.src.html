<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="style.css">

</head>

<body>

<div class=document>

	<p class=NemTitle style='margin-bottom:88.0pt;'><img src="image002.jpg"></p>
	
	<p class=NemTitleText>NEM NIS API Documentation</p>

	<p class=NemSubtitle>Version 1.16</p>
	<p class=NemSubtitle><time>FILLED AUTOMATICALLY</time></p>
	<p style='page-break-before:always'></p>

	<p class=NemTocHeading>Contents</p>
	<div id="toc">FILLED AUTOMATICALLY

        NOTES:

        use samp+pre for OUTPUTS (nis answers)
        use code+pre for INPUTS (requests

    </div>

	<hr/>
	<div>
		<h4>Changes since 1.15</h4>
		<ul>
			<li>updated chapter 6.8 to reflect correct fee calculation for aggregate modification transactions.</li>
		</ul>

		<h4>Changes since 1.14</h4>
		<ul>
			<li>updated chapter 6.3, 6.5 and appendix A 8.19.2 to reflect that aggregate modification transactions need to have version 2.</li>
		</ul>

		<h4>Changes since 1.13</h4>
		<ul>
			<li>added chapter 3.1.10 <a href="#retrieving-the-unlock-info"> Retrieving the unlock info</a></li>
		</ul>

		<h4>Changes since 1.12</h4>
		<ul>
			<li>updated chapter 6.3 - 6.5 to reflect the m of n multisig account changes</li>
			<li>updated chapter 6.7.1 to reflect the m of n multisig account changes</li>
			<li>updated structure <a href="#multisigAggregateModificationTransaction">MultisigAggregateModificationTransaction</a> </li>
			<li>replaced table tag with fields tag</li>
			<li>updated structures that have changed</li>
			<li>added missing error messages</li>
		</ul>
		<h4>Changes since 1.11</h4>
		<ul>
			<li>updated chapter 3.1.2 <a href="#requesting-the-account-data"> Requesting the account data</a></li>
			<li>added chapter 3.1.3 <a href="#requesting-the-original-account-data-for-a-delegate-account"> Requesting the original account data for a delegate account</a></li>
			<li>updated structure <a href="#accountInfo">AccountInfo</a></li>
		</ul>

		<h4>Changes since 1.10</h4>
		<ul>
			<li>added chapter 3.2 <a href="#retrieving-historical-account-data"> Retrieving historical account data</a></li>
			<li>added structure <a href="#accountHistoricalDataViewModel">AccountHistoricalDataViewModel</a></li>
		</ul>

		<h4>Changes since 1.9</h4>
        <ul>
            <li>corrected the fee formula for aggregate modification transactions in the fee table</li>
        </ul>

        <h4>Changes since 1.8</h4>
        <ul>
            <li>updated document to reflect the possible versions (main and test network) of the block and transactions structures</li>
            <li>updated structure <a href="#node">Node</a></li>
        </ul>

        <h4>Changes since 1.7</h4>
        <ul>
            <li>added chapter 6.7 <a href="#creating-a-signed-transaction"> Creating a signed transaction</a> and added structure <a href="#requestAnnounce">RequestAnnounce</a></li>
            <li>updated structures <a href="#transactionMetaData">TransactionMetaData</a>, <a href="#nemAnnounceResult">NemAnnounceResult</a></li>
        </ul>

        <h4>Changes since 1.6</h4>
		<ul>
            <li>added table with <a href="#transaction-fees">transaction fees</a></li>
            <li>fixed description of <a href="#requestPrepareAnnounce">RequestPrepareAnnounce</a></li>
		</ul>

		<h4>Changes since 1.5</h4>
		<ul>
			<li>added <a href="#generating-new-account-data">Generating new account data</a></li>
			<li>updated <a href="#requesting-the-account-data">Requesting the account data</a></li>
			<li>updated structures <a href="#keyPairViewModel">KeyPairViewModel</a>, <a href="#accountMetaData">AccountMetaData</a></li>
		</ul>
	</div>
	<hr/>

	<h1>Introduction</h1>

	<h2>General Information</h2>

	<p>The NEM Infrastructure Server (short: NIS) was written in Java. It needs Java 8 to run. It can run with at least 512MB memory for the java virtual machine but we recommend at least 1GB.</p>

	<h2>Installation</h2>

	<p>NIS can be installed either via installer using the URL <a href="http://bob.nem.ninja/installer/">NEM Infrastructure Server</a> or as stand-alone package which is hosted on <a href="http://bob.nem.ninja/">http://bob.nem.ninja/</a>. The installer only supports 64 bit versions of Java. The current stand-alone version as of this writing is <a href="http://bob.nem.ninja/nis-ncc-0.5.13.tgz">nis-ncc-0.5.13.tgz</a>. When using the installer both installation and the start-up of the software is automatic. The stand-alone version needs to be unzipped to a directory of your choice. It is then started by running runNis.bat (windows) or nix.runNis.sh (linux) from the command prompt.</p>

	<h2>Requests</h2>

	<p>NIS uses port 7890 to communicate with its clients. It accepts both HTTP GET and POST requests.</p>

	<p>Assuming that the NIS is running locally, HTTP GET requests can be executed from a browser and have the form:</p>

	<p><a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a>&lt;path to API request&gt;?&lt;parameters&gt; for example:</p>

	<p><a href="http://127.0.0.1:7890/account/get?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS">http://127.0.0.1:7890/account/get?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS</a></p>

	<p>HTTP POST request usually cannot be executed from within the browser unless you use a plugin which is able to do it. HTTP POST requests use JSON structures in the request body to supply data to NIS.</p>

	<p>Both request types return (if any data is returned) data using JSON structures. <a href="#appendix-A:-description-of-the-JSON-structures">Appendix A: Description of the JSON Structures</a> explains all JSON structures used in this document.</p>

	<h1>NIS status related requests</h1>

	<p>There are two requests by which you can get information about the status of NIS. The /heartbeat request gives you information if the node is up and responsive. The /status request gives more detailed information about the state of NIS. Both requests return a NemRequestResult object. See <appa>NemRequestResult</appa> for more details on the interpretation of a NemRequestResult.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h2>Heart beat request</h2>
	<api get>/heartbeat</api>

	<desc>
	<p class=NemNoSpacing>Determines if NIS is up and responsive.</p>
	</desc>

	<h4>No Parameter:</h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/heartbeat">http://127.0.0.1:7890/heartbeat</a></p>

	<h4>Example of returned JSON object:</h4>

	<resp>
{
	"code": 1,
	"type": 2,
	"message": "ok"
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>If there is no response to this request,
	NIS is either not running or is in a state where it can't serve requests.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h2>Status Request</h2>
	<api get>/status</api>

	<desc>
	<p class=NemNoSpacing>Determines the status of NIS.</p>
	</desc>

	<h4>No Parameter:</h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/status">http://127.0.0.1:7890/status</a></p>

	<h4>Example of returned JSON object:</h4>

	<resp>
{ 
	"code": 6, 
	"type": 4, 
	<b>"message": "status"</b>
} 
	</resp>

	<p class=NemNoSpacing>The code can be interpreted as follows:</p>
	<vals>
	0: Unknown status.
	1: NIS is stopped.
	2: NIS is starting.
	3: NIS is running.
	4: NIS is booting the local node (implies NIS is running).
	5: The local node is booted (implies NIS is running).
	6: The local node is synchronized (implies NIS is running and the local node is booted).
	7: NIS local node does not see any remote NIS node (implies running and booted).
	8: NIS is currently loading the block chain from the database. In this state NIS cannot serve any requests.
	</vals>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>If there is no response to this request,
	NIS is either not running or is in a state where it can't serve requests.</p>

	<h1>Account related requests</h1>

	<p>This chapter will guide you through the
	process of retrieving account information from a NEM Infrastructure Server. The
	information that can be retrieved is the durable account data, its meta data
	and information about transactions and harvested blocks.</p>

    <p>NIS supports two different kind of accounts: normal accounts and multsig (short for: multi signature) accounts:</p>

	<h4>Normal accounts:</h4>

	<p>Normal accounts are created and controlled
	by a private key. Any action for the account like sending NEM to another
	account via a transfer transaction is signed with this private key. If an
	attacker gains knowledge of the private key, he/she can rob the account. The
	private key must therefore be kept secret by all means.</p>

	<h4>Multisig accounts:</h4>

	<p>Multisig accounts can be created by
	converting a normal account to a multisig account via a <b>aggregate
	modification transaction</b>. This adds cosignatories to the account. After that
	modification, only the cosignatories can initiate an action for the account.
	Any action must be signed by all cosignatories. This makes a multisig account
	significantly more secure than a normal account. When a single cosignatory
	private key is gained by an attacker, the attacker still can't initiate any
	action on the account since <b>all</b> cosignatories must sign. It is strongly
	recommended to convert any account holding a significantly high amount of NEM
	into a multisig account with at least 3 cosignatories. Once converted to a
	multisig account, the original private key for the account plays no role any
	more.</p>

	<p>Durable data is either stored in the
	database or can be calculated from other database data. The corresponding JSON
	object is described in <appa>AccountInfo</appa>. It has the fields:</p>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>address</p>
			</td>
			<td>
				<p>Each account has a unique address. First letter of an address indicate
				the network the account belongs to. Currently two networks are defined: the
				test network whose account addresses start with a capital <b>T</b> and the main
				network whose account addresses always start with a capital <b>N</b>. Addresses have
				always a length of 40 characters and are <a href="http://en.wikipedia.org/wiki/Base32">base-32</a> encoded.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>balance</p>
			</td>
			<td>
				<p>Each account has a balance which is an integer greater or equal to
				zero and denotes the number of <b>micro</b> NEMs which the account owns. Thus a
				balance of 123456789 means the account owns 123.456789 NEM. A balance is
				split into its vested and unvested part. Only the vested part is relevant for
				the importance calculation. For transfers from one account to another only
				the balance itself is relevant.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>importance</p>
			</td>
			<td>
				<p>Each account is assigned an importance. The importance is a
				decimal number between 0 and 1. It denotes the probability of an account to
				harvest the next block in case the account has harvesting turned on and all
				other accounts are harvesting too. The exact formula for calculating the
				importance is not public yet. Accounts need at least 10k <b>vested</b> NEM to be
				included in the importance calculation.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>publicKey</p>
			</td>
			<td>
				<p>The public key of an account can be used
				to verify signatures of the account. Only accounts that have already
				published a transaction have a public key assigned to the account. Otherwise
				the field is null.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>label</p>
			</td>
			<td>
				<p>This field is not used yet and is always null.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>harvestedBlocks</p>
			</td>
			<td>
				<p>Harvesting is the process of generating new blocks. The field
				denotes the number of blocks that the account harvested so far. For a new
				account the number is 0.</p>
			</td>
		</tr>
	</table>


	<p>The meta data for an account describes the
	harvesting status of an account, and in case that the account is a cosignatory
	of at least one multisig account, the list of those multisig accounts. An
	account can either harvest with its current importance or delegate the
	harvesting to a so called remote account. In the latter case the remote account
	uses the importance of the original account to harvest. The corresponding JSON
	object and the possible values for the status/remoteStatus are described in
	<appa>AccountMetaDataPair</appa>. The meta
	data consists of the following fields:</p>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>status</p>
			</td>
			<td>
				<p>This field describes the harvesting status of an account.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>remoteStatus</p>
			</td>
			<td>
				<p>The field describes the status of remote harvesting.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>cosignatoryOf</p>
			</td>
			<td>
				<p>Array of AccountInfo structures that describe the multisig
				accounts that this account is cosignatory of.</p>
			</td>
		</tr>
	</table>


	<p>Known accounts have at least one incoming
	transaction. The corresponding JSON objects are described in <appa>Transaction</appa>, <alnk>TransactionMetaData</alnk> and <alnk>TransactionMetaDataPair</alnk>.</p>

	<p>A transaction has always the following fields:</p>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>timeStamp</p>
			</td>
			<td>
				<p>The number of seconds elapsed since the creation of the nemesis
				block. Future timestamps are not allowed. Transaction validation detects
				future timestamps and returns an error in that case. Network time
				synchronization ensures that any NEM software component will use valid timestamps
				when creating transactions.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>signature</p>
			</td>
			<td>
				<p>The transaction signature. The transaction signature is validated
				using the supplied public key in the field signer. If the signature is not
				valid, an error is returned from validation.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>fee</p>
			</td>
			<td>
				<p>The fee for the transaction. The higher the fee, the higher is the
				priority of the transaction. Transactions with high priority get included in
				a block before transactions with lower priority. If the sender does not have
				enough funds the validation will result in an error</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>type</p>
			</td>
			<td>
				<p>The transaction type. Currently the following types of
				transactions are supported:</p>
				<vals>
				0x101: Transfer of NEM from sender to recipient.
				0x801: Transfer of importance from sender to remote account.
				0x1001: An aggregate modification transaction, which converts a normal account into a multisig account.
				0x1002: A multisig signature transaction which is used to sign a multisig transaction.
				0x1003: A multisig transaction, which is used for multisig accounts.
				</vals>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>deadline</p>
			</td>
			<td>
				<p>The deadline of the transaction. The deadline is given as the
				number of seconds elapsed since the creation of the nemesis block. If a
				transaction does not get included in a block before the deadline is reached,
				it is deleted.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>version</p>
			</td>
			<td>
				<p>The version of the structure. The following version are currently support.</p>
                <li>0x68 << 24 + 1 (1744830465 as 4 byte integer): the main network version</li>
                <li>0x98 << 24 + 1 (-1744830463 as 4 byte integer): the test network version</li>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>signer</p>
			</td>
			<td>
				<p>The public key of the account that created the transaction. The
				public key is encoded as hexadecimal string.</p>
			</td>
		</tr>
	</table>

	<p>Depending on the type of the transaction, there are additional fields which are specific to given type.
        For instance a transfer transaction will have the additional fields.</p>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>recipient</p>
			</td>
			<td>
				<p>The address of the recipient. If the address is not valid an error
				is returned from validation.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>message</p>
			</td>
			<td>
				<p>Optionally a transfer transaction can contain a message.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>payload</p>
			</td>
			<td>
				<p>Optional field in case the transaction contains a message. The
				payload is the actual (possibly encrypted) message data. The payload is
				allowed to have a maximal size of 512 bytes. Transaction validation detects
				if the limit is exceeded and returns an error in this case.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>type</p>
			</td>
			<td>
				<p>Optional field in case the transaction contains a message. The
				field holds the message type information. Possible message types are:</p>
				<vals>
				1: The message is not encrypted.
				2: The message is encrypted.
				</vals>
			</td>
		</tr>
	</table>

	<p>Please refer to <a href="#appendix-A:-description-of-the-JSON-structures">Appendix A</a> for detailed information on the various transactions types and
	their additional fields.</p>

	<p>Transaction meta data contains only following field:</p>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>height</p>
			</td>
			<td>
				<p>The height of the block in which the transaction was included.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>id</p>
			</td>
			<td>
				<p>The id of the transaction.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>hash</p>
			</td>
			<td>
				<p>The hash of the transaction.</p>
			</td>
		</tr>
	</table>

	<p></p>

	<p>Accounts can harvest (i.e. generate new)
	blocks if they are lucky. The account which harvests a block collects the fees
	which are included in the transactions in the block. The information which
	blocks were harvested by an account can be requested. The request returns an
	array of HarvestInfo JSON objects. For an example see <appa>HarvestInfo</appa></p>

	<p>A harvest info object has the following fields:</p>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>timeStamp</p>
			</td>
			<td>
				<p>The number of seconds elapsed since the creation of the nemesis block.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>id</p>
			</td>
			<td>
				<p>The database id for the block.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>difficulty</p>
			</td>
			<td>
				<p>The block difficulty.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>totalFee</p>
			</td>
			<td>
				<p>The total fee collected by harvesting the block.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>height</p>
			</td>
			<td>
				<p>The height of the harvested block.</p>
			</td>
		</tr>
	</table>

	<p></p>

	<p>It is possible to request an array with the
	importance information for all accounts. The request returns an array of
	AccountImportanceViewModel JSON objects. For an example see
	<appa>AccountImportanceViewModel</appa>.</p>

	<p>An account importance view model has the following fields:</p>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>address</p>
			</td>
			<td>
				<p>The address of the account.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>importance</p>
			</td>
			<td>
				<p>Substructure that describes the importance of the account.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>isSet</p>
			</td>
			<td>
				<p>Indicates if the fields &quot;score&quot;, &quot;ev&quot; and &quot;height&quot; are available.</p>
				<p>isSet can have the values 0 or 1. In case isSet is 0 the following fields are not available.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>score</p>
			</td>
			<td>
				<p>The importance of the account. The importance ranges between 0 and 1.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>ev</p>
			</td>
			<td>
				<p>The page rank portion of the importance. The page rank ranges between 0 and 1.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>height</p>
			</td>
			<td>
				<p>The height at which the importance calculation was performed.</p>
			</td>
		</tr>
	</table>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h2>Retrieving account data</h2>

    <h3>Generating new account data</h3>
    <api get>/account/generate</api>

    <desc>
        <p class=NemNoSpacing>Generates a <a href="#keyPairViewModel">KeyPairViewModel</a>.</p>
    </desc>

    <h4>No Parameter:</h4>

    <h4>Example:</h4>

    <p><a href="http://127.0.0.1:7890/account/generate">http://127.0.0.1:7890/account/generate</a></p>

    <h4>Example of returned JSON object:</h4>

    <resp>

{
    "privateKey": "0962c6505d02123c40e858ff8ef21e2b7b5466be12c4770e3bf557aae828390f",
    "address": "NCKMNCU3STBWBR7E3XD2LR7WSIXF5IVJIDBHBZQT",
    "publicKey": "c2e19751291d01140e62ece9ee3923120766c6302e1099b04014fe1009bc89d3"
}

    </resp>

    <h4>Possible Errors:</h4>

    <p class=NemNoSpacing>None.</p>

    <!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
    <h3>Requesting the account data</h3>
	<api get>/account/get</api>

	<desc>
	<p class=NemNoSpacing>Gets an <a href="#accountMetaDataPair">AccountMetaDataPair</a> for an account.</p>
	</desc>

	<h4>Parameter:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>address</p>
			</td>
			<td>
				<p class=NemNoSpacing>The address of the account.</p>
			</td>
		</tr>
	</table>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/account/get?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS">http://127.0.0.1:7890/account/get?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS</a></p>

	<h4>Example of returned JSON object:</h4>

	<resp>
{
    "account":
    {
        "address": "TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS",
        "balance": 124446551689680,
        "vestedBalance": 104443451691625,
        "importance": 0.010263666447108395,
        "publicKey": "a11a1a6c17a24252e674d151713cdf51991ad101751e4af02a20c61b59f1fe1a",
        "label": null,
        "harvestedBlocks": 645
    },
    "meta":
    {
        "cosignatoryOf": [ ],
        "cosignatories": [ ],
        "status": "LOCKED",
        "remoteStatus": "ACTIVE"
    }
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>If the address parameter is not valid, NIS returns an error. See <alnk>Appendix B: NIS Errors</alnk> for details about errors.</p>

	<p></p>
	<p>Alternatively you can retrieve the account data by providing the public key for the account:</p>

	<api get>/account/get/from-public-key</api>

	<h4>Parameter:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>publicKey</p>
			</td>
			<td>
				<p class=NemNoSpacing>The public key of the account as hex string.</p>
			</td>
		</tr>
	</table>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/account/get/from-public-key?publicKey=f9bd190dd0c364261f5c8a74870cc7f7374e631352293c62ecc437657e5de2cd">http://127.0.0.1:7890/account/get/from-public-key?publicKey=f9bd190dd0c364261f5c8a74870cc7f7374e631352293c62ecc437657e5de2cd</a></p>

	<p>The returned JSON object has the same structure as in the first example.</p>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>If the public key parameter is not valid, NIS returns an error. See <alnk>Appendix B: NIS Errors</alnk> for details about errors.</p>

	<h3>Requesting the original account data for a delegate account</h3>
	<api get>/account/get/forwarded</api>

	<desc>
		<p class=NemNoSpacing>Given a delegate (formerly known as remote) account's address, gets the <a href="#accountMetaDataPair">AccountMetaDataPair</a>
			for the account for which the given account is the delegate account. If the given account address is not a delegate account for any account, the
		request returns the <a href="#accountMetaDataPair">AccountMetaDataPair</a> for the given address.</p>
	</desc>

	<h4>Parameter:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>address</p>
			</td>
			<td>
				<p class=NemNoSpacing>The address of the delegate account.</p>
			</td>
		</tr>
	</table>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/account/get/forwarded?address=NC2ZQKEFQIL3JZEOB2OZPWXWPOR6LKYHIROCR7PK">http://127.0.0.1:7890/account/get/forwarded?address=NC2ZQKEFQIL3JZEOB2OZPWXWPOR6LKYHIROCR7PK</a></p>

	<h4>Example of returned JSON object:</h4>

	<resp>
{
	"account":
    {
        "address": "NALICE2A73DLYTP4365GNFCURAUP3XVBFO7YNYOW",
        "balance": 11793338398661,
        "vestedBalance": 10890953464862,
        "importance": 0.001264596432148395,
        "publicKey": "bdd8dd702acb3d88daf188be8d6d9c54b3a29a32561a068b25d2261b2b2b7f02",
        "label": null,
        "harvestedBlocks": 742
    },
    "meta":
    {
        "cosignatoryOf": [ ],
        "cosignatories": [ ],
        "status": "LOCKED",
        "remoteStatus": "ACTIVE"
    }
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>If the address parameter is not valid, NIS returns an error. See <alnk>Appendix B: NIS Errors</alnk> for details about errors.</p>

	<p></p>
	<p>Alternatively you can retrieve the original account data by providing the public key of the delegate account:</p>

	<api get>/account/get/forwarded/from-public-key</api>

	<h4>Parameter:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>publicKey</p>
			</td>
			<td>
				<p class=NemNoSpacing>The public key of the account as hex string.</p>
			</td>
		</tr>
	</table>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/account/get/forwarded/from-public-key?publicKey=bdd8dd702acb3d88daf188be8d6d9c54b3a29a32561a068b25d2261b2b2b7f02">http://127.0.0.1:7890/account/get/forwarded/from-public-key?publicKey=bdd8dd702acb3d88daf188be8d6d9c54b3a29a32561a068b25d2261b2b2b7f02</a></p>

	<p>The returned JSON object has the same structure as in the first example.</p>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>If the public key parameter is not valid, NIS returns an error. See <alnk>Appendix B: NIS Errors</alnk> for details about errors.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h3>Requesting the account status</h3>
	<api get>/account/status</api>

	<desc>
	<p class=NemNoSpacing>Gets the <a href="#accountMetaData">AccountMetaData</a> from an account.</p>
	</desc>

	<h4>Parameter:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>Address</p>
			</td>
			<td>
				<p class=NemNoSpacing>The address of the account.</p>
			</td>
		</tr>
	</table>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/account/status?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS">http://127.0.0.1:7890/account/status?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS</a></p>

	<h4>Example of returned JSON object:</h4>

	<resp>
{
    "cosignatoryOf": [ ],
    "status": "LOCKED",
    "remoteStatus": "ACTIVE"
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>If the address parameter is not valid,
	NIS returns an error. See <alnk>Appendix B: NIS Errors</alnk> for details about errors.</p>

	<h3>Requesting transaction data for an account</h3>

	<p>A transaction is said to be incoming with
	respect to an account if the account is the recipient of the transaction. In
	the same way outgoing transaction are the transactions where the account is the
	sender of the transaction. Unconfirmed transactions are those transactions that
	have not yet been included in a block. Unconfirmed transactions are <b>not</b>
	guaranteed to be included in any block.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h4>Incoming transactions</h4>
	<api get>/account/transfers/incoming</api>
	<desc>
	<p class=NemNoSpacing>Gets an array of <a href="#transactionMetaDataPair">TransactionMetaDataPair</a> objects
    where the recipient has the address given as parameter to the request. A
	maximum of 25 transaction meta data pairs is returned. The returned transaction
	meta data pairs are sorted in descending order in which they were written to
	the database.</p>

    <p class=NemNoSpacing> The second parameter is optional. When it's not present, the
	request will return newest transactions according to the above criteria. When hash
	is supplied as second parameter, the request will return up to 25 transactions
	that appeared directly before the transaction that has the supplied hash sorted
	according to the above criteria.</p>

	<p class=NemNoSpacing>The third parameter is optional. When an
	id is supplied as third parameter, the request will return up to 25
	transactions that appeared directly before the transaction that has the
	supplied id sorted according to the above criteria.</p>

	<p class=NemNoSpacing>If less than 25 transactions fulfill the
	requirements, only those transactions are returned.</p>

	<p class=NemNoSpacing></p>
	</desc>

	<h4>Parameters:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>address</p> </td>
			<td>
				<p class=NemNoSpacing>The address of the account.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>hash</p>
			</td>
			<td>
				<p class=NemNoSpacing>The 256 bit sha3 hash of the
				transaction up to which transactions are returned.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>id </p>
			</td>
			<td>
				<p class=NemNoSpacing>The transaction id up to which
				transactions are returned.</p>
			</td>
		</tr>
	</table>

	<h4></h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/account/transfers/incoming?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS&amp;hash=949583a20ebdfdcb58277eb42fef3e66e9e6bbfc47304d8741a82c68f7c53a2">http://127.0.0.1:7890/account/transfers/incoming?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS&amp;hash=949583a20ebdfdcb58277eb42fef3e66e9e6bbfc47304d8741a82c68f7c53a2</a></p>

	<h4>Example of returned JSON object (test network):</h4>

	<resp>
{
       "data": [
       {
              "meta":
              {
                     "id": 71245,
                     "height": 40706,
                     "hash": {
                         "data":"15c373ad4c3fe6af47d1941379ff262f785bdcfa07c02ac3608bc10da27d5e82"
                     }
              },
              "transaction":
              {
                     "timeStamp": 9106400,
                     "amount": 1000000000,
                     "signature": "449cd76ea8bda2220b3d6ad6f8db5f81d4e68ad3d4b0c3db9a3c267355657639eabed3dbcef8e0cc22953ae2b36a22ee7dc6327484c9649cccd686a511eca105",
                     "fee": 3000000,
                     "recipient": "TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS",
                     "type": 257,
                     "deadline": 9149600,
                     "message":
                     {
                           "payload": "280000005444334b32493543524850595634425a5a5a4c335850454e4",
                           "type": 2
                     },
                     "version": -1744830463,
                     "signer": "c20a1dffe699c7a68328986273265e33fceebe074f274240ef890dd80ad55ed6"
              }
       },
       {
              "meta":
              {
                     "id": 71356,
                     "height": 40629,
                     "hash": {
                         "data":"37c34ead4c3fe6af42d994135798262f785ba2d807c02ac3608bc10da12e5f87"
                     }
              },
              "transaction":
              {
                     "timeStamp": 9101541,
                     "amount": 49997995000000,
                     "signature": "57c3c48d2ae8b24240b57d72493f498cfeb61e2ab87237dc0e08c51007d5c7f15847d0e08c0286e68a72028925db5fa809ca9d57e2cb6eebe11822176a834c0b",
                     "fee": 2005000000,
                     "recipient": "TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS",
                     "type": 257,
                     "deadline": 9144741,
                     "message":
                     {
                           "payload": "526f6262657279212121",
                           "type": 1
                     },
                     "version": -1744830463,
                     "signer": "546e4fb9c81db84e04d8e9e67380db0fe1f540df09a527fb995b589b5695ae24"
              }
       }]
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>If the address parameter is not valid or
	the id cannot be found in the database, NIS returns an error. See <alnk>Appendix B: NIS Errors</alnk> for details about errors.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h4>Outgoing transactions</h4>
	<api get>/account/transfers/outgoing</api>

	<desc>
	<p class=NemNoSpacing>Gets an array of transaction meta data
	pairs where the recipient has the address given as parameter to the request. A
	maximum of 25 transaction meta data pairs is returned. For details about
	sorting and discussion of the second parameter see <a href="#incoming-transactions">Incoming transactions</a>.</p>
	</desc>
	<h4>Parameters:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>address</p>
			</td>
			<td>
				<p class=NemNoSpacing>The address of the account.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>hash</p>
			</td>
			<td>
				<p class=NemNoSpacing>The 256 bit sha3 hash of the
				transaction up to which transactions are returned.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>id </p>
			</td>
			<td>
				<p class=NemNoSpacing>The transaction id up to which
				transactions are returned.</p>
			</td>
		</tr>
	</table>

	<h4></h4>

	<h4>Example:</h4>

	<p class=NemNoSpacing><a href="http://127.0.0.1:7890/account/transfers/outgoing?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS&amp;hash=949583a20ebdfdcb58277eb42fef3e66e9e6bbfc47304d8741a82c68f7c53a22">http://127.0.0.1:7890/account/transfers/outgoing?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS&amp;hash=949583a20ebdfdcb58277eb42fef3e66e9e6bbfc47304d8741a82c68f7c53a22</a></p>

	<h4>Example of returned JSON object (test network):</h4>

	<resp>
{
       "data": [
       {
              "meta":
              {
                     "id": 70498,
                     "height": 40803,
                     "hash": {
                         "data":"37c34ead4c3fe6af42d994135798262f785ba2d807c02ac3608bc10da12e5f87"
                     }
              },
              "transaction":
              {
                     "timeStamp": 9111526,
                     "amount": 1000000000,
                     "signature": "651a19ccd09c1e0f8b25f6a0aac5825b0a20f158ca4e0d78f2abd904a3966b6e3599a47b9ff199a3a6e1152231116fa4639fec684a56909c22cbf6db66613901",
                     "fee": 3000000,
                     "recipient": "TDGIMREMR5NSRFUOMPI5OOHLDATCABNPC5ID2SVA",
                     "type": 257,
                     "deadline": 9154726,
                     "message":
                     {
                           "payload": "74657374207472616e73616374696f6e",
                           "type": 1
                     },
                     "version": -1744830463,
                     "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
              }
       }]
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>If the address parameter is not valid or
	the id cannot be found in the database, NIS returns an error. See <alnk>Appendix B: NIS Errors</alnk> for details about errors.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h4>All transactions</h4>
	<api get>/account/transfers/all</api>

	<desc>
	<p class=NemNoSpacing>Gets an array of transaction meta data
	pairs for which an account is the sender or receiver. A maximum of 25
	transaction meta data pairs is returned. For details about sorting and
	discussion of the second parameter see <a href="#incoming-transactions">Incoming transactions</a>.</p>
	</desc>

	<h4>Parameters:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>address</p>
			</td>
			<td>
				<p class=NemNoSpacing>The address of the account.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>hash</p>
			</td>
			<td>
				<p class=NemNoSpacing>The 256 bit sha3 hash of the
				transaction up to which transactions are returned.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>id </p>
			</td>
			<td>
				<p class=NemNoSpacing>The transaction id up to which
				transactions are returned.</p>
			</td>
		</tr>
	</table>

	<h4></h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/account/transfers/all?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS&amp;hash=949583a20ebdfdcb58277eb42fef3e66e9e6bbfc47304d8741a82c68f7c53a22">http://127.0.0.1:7890/account/transfers/all?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS&amp;hash=949583a20ebdfdcb58277eb42fef3e66e9e6bbfc47304d8741a82c68f7c53a22</a></p>

	<h4>Example of returned JSON object:</h4>

	<p class=NemNoSpacing>See example for <a href="#incoming-transactions">Incoming transactions</a> or <a href="#outgoing-transactions">Outgoing transactions</a>.</p>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>If the address parameter is not valid or
	the id cannot be found in the database, NIS returns an error. See <alnk>Appendix B: NIS Errors</alnk> for details about errors.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h4>Unconfirmed transactions</h4>

	<api get>/account/unconfirmedTransactions</api>


	<desc>
	<p class=NemNoSpacing>Gets the array of transactions for which
	an account is the sender or receiver and which have not yet been included in a
	block. The returned structure is UnconfirmedTransactionMetaDataPair see
	<appa>UnconfirmedTransactionMetaDataPair</appa></p>
	</desc>

	<h4>Parameters:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>address</p>
			</td>
			<td>
				<p class=NemNoSpacing>The address of the account.</p>
			</td>
		</tr>
	</table>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/account/unconfirmedTransactions?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS">http://127.0.0.1:7890/account/unconfirmedTransactions?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS</a></p>

	<h4>Example of returned JSON object (test network):</h4>

	<resp>
{
       "meta": {
           "data": "d7c9e33421e43bf4a5d6e21304c8096c599142755d581bd6e9037f41545a5873"
       },
       "data": [
       {
              "timeStamp": 9131839,
              "amount": 1000000000,
              "signature": "0acface77696a54340a7da8592750ea0410f62717d07e4df30e09718092521262465df5c4d98d32cd9d6e8699d66e016ec8db716d20090ad99cc16f7a6d13904",
              "fee": 2000000,
              "recipient": "TDGIMREMR5NSRFUOMPI5OOHLDATCABNPC5ID2SVA",
              "type": 257,
              "deadline": 9175039,
              "message": {
                     "payload": "",
                     "type": 1
              },
              "version": -1744830463,
              "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
       }]
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>If the address parameter is not valid,
	NIS returns an error. See <alnk>Appendix B: NIS Errors</alnk> Errors for details about errors.</p>

    <h3>Transaction data with decoded messages</h3>

    <p>All the requests for retrieving transaction data for an account which were described in previous part
        do not decode any message contained in a transaction.
        The following requests are similar to the ones above but are able to return transaction data with decoded messages.
        Decoding requires the private key of an account for which transactions are requested.
    Therefore the following requests <b>should only be done when NIS is running locally</b>.</p>

    <h4>Incoming/outgoing/all transactions with decoded messages</h4>
    <api post>/local/account/transfers/incoming</api>
    <api post>/local/account/transfers/outgoing</api>
    <api post>/local/account/transfers/all</api>

    <desc>
    <p class=NemNoSpacing>The request returns incoming/outgoing/all transactions as described in the previous chapter.
        The only difference is that if a transaction contains an encoded message, this message will be decoded before it is
        sent to the requester.</p>
	</desc>

    <h4>Parameters:</h4>

    <table class=NemTableGrid>
        <tr>
            <td>
                <p class=JSON>page</p>
            </td>
            <td>
                <p class=NemNoSpacing>An AccountPrivateKeyTransactionsPage
                    JSON object as described in <appa>AccountPrivateKeyTransactionsPage</appa></p>
            </td>
        </tr>
    </table>

    <h4>Example:</h4>

    <p>Request cannot be performed in a browser.</p>

    <h4>Example of returned JSON object:</h4>

	<p>See section: <a href="#requesting-transaction-data-for-an-account">Requesting transaction data for an account</a></p>

    <h4>Possible Errors:</h4>

    <p class=NemNoSpacing>If the private key is not supplied, NIS returns an error.
        See <alnk>Appendix B: NIS Errors</alnk> for details about errors.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h3>Requesting harvest info data for an account</h3>

	<api get>/account/harvests</api>


	<desc>
	<p class=NemNoSpacing>Gets an array of harvest info objects
	for an account.</p>
	</desc>

	<h4>Parameter:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>address</p>
			</td>
			<td>
				<p class=NemNoSpacing>The address of the account.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>hash </p>
			</td>
			<td>
				<p class=NemNoSpacing>The 256 bit sha3 hash of the block up to which harvested blocks are returned.</p>
			</td>
		</tr>
	</table>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/account/harvests?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS&amp;hash=81d52a7df4abba8bb1613bcc42b6b93cf3114524939035d88ae8e864cd2c34c8">http://127.0.0.1:7890/account/harvests?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS&amp;hash=81d52a7df4abba8bb1613bcc42b6b93cf3114524939035d88ae8e864cd2c34c8</a></p>

	<h4>Example of returned JSON object:</h4>

	<resp>
{
       "data": [{
              "timeStamp": 8879051,
              "blockHash": {
                     "data": "be3bb308ce33625f0dab64fd31b9ebe1c50dd4b94b43b03c228f481ab82458c3"
              },
              "totalFee": 102585065,
              "height": 37015
       }]
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>If the address parameter is not valid or
	the hash cannot be found in the database, NIS returns an error. See <alnk>Appendix B: NIS Errors</alnk> Errors for details about errors.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h3>Retrieving account importances for accounts</h3>

	<api get>/account/importances</api>


	<desc>
	<p class=NemNoSpacing>Gets an array of account importance view model objects.</p>
	</desc>

	<h4>No parameter:</h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/account/importances">http://127.0.0.1:7890/account/importances</a></p>

	<h4>Example of returned JSON object:</h4>

	<resp>
{
       "data": [{
              "address": "TCYGT6GHZPNASMAXV7YCFCU5R5XTJKNNT66R4A4T",
              "importance": {
                     "isSet": 0
              }
       },
       {
              "address": "TD2JJJVPKDZFXWK3N3ZJLN7A5TGNOTM3J5EVSTIG",
              "importance": {
                     "score": 0.001222376902598832,
                     "ev": 0.004252356221747241,
                     "isSet": 1,
                     "height": 40926
              }
       }]
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>None.</p>

	<h3>Locking and unlocking accounts</h3>

	<p>Accounts that have at least 10000 vested
	NEM balance are allowed to harvest blocks. To do that the account must be
	unlocked. After start-up of NIS all accounts are locked by default.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h4>Unlocking the account (enables harvesting)</h4>

	<api post>/account/unlock</api>


	<desc>
	<p class=NemNoSpacing>Unlocks an account (starts harvesting).</p>
	</desc>

	<h4>Parameter:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON><b><span style='color:#C00000'>privateKey</span></b></p>
			</td>
			<td>
				<p class=NemNoSpacing>A PrivateKey JSON object as described in <appa>PrivateKey</appa></p>
			</td>
		</tr>
	</table>

	<h4>Example:</h4>

	<p class=NemNoSpacing>Request cannot be performed in a browser.</p>

	<h4>No return value</h4>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h4>Locking the account (stops harvesting)</h4>

	<api post>/account/lock</api>


	<desc>
	<p class=NemNoSpacing>Locks an account (stops harvesting).</p>
	</desc>

	<h4>Parameter:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON><b><span style='color:#C00000'>privateKey</span></b></p>
			</td>
			<td>
				<p class=NemNoSpacing>A PrivateKey JSON object as described in <appa>PrivateKey</appa></p>
			</td>
		</tr>
	</table>


	<h4>Example:</h4>

	<p class=NemNoSpacing>Request cannot be performed in a browser.</p>

	<h4>No return value</h4>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>Both requests return an error if the
	private key does not correspond to a known account or the account is not
	allowed to harvest. See <alnk>Appendix B: NIS Errors</alnk> for details about errors.</p>

	<h3>Retrieving the unlock info</h3>

	<p>Each node can allow users to harvest with their delegated key on that node.
		The NIS configuration has entries for configuring the maximum number of allowed harvesters
		and optionally allow harvesting only for certain account addresses. The unlock info gives
		information about the maximum number of allowed harvesters and how many harvesters are already
		using the node.
	</p>

	<api post>/account/unlocked/info</api>

	<h4>No parameter:</h4>

	<h4>Example:</h4>

	<p class=NemNoSpacing>Request cannot be performed in a browser.</p>

	<h4>Example of returned JSON object:</h4>

	<resp>
{
    "num-unlocked" : 2,
    "max-unlocked" : 3
}
	</resp>

	<h4>Possible Errors:</h4>

	<p>None</p>

	<h2>Retrieving historical account data</h2>

    <p>The configuration for NIS offers the possibility for a node to expose additional features
    that other nodes don't want to offer. One of those features is the supply of historical account
    data like balance and importance information. To turn on this feature for your NIS, you need to add
    HISTORICAL_ACCOUNT_DATA to the list of optional features in the file config.properties.</p>

    <api get>/account/historical/get</api>

    <desc>
        <p class=NemNoSpacing>Gets historical information for an account.</p>
    </desc>

    <h4>Parameter:</h4>

    <table class=NemTableGrid>
        <tr>
            <td>
                <p class=JSON>address</p>
            </td>
            <td>
                <p class=NemNoSpacing>The address of the account.</p>
            </td>
        </tr>
        <tr>
            <td>
                <p class=JSON>startHeight</p>
            </td>
            <td>
                <p class=NemNoSpacing>The block height from which on the data should be supplied.</p>
            </td>
        </tr>
        <tr>
            <td>
                <p class=JSON>endHeight</p>
            </td>
            <td>
                <p class=NemNoSpacing>The block height up to which the data should be supplied.
                The end height must be greater than or equal to the start height.</p>
            </td>
        </tr>
        <tr>
            <td>
                <p class=JSON>increment</p>
            </td>
            <td>
                <p class=NemNoSpacing>The value by which the height is incremented between each data point.
                The value must be greater than 0. NIS can supply up to 1000 data points with one request.
                Requesting more than 1000 data points results in an error.</p>
            </td>
        </tr>
    </table>

    <h4>Example:</h4>

    <p><a href="http://bigalice3.nem.ninja:7890/account/historical/get?address=NALICELGU3IVY4DPJKHYLSSVYFFWYS5QPLYEZDJJ&amp;startHeight=17592&amp;endHeight=17592&amp;increment=1">
        http://bigalice3.nem.ninja:7890/account/historical/get?address=NALICELGU3IVY4DPJKHYLSSVYFFWYS5QPLYEZDJJ&amp;startHeight=17592&amp;endHeight=17592&amp;increment=1</a></p>

    <h4>Example of returned JSON object:</h4>

    <resp>
{
    [
        {
          "height": 17592,
          "address": "NALICELGU3IVY4DPJKHYLSSVYFFWYS5QPLYEZDJJ",
          "balance": 509676000000,
          "vestedBalance": 100999147150,
          "unvestedBalance": 408676852850,
          "importance": 0.00008857563463531297,
          "pageRank": 0.0007605047835049349
        }
    ]
}
    </resp>

    <h4>Possible Errors:</h4>

    <p class=NemNoSpacing>If the address is invalid, the start height is larger than the endheight, the increment
        is not a positive or the request results in more than 1000 data points an error is returned.</p>

    <h1>Block chain related requests</h1>

	<p>NEM builds a block chain which contains every
	bit of information needed. Subsequent blocks in the block chain have increasing
	heights that differ by one. Each block can contain transactions. Transactions
	build the basis of all account activity. It is therefore important to
	understand the concept and the structures of blocks and transactions.</p>

	<p>Blocks are generated by accounts. If an
	account generates a block and the block gets included in the block chain, the
	generating account, called the harvester, gets all the transaction fees for
	transactions that are included in the block. A harvester will therefore usually
	include as many transactions as possible.</p>

	<p>Transactions reflect all account
	activities. In order for a client to have an up to date balance for every
	account it is crucial to know about every transaction that occurred and
	therefore the client must have knowledge about every single block in the chain
	(one says: the client must be synchronized with the block chain).</p>

	<p>Whenever timestamps are used, the time
	reflects the network time. NEM has a time synchronization mechanism which lets
	all node agree on how many seconds since the nemesis have elapsed. This common
	time is called network time.</p>

	<p>The following chapters will first introduce
	the fields used in the block and transaction structure and then explain how a
	client can request parts of the block chain.</p>

	<p>Blocks are transferred using a JSON Block
	object. <appa>Block</appa> has more information and an example JSON Block object. The
	following fields are in the structure:</p>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>timeStamp</p>
			</td>
			<td>
				<p>The network time when the block was created.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>signature</p>
			</td>
			<td>
				<p>The signature of the block. All blocks in the chain are signed by
				the harvesters.</p>
				<p>This way any node can check if the block has been altered by some
				evil entity.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>prevBlockHash</p>
			</td>
			<td>
				<p>The sha3-256 hash of the previous block as hexadecimal string.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>type</p>
			</td>
			<td>
				<p>The block type. There are currently two block types used:</p>
				<vals>
				-1: Nemesis block type. This block type appears only once in the chain.
				1: Regular block type. All blocks with height &gt; 1 have this type.
				</vals>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>transactions</p>
			</td>
			<td>
				<p>The array of transactions. See <appa>Transaction</appa>
				for more details. A block can contain up to 120 transactions.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>version</p>
			</td>
			<td>
				<p>The block version. The following versions are supported:</p>
                <li>0x68 << 24 + 1 (1744830465 as 4 byte integer): the main network version</li>
                <li>0x98 << 24 + 1 (-1744830463 as 4 byte integer): the test network version</li>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>signer</p>
			</td>
			<td>
				<p>The public key of the harvester of the block as hexadecimal
				string.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>height</p>
			</td>
			<td>
				<p>The height of the block. Each block has a unique height.
				Subsequent blocks differ in height by 1.</p>
			</td>
		</tr>
	</table>

	<p>Transactions were already discussed in
	chapter 2 <a href="#account-related-requests">Account related requests</a>. See also <appa>Transaction</appa>
	for an example JSON transaction object.</p>

	<h2>Requesting the block chain status information</h2>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h3>Block chain height</h3>

	<api get>/chain/height</api>


	<desc>
	<p class=NemNoSpacing>Gets the current height of the block chain.</p>
	</desc>

	<h4>No parameter:</h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/chain/height">http://127.0.0.1:7890/chain/height</a></p>

	<h4>Example of returned JSON object:</h4>

	<resp>
{
       "height": 42799
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>None.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h3>Block chain score</h3>

	<api get>/chain/score</api>

	<desc>
	<p class=NemNoSpacing>Gets the current score of the block
	chain. The higher the score, the better the chain. During synchronization,
	nodes try to get the best block chain in the network.</p>
	</desc>

	<h4>No parameter:</h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/chain/score">http://127.0.0.1:7890/chain/score</a></p>

	<h4>Example of returned JSON object:</h4>

	<resp>
{
       "score": "18722d5a7d590deb"
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>None.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h3>Last block of the block chain score</h3>

	<api get>/chain/last-block</api>


	<desc>
	<p class=NemNoSpacing>Gets the current last block of the
	chain.</p>
	</desc>

	<h4>No parameter:</h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/chain/last-block">http://127.0.0.1:7890/chain/last-block</a></p>

	<h4>Example of returned JSON object (main network):</h4>

	<resp>
{
       "timeStamp": 9232968,
       "signature": "0a1351ef3e9b19c601e804a6d329c9ade662051d1da2c12c3aec9934353e421c79de7d8e59b127a8ca9b9d764e3ca67daefcf1952f71bc36f747c8a738036b05",
       "prevBlockHash": {
              "data": "58efa578aea719b644e8d7c731852bb26d8505257e03a897c8102e8c894a99d6"
       },
       "type": 1,
       "transactions": [
       ],
       "version": 1744830465,
       "signer": "2afca04d2cb8d16cf3656274bc55b95e60be823cfb7230d82f791ed42a309ee7",
       "height": 42804
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>None.</p>

	<h2>Requesting parts of the block chain</h2>

	<p>NIS can supply either individual blocks
	identified by block height or block hash or can supply up to 10 blocks
	beginning at a certain height.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h3>Getting a block with a given hash</h3>

	<api get>/block/get</api>


	<desc>
	<p class=NemNoSpacing>Gets a block from the chain that has a
	given hash.</p>
	</desc>

	<h4>Parameter:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>blockHash </p>
			</td>
			<td>
				<p class=NemNoSpacing>The 256 bit sha3 hash of the block.
				The hash must be supplied as hexadecimal string.</p>
			</td>
		</tr>
	</table>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/block/get?blockHash=58efa578aea719b644e8d7c731852bb26d8505257e03a897c8102e8c894a99d6">http://127.0.0.1:7890/block/get?blockHash=58efa578aea719b644e8d7c731852bb26d8505257e03a897c8102e8c894a99d6</a></p>

	<h4>Example of returned JSON object (main network):</h4>

	<resp>
{
       "timeStamp": 9232942,
       "signature": "005f91b8908fc173a428ff8e8c4a0ee0d69e4004aed0d08f27690b6b6672ef74ccc6b89695bed5f29b0f4a812cb84bfa459f52a4e14a11e574793969f0e1a30f",
       "prevBlockHash": {
              "data": "f721e563b4431594c5af6f6be0a913f47f0aca6c3b8ee6a703bfe175ee54babf"
       },
       "type": 1,
       "transactions": [
       ],
       "version": 1744830465,
       "signer": "78e121cc1cf63424651ec64251e78efda81386c9f5e9eb4cb08b2a2192c9dce5",
       "height": 42803
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>If the block hash is not found in the
	database, NIS will return a JSON error object. See <appa>Error object</appa> or more information of the error object and <alnk>Appendix B: NIS Errors</alnk> for the error message.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h3>Getting a block with a given height</h3>

	<api post>/block/at/public</api>


	<desc>
	<p class=NemNoSpacing>Gets a block from the chain that has the given height.</p>
	</desc>

	<h4>Parameter:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>blockHeight </p>
			</td>
			<td>
				<p class=NemNoSpacing>A BlockHeight JSON object as described
				in <appa>BlockHeight</appa>.</p>
			</td>
		</tr>
	</table>

	<h4>Example:</h4>

	<p class=NemNoSpacing>Request cannot be performed in a browser.</p>

	<h4>Example of returned JSON object (test network):</h4>

	<resp>
{
       "timeStamp": 9232942,
       "signature": "005f91b8908fc173a428ff8e8c4a0ee0d69e4004aed0d08f27690b6b6672ef74ccc6b89695bed5f29b0f4a812cb84bfa459f52a4e14a11e574793969f0e1a30f",
       "prevBlockHash": {
              "data": "f721e563b4431594c5af6f6be0a913f47f0aca6c3b8ee6a703bfe175ee54babf"
       },
       "type": 1,
       "transactions": [
       ],
       "version": -1744830463,
       "signer": "78e121cc1cf63424651ec64251e78efda81386c9f5e9eb4cb08b2a2192c9dce5",
       "height": 42803
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>If the block with the specified height
	cannot be found in the database, NIS will return a JSON error object. See <appa>Error object</appa> or more information of the error object and <alnk>Appendix B: NIS Errors</alnk> the error message.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h3>Getting part of a chain</h3>

	<api post>/local/chain/blocks-after</api>


	<desc>
	<p class=NemNoSpacing>Gets up to 10 blocks after given block height from the chain.
        If the database contains less than 10 block after the given height, then less blocks are returned.
        The returned data is an array of <a href="#explorerBlockViewModel">ExplorerBlockViewModel</a> JSON objects.</p>
	</desc>

	<h4>Parameter:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>blockHeight </p>
			</td>
			<td>
				<p class=NemNoSpacing>A BlockHeight JSON object as described
				in <appa>BlockHeight</appa>.</p>
			</td>
		</tr>
	</table>

	<h4>Example:</h4>

	<p class=NemNoSpacing>Request cannot be performed in a browser.</p>

	<h4>Example of returned JSON object:</h4>
	
	<resp>
{
	"data":[{
		"txes":[{
			"tx": &lt;ExplorerViewModelTransaction&gt;
			"tx": &lt;ExplorerViewModelTransaction&gt;
		}],
		"block": &lt;Block&gt;
		"hash":"8ca8a3e01ac0eb482e668fda74141984ba118b027fc5f1f67d2d36a38bf48c49"
	}]
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>If the block height supplied is not
	positive, NIS will return a JSON error object. See <appa>Error object</appa><b> </b>for more information of the error
	object and <alnk>Appendix B: NIS Errors</alnk> for the error message.</p>

	<h1>Node related requests</h1>

	<p>Nodes are the entities that exchange data
	in a network. A node is essentially a NIS instance running on a computer. To be
	able to communicate with the network, a node needs to be booted. Through node
	requests it is possible to discover other nodes in the network, learn about
	other nodes experiences and get information about their current chain height.</p>

	<p>Node structure consists of 3 parts:
	identity, endpoint and meta data:</p>

	<p>Every node is tied to an identity which is
	represented by an account. That way nodes are easier to identify. A node is
	given an identity during the boot process.</p>

	<p>The endpoint of a node holds information
	about the IP address, the port and the protocol used for communication.</p>

	<p>The meta data holds additional information
	about the NIS version and the platform NIS is running on.</p>

	<p>A node groups the set of neighbor nodes
	into several subsets by assigning a status to each node. The possible statuses
	are:</p>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>active</p>
			</td>
			<td>
				<p>Nodes that have this status can be successfully communicated with.
				Whenever a node is selecting a node for communication, it will pick a node
				from the set of active nodes.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>inactive</p>
			</td>
			<td>
				<p>Inactive nodes are nodes with which it is not possible to
				establish a connection.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>busy</p>
			</td>
			<td>
				<p>A node is set to status 'busy' if a connection can be established
				but the node did not answer a request within a certain time limit.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>failure</p>
			</td>
			<td>
				<p>The status failure is assigned to a remote node in case there is
				severe error during communication. This can for instance be due to the remote
				node using a different protocol or the remote node using an identity
				different from what was expected.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>unknown</p>
			</td>
			<td>
				<p>This status is given to a node if there is no information about
				the status available.</p>
			</td>
		</tr>
	</table>

	<p><appa>Node</appa> has more information and an example JSON Node object. A node object has the following fields:</p>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>name</p>
			</td>
			<td>
				<p>The name of the node. This can be any string.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>public-key</p>
			</td>
			<td>
				<p>The public key used to identify the node.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>protocol</p>
			</td>
			<td>
				<p>The protocol used for the communication (currently only HTTP is
				supported).</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>port</p>
			</td>
			<td>
				<p>The port used for the communication.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>host</p>
			</td>
			<td>
				<p>The IP address of the endpoint.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>application</p>
			</td>
			<td>
				<p>The name of the application that is running the node.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>version</p>
			</td>
			<td>
				<p>The version of the application.</p>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>platform</p>
			</td>
			<td>
				<p>The underlying platform (OS, java version).</p>
			</td>
		</tr>
	</table>

	<h2>Requesting information about a node</h2>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h3>Basic node information</h3>

	<api get>/node/info</api>


	<desc>
	<p class=NemNoSpacing>Gets basic information about a node.
	Using IP 127.0.0.1 gets information about the local node.</p>
	</desc>

	<h4>No parameter:</h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/node/info">http://127.0.0.1:7890/node/info</a></p>

	<h4>Example of returned JSON <a href="#node">Node</a></h4>

	<resp>
{
       "metaData":
       {
              "application": "NIS",
              "version": "0.4.33-BETA",
              "platform": "Oracle Corporation (1.8.0_25) on Windows 8"
       },
       "endpoint":
       {
              "protocol": "http",
              "port": 7890,
              "host": "81.224.224.156"
       },
       "identity":
       {
              "name": "Alice",
              "public-key": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
       }
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>In case the node has not been booted
	yet, NIS will return a JSON error object. See <appa>Error object</appa><b> </b>for more information of the error
	object and <alnk>Appendix B: NIS Errors</alnk> for the error message.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h3>Extended node information</h3>

	<api get>/node/extended-info</api>


	<desc>
	<p class=NemNoSpacing>Gets extended information about a node.
	Using IP 127.0.0.1 gets extended information about the local node.</p>
	</desc>

	<h4>No parameter:</h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/node/extended-info">http://127.0.0.1:7890/node/extended-info</a></p>

	<h4>Example of returned JSON <a href="#nisNodeInfo">NisNodeInfo</a> object:</h4>

	<resp>
{
       "node": {
              "metaData":
              {
                     "application": "NIS",
                     "version": "0.4.33-BETA",
                     "platform": "Oracle Corporation (1.8.0_25) on Windows 8"
              },
              "endpoint":
              {
                     "protocol": "http",
                     "port": 7890,
                     "host": "81.224.224.156"
              },
              "identity":
              {
                     "name": "Alice",
                     "public-key": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
              }
       },
       "nisInfo":
       {
              "currentTime": 9288341,
              "application": "NEM Infrastructure Server",
              "startTime": 9238484,
              "version": "0.4.33-BETA",
              "signer": "CN=VeriSign Class 3 Code Signing 2010 CA,OU=Terms of use at https://www.verisign.com/rpa (c)10,OU=VeriSign Trust Network,O=VeriSign\\, Inc.,C=US"
       }
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>In case the node has not been booted
	yet, NIS will return a JSON error object. See <appa>Error object</appa><b> </b>for more information of the error
	object and <alnk>Appendix B: NIS Errors</alnk> for the error message.</p>

	<h2>Request for discovering the neighborhood of a node</h2>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h3>Complete neighborhood</h3>

	<api get>/node/peer-list/all</api>


	<desc>
	<p class=NemNoSpacing>Gets an array of all known nodes in the
	neighborhood.</p>
	</desc>

	<h4>No parameter:</h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/node/peer-list/all">http://127.0.0.1:7890/node/peer-list/all</a></p>

	<h4>Example of returned JSON <a href="#nodeCollection">NodeCollection</a> object (&lt;Node&gt;
		denotes a <a href="#node">Node</a> object):</h4>

	<resp>
{
       "inactive": [
              &lt;Node&gt;,
              &lt;Node&gt;
       ],
       "active": [
              &lt;Node&gt;,
              &lt;Node&gt;
       ],
       "busy": [
              &lt;Node&gt;,
              &lt;Node&gt;
       ],
       "failure": [
              &lt;Node&gt;,
              &lt;Node&gt;
       ]
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>In case the node has not been booted
	yet, NIS will return a JSON error object. See <appa>Error object</appa><b> </b>for more information of the error
	object and <alnk>Appendix B: NIS Errors</alnk> for the error message.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h3>Reachable neighborhood</h3>

	<api get>/node/peer-list/reachable</api>


	<desc>
	<p>Gets an array of all nodes with status 'active' in the neighborhood.</p>
	</desc>

	<h4>No parameter:</h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/node/peer-list/reachable">http://127.0.0.1:7890/node/peer-list/reachable</a></p>

	<h4>Example of returned JSON <a href="#nodeCollection">NodeCollection</a> object (&lt;Node&gt;
		denotes a <a href="#node">Node</a> object):</h4>

	<resp>
{
       "data": [
              "metaData":
              {
                     "application": "NIS",
                     "version": "0.4.33-BETA",
                     "platform": "Oracle Corporation (1.8.0_25) on Windows 8"
              },
              "endpoint":
              {
                     "protocol": "http",
                     "port": 7890,
                     "host": "81.224.224.156"
              },
              "identity":
              {
                     "name": "Alice",
                     "public-key": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
              },
       ]
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>In case the node has not been booted
	yet, NIS will return a JSON error object. See <appa>Error object</appa><b> </b>for more information of the error
	object and <alnk>Appendix B: NIS Errors</alnk> for the error message.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h3>Active neighborhood</h3>

	<api get>/node/peer-list/active</api>


	<desc>
	<p class=NemNoSpacing>Gets an array of active nodes in the
	neighborhood that are selected for broadcasts.</p>
	</desc>

	<h4>No parameter:</h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/node/peer-list/active">http://127.0.0.1:7890/node/peer-list/active</a></p>

	<h4>Example of returned JSON <a href="#nodeCollection">NodeCollection</a> object (&lt;Node&gt;
		denotes a <a href="#node">Node</a> object):</h4>

	<resp>
{
       "data": [
              "metaData":
              {
                     "application": "NIS",
                     "version": "0.4.33-BETA",
                     "platform": "Oracle Corporation (1.8.0_25) on Windows 8"
              },
              "endpoint":
              {
                     "protocol": "http",
                     "port": 7890,
                     "host": "81.224.224.156"
              },
              "identity":
              {
                     "name": "Alice",
                     "public-key": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
              },
       ]
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>In case the node has not been booted
	yet, NIS will return a JSON error object. See <appa>Error object</appa><b> </b>for more information of the error
	object and <alnk>Appendix B: NIS Errors</alnk> for the error message.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h3>Maximum chain height in the active neighborhood</h3>

	<api get>/node/active-peers/max-chain-height</api>


	<desc>
	<p class=NemNoSpacing>Requests the chain height from every
	node in the active node list (described in <a href="#active-neighborhood">Active neighborhood</a>) and returns the maximum height seen.</p>
	</desc>

	<h4>No parameter:</h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/node/active-peers/max-chain-height">http://127.0.0.1:7890/node/active-peers/max-chain-height</a></p>

	<h4>Example of returned JSON <a href="#blockHeight">BlockHeight</a> object:</h4>

	<resp>
{
       "height": 43920
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>In case the node has not been booted
	yet, NIS will return a JSON error object. See <appa>Error object</appa><b> </b>for more information of the error
	object and <alnk>Appendix B: NIS Errors</alnk> for the error message.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h2>Requesting node experiences</h2>

	<api get>/node/experiences</api>


	<desc>
	<p class=NemNoSpacing>Gets an array of node experiences from
	another node. Each node saves its experiences with other nodes in an internal
	map. Sharing experiences helps nodes to select honest nodes for communication.</p>
	</desc>

	<h4>No parameter:</h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/node/experiences">http://127.0.0.1:7890/node/experiences</a></p>

	<h4>Example of returned array of JSON <a href="#extendedNodeExperiencePair">ExtendedNodeExperiencePair</a> objects:</h4>

	<resp>
{
       "data": [
       {
              "node":
              "metaData":
              {
                     "application": "NIS",
                     "version": "0.4.33-BETA",
                     "platform": "Oracle Corporation (1.8.0_25) on Windows 8"
              },
              "endpoint":
              {
                     "protocol": "http",
                     "port": 7890,
                     "host": "81.224.224.156"
              },
              "identity":
              {
                     "name": "Alice",
                     "public-key": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
              },
              "syncs": 3,
              "experience":
              {
                     "s": 1,
                     "f": 0
              }
       }]
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>In case the node has not been booted
	yet, NIS will return a JSON error object. See <appa>Error object</appa><b> </b>for more information of the error
	object and <alnk>Appendix B: NIS Errors</alnk> for the error message.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h2>Booting the local node</h2>

	<api post>/node/boot</api>

	<desc>
	<p class=NemNoSpacing>Boots the local node and thus assign an account (the identity) to the local node.</p>
	</desc>

	<h4>Parameter:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>bootNodeRequest </p>
			</td>
			<td>
				<p class=NemNoSpacing>A BootNodeRequest JSON object as
				described in <appa>BootNodeRequest</appa>.</p>
			</td>
		</tr>
	</table>

	<h4>Example:</h4>

	<p class=NemNoSpacing>Request cannot be performed in a
	browser.</p>

	<h4>No return value</h4>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>In case the node has already been booted, NIS will return a JSON error object. See <appa>Error object</appa> for more information of the error
	object and <alnk>Appendix B: NIS Errors</alnk> for the error message.</p>

	<h1>Initiating transactions</h1>

	<p>Transactions are the way of transferring NEM and/or messages from one
        account to another. Once a transaction is initiated, it is still unconfirmed and
        thus not yet accepted by the network. At this point it is not yet clear if it will
        get included in a block. Never rely on a transaction which has the state
        'unconfirmed'. Once it is included in a block, the transaction gets processed and,
        in case of a transfer transaction, the amount stated in the transaction gets
        transferred from the sender's account to the recipient's account. Additionally
        the transaction fee is deducted from the sender's account. The transaction is
        said to have 0 confirmations at this point. When another block is added to the
        block chain the transaction has 1 confirmation. The next block added to the
        chain will give it 2 confirmations and so on.</p>

    <p>Crypto currencies have the ability to roll back part the block chain. This is
        essential for being able to resolve forks of the block chain. There is however
        a maximum number of blocks that can be rolled back, this is called the rewrite
        limit. Hence forks can only be resolved up to a certain depth too. NEM has
        a rewrite limit of 360 blocks. Once a transaction has more than 360
        confirmations, it cannot be reversed. In real life, forks that are deeper than
        20 blocks do not happen, unless there was some severe problem with the
        block chain due to a bug in the code or an attack of some kind.</p>

	<p>A client can initiate a transaction in two ways:</p>
	<li>
        If the client is not able to sign the transaction data it can let the local NIS
        do the signing by sending a RequestPrepareAnnounce JSON object to NIS. See
        <appa>RequestPrepareAnnounce</appa> for more details.

        <div class="warning">
            The <span class="JSON">/transaction/prepare-announce</span> API
            should be <br> used only on <strong>TRUSTED</strong> and <strong>LOCAL</strong> nodes!
        </div>

        <p>Note: keep in mind, that NCC does <strong>NOT</strong>
            use this API. It does all the transaction signing on it's own.
        </p>

    </li>
    <li>
        If the client has an ed25519 implementation and can thus sign the transaction it
        can send a RequestAnnounce JSON object to NIS. Doing so has the advantage that you
        can use an untrusted remote NIS for sending a transaction.
        See <appa>RequestAnnounce</appa> for more details on this object.
    </li>

    <p>Since most client with depend on a local NIS to create the transaction signature
        Chapters 6.1 through 6.6 will explain transaction related actions using the first way.
        Chapter 6.7 explains the steps you have to take to gather the data that needs to be signed
        and how to initiate a transaction the second way.
        Note however that we will not explain how to create the signature itself since this involves
        some cryptographical concepts which are out of the scope of this document.
    </p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h2>Initiating a transaction</h2>

	<api post>/transaction/prepare-announce</api>

	<desc>
	<p class=NemNoSpacing>Creates and broadcasts a transaction.
	Since this request involves the private key of an account, it should only be
	sent to a <b>local</b> NIS.</p>
	</desc>

	<h4>Parameter:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>requestPrepareAnnounce</p>
			</td>
			<td>
				<p class=NemNoSpacing>A RequestPrepareAnnounce JSON object as described in <appa>RequestPrepareAnnounce</appa>.</p>
			</td>
		</tr>
	</table>

	<h4>Example:</h4>

	<p class=NemNoSpacing>Request cannot be performed in a
	browser.</p>

	<h4>Example of returned JSON <a href="#nemAnnounceResult">NemAnnounceResult</a> object:</h4>

	<resp>
{
   "type":1,
   "code":1,
   "message":"SUCCESS",
   "transactionHash": {
      "data":"c1786437336da077cd572a27710c40c378610e8d33880bcb7bdb0a42e3d35586"
   },
   "innerTransactionHash": {
      "data":"cc317a7674d56352b4c711096a7594bd11908bf518293a191fc2faa12eac0fbb"
   }
}
    </resp>

	<h4>Possible Errors:</h4>

	<p>There are various errors that can occur due
	to failure of transaction validation See <appa>Error object</appa><b> </b>for more information of the error
	object and <alnk>Appendix B: NIS Errors</alnk> for the error message.</p>

	<p>The most common errors are:</p>

	<ul>
		<li>The sender account has not enough funds.</li>
		<li>The timestamp is invalid because it lies too far in the future.</li>
		<li>The deadline is invalid because it has already been passed.</li>
		<li>The attached message is too large.</li>
		<li>The transaction is already known.</li>
		<li>There is another transaction conflicting with this transaction. This can happen when trying to transfer the importance to another account.</li>
	</ul>

    <h2>Initiating a transfer transaction</h2>

    <p>Suppose you want to send 1000 NEM from sender account (referred hereafter as <em><b>'Alice'</b></em>):</p>
    <p class="JSON">TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS</p>
    <p>to recipient account: </p>
    <p class="JSON">TBOBBSXX7BESJXDWGLP5Z7FM5HSTKUH5WIMPW562</p>

    <p>The RequestPrepareAnnounce JSON object you have to send to NIS via a POST request would look similar to this (test network):</p>

    <pre><code class="JSON">    {
        "transaction":
        {
            "timeStamp": 9111526,
            "amount": 1000000000,
            "fee": 3000000,
            "recipient": "TBOBBSXX7BESJXDWGLP5Z7FM5HSTKUH5WIMPW562",
            "type": 257,
            "deadline": 9154726,
            "message":
            {
                "payload": "",
                "type": 1
            },
            "version": -1744830463,
            "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
        },
        "privateKey": "00983bb01d05edecfaef55df9486c111abb6299c754a002069b1d0ef4537441bda"
    }</code></pre>

    <p>Note that there is no signature in the transaction part of the object since NIS
        will create the signature for you. If the sender account has enough funds for
        the transaction NIS would respond with the JSON object</p>

	<resp>
{
        "type": 1,
        "code": 1,
        "message": "SUCCESS",
        "transactionHash": {
            "data":"c1786437336da077cd572a27710c40c378610e8d33880bcb7bdb0a42e3d35586"
        },
        "innerTransactionHash": {}
}
	</resp>

    <h2>Converting an account to a multisig account</h2>

    <p>NIS natively supports m of n multisig accounts. This means an account can be converted into a multisig account
        having n cosignatories and m of those cosignatories need to sign a transaction from the multisig account in order
        to complete the transaction.
		To convert a normal account to a multisig account an aggregate modification transaction
        (see <appa>MultisigAggregateModificationTransaction</appa>) must be sent to the network.
        Assuming you want to convert <em>Alice</em> with public key:</p>
		<ul> Account <b>'Alice'</b>:
			<ul>
				<li>public key: <span class="JSON">a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a</span></li>
			</ul>
		</ul>

    <p>into a 2 of 3 multisig account meaning the account has 3 cosignatories and at least 2 cosignatories have to sign
		to complete a multisig transaction:</p>

    <ol>
        <li> Cosignatory <b>'Bob'</b>:
            <ul>
                <li>address: <span class="JSON">TBOBBSXX7BESJXDWGLP5Z7FM5HSTKUH5WIMPW562</span></li>
                <li>public key: <span class="JSON">6083df7119d43e815ed2967c795f806f6b73f8f92a56a7611e3848816ec50958</span></li>
            </ul>
        </li>
        <li>Cosignatory <b>'jusan'</b>:
            <ul>
                <li>address: <span class="JSON">TBJUSANZ63AKNJ57XMK6Y2IBH55UNNRXJFZRDTRW</span></li>
                <li>public key: <span class="JSON">0662ed29cbfa7038530fb7f52df865eed6708d51bc7a24bcd05db35185b53c70</span></li>
            </ul>
        </li>
        <li>Cosignatory <b>'go'</b>:
            <ul>
                <li>address: <span class="JSON">TDGOGOGOWZJ3HU4F6CUM5IKE7GHG4FFTF5BZ7JPW</span></li>
                <li>public key: <span class="JSON">cc61676a4275abcffd10a9ea1081091ff054a1a8a720429256aebf8034aab099</span></li>
            </ul>
        </li>
    </ol>

    <p>you would have to create a JSON object that looks similar to this (test network):</p>

    <pre><code class="JSON">    {
        "transaction":
        {
            "timeStamp": 9111526,
            "fee": 28000000,
            "type": 4097,
            "deadline": 9154726,
            "version": -1744830462,
            "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a",
            "modifications": [
                {
                    "modificationType": 1,
                    "cosignatoryAccount": "6083df7119d43e815ed2967c795f806f6b73f8f92a56a7611e3848816ec50958"
                },{
                    "modificationType": 1,
                    "cosignatoryAccount": "0662ed29cbfa7038530fb7f52df865eed6708d51bc7a24bcd05db35185b53c70"
                },{
                    "modificationType": 1,
                    "cosignatoryAccount": "cc61676a4275abcffd10a9ea1081091ff054a1a8a720429256aebf8034aab099"
                }
            ],
            "minCosignatories" : {
                "relativeChange": 2
            }
        },
        "privateKey": "00983bb01d05edecfaef55df9486c111abb6299c754a002069b1d0ef4537441bda"
    }</code></pre>

    <p>Note again that there is no signature since the transaction will be signed by NIS.</p>

    <p>After the transaction is signed by NIS and is accepted by the network by
        including it into a block, the account Alice is now a 2 of 3 multisig account.
        From this point on, only the cosignatories can initiate a transaction for the
        account <em>Alice</em>. Also, any transaction from account <em>Alice</em>
        must be a multisig transaction.</p>

    <h2>Initiating a multisig transaction</h2>

    <p>As stated above, only one of the cosignatories (<em>Bob, Jusan and Go</em>)
        can create a transaction for the account <em>Alice</em>.</p>

    <p>Lets assume <em>Bob</em> wants to start a transfer transaction which transfers
        1000 NEM from account <em>Alice</em> to account <em>Jusan</em>.<br>
        Since the account <em>Alice</em> is a multisig account the transfer transaction
        (in the JSON object the "otherTrans" structure) must be wrapped in
        a multisig transaction (see <appa>MultisigTransaction</appa>).
        The corresponding RequestPrepareAnnounce object would look similar to this (test network):</p>

    <pre><code class="JSON">    {
        "transaction":
        {
            "timeStamp": 9111526,
            "fee": 3000000,
            "type": 4100,
            "deadline": 9154726,
            "version": -1744830463,
            "signer": "6083df7119d43e815ed2967c795f806f6b73f8f92a56a7611e3848816ec50958",
            "otherTrans": {
                "timeStamp": 9111526,
                "amount": 1000000000,
                "fee": 4000000,
                "recipient": "TBJUSANZ63AKNJ57XMK6Y2IBH55UNNRXJFZRDTRW",
                "type": 257,
                "deadline": 9154726,
                "message":
                {
                    "payload": "",
                    "type": 1
                },
                "version": -1744830463,
                "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
            },
            "signatures":[
            ]
        },
        "privateKey": "00a6e2526b5cc84f9174c4ff050ca352623061115951c649b36b08409c4ccb7b2e"
    }</code></pre>

    <p>NIS will sign the transaction and publish it. The returned
        <a href="#NemAnnounceResult">NemAnnounceResult</a> object this time
        contains the hash of the inner transaction (<i>otherTrans</i> in the above structure):</p>

    <pre><span class="JSON">    {
        "type": 1,
        "code": 1,
        "message": "SUCCESS"
    	"transactionHash": {
            "data":"c1786437336da077cd572a27710c40c378610e8d33880bcb7bdb0a42e3d35586"
        },
        "innerTransactionHash": {
            <b>"data": "44e4968e5aa35fe182d4def5958e23cf941c4bf809364afb4431ebbf6a18c039"</b>
        }
    }</span></pre>

    <p>The hash is needed by the nodes that will create multisig signature transactions
        for the above transaction.</p>

    <p>At this point the transaction cannot (and will not) be included in a block
        because none of the other cosignatories - <em>Jusan</em> and <em>Go</em> - has
        signed the transaction yet &hellip;</p>

    <h3>Cosigning multisig transaction</h3>

    <p>&hellip; to do so, <em>Jusan</em> or <em>Go</em> must initiate a multisig signature transaction
        (see <appa>MultisigSignatureTransaction</appa>).
        <em>Jusan</em> has to create a RequestPrepareAnnounce JSON object that looks similar to this (test network):</p>

    <pre><code class="JSON">    {
        "transaction":
        {
            "timeStamp": 9111526,
            "fee": 6000000,
            "type": 4098,
            "deadline": 9157365,
            "version": -1744830463,
            "signer": "0662ed29cbfa7038530fb7f52df865eed6708d51bc7a24bcd05db35185b53c70",
            "otherHash": {
                <b>"data": "44e4968e5aa35fe182d4def5958e23cf941c4bf809364afb4431ebbf6a18c039"</b>
            },
            <b>"otherAccount": "TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS"</b>
        },
        "privateKey": "00be34fdb20a9f6fed51376f0bab9f25ea7a48d610324588a6b203d0a1a6db4bc1"
    }</code></pre>

    <p>Note that <em>Jusan</em> used the hash ('otherHash') returned by NIS
        from <em>Bob's</em> request.</p>

    <p>After NIS has signed the transaction and sent it to the network,
        the signature transaction will be attached to the multisig transaction.<br>
        With <em>Jusan</em> having signed the multisig transaction that <em>Bob</em> initiated,
        two of the three cosignatories have signed the inner transfer transaction (<em>Bob</em>
		indirectly signed by initiating the multisig transaction) and thus the
        multisig transaction can be included in a block.
    </p>

    <h2>Adding and removing cosignatories</h2>

    <p>It is possible to modify the list of cosignatories for a multisig account. This is
        done via a aggregate modification transaction wrapped in a multisig transaction.</p>

    <p>Suppose you want to add the cosignatory <em>Hachi</em> to the multisig
        account <em>Alice</em> and increase the minimum of cosignatories required to complete
	a transaction from 2 to 3.</p>

    <ol start="4">
        <li> Cosignatory <b>'hachi'</b>:
            <ul>
                <li>address: <span class="JSON">TDHACHIMHRBBRHR57SR3BDBFFWDTYVSLGMFKIDOR</span></li>
                <li>public key: <span class="JSON">6c66ea288522990db7a0a63c9c20f532cdcb68dc3c9544fb20f7322c92ceadbb</span></li>
            </ul>
        </li>
    </ol>

    <p>To do that, one of the existing cosignatories (assuming here it is <em>Jusan</em>)
        must initiate the corresponding multisig transaction (test network):</p>
    
    <pre><code class="JSON">{
        "transaction":
        {
            "timeStamp": 9111526,
            "fee": 6000000,
            "type": 4100,
            "deadline": 9154726,
            "version": -1744830462,
            "signer": "6083df7119d43e815ed2967c795f806f6b73f8f92a56a7611e3848816ec50958",
            "otherTrans": {
                "timeStamp": 9111526,
                "fee": 16000000,
                "type": 4097,
                "deadline": 9154726,
                "version": -1744830462,
                "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a",
                "modifications": [
                    {
                    "modificationType": 1,
                    <b>"cosignatoryAccount": "6c66ea288522990db7a0a63c9c20f532cdcb68dc3c9544fb20f7322c92ceadbb"</b>
                    }
                ],
                "minCosignatories" : {
                    "relativeChange": 1
                }
            },
            "signatures":[
            ]
        },
        "privateKey": "00be34fdb20a9f6fed51376f0bab9f25ea7a48d610324588a6b203d0a1a6db4bc1"
    }</code> </pre>

    <p>After NIS has signed and broadcasted the transaction to the network, one of the other
        two cosignatories needs to sign the transaction as well as explained in
        <a href="#initiating-a-multisig-transaction">Initiating a multisig transaction</a>.
        After the transaction was successfully included in a block, the account <em>Alice</em>
        is a 3 of 4 multisig account.</p>

    <p>If at some later time <em>Bob, Jusan and Go</em> want to remove the
        cosignatory <em>Hachi</em> to make it a 2 of 3 multisig account again one of cosignatories could initiate a similar
        transaction as above but this time with <span class="JSON">"modificationType"</span>
        set to <b>2</b> (which means remove) and using a minimum cosignatories relative change value of <b>-1</b>.<br>
        For removing a cosignatory <em>all</em> cosignatories except the one being removed need to sign the transaction.
        Once approved by the network <em>Hachi</em> is no longer cosignatory of the multisig account <em>Alice.</em></p>

    <div class="warning">
        Removal of accounts is <strong>NOT</strong> final and might be subject of change
    </div>

    <h2>How to use a multisig account</h2>

    <p>The purpose of multisig accounts is to make accounts safer. But this relies
        on the user not making mistakes when using multisig accounts.<br>
        If for instance all private keys of the cosignatories of a multisig account
        reside on a single computer then the multisig account is essentially as good
        as a normal account because if that computer gets compromised all private
        keys are disclosed to the attacks at once.</p>

    <p>It is therefore essential to have the private key of the cosignatories on
        different computer preferably in different locations.</p>

    <p>If you have read
        "<a href="#initiating-a-multisig-transaction">Initiating a multisig transaction</a>"
        you know that the cosignatories of a multisig transaction must know the hash
        of the inner transaction in order to be able to sign the multisig transaction.
        There are two ways of gaining knowledge of that hash:</p>

    <ol>
        <li>The initiator of the multisig transaction writes down the hash (which is
            included in the returned JSON object by NIS) and sends the hash to the cosignatories.</li>
        <li>The cosignatories poll the unconfirmed transactions using their local NIS.
            As described in chapter
            <a href="#unconfirmed-transactions">Unconfirmed transactions</a>,
            the meta data part of an unconfirmed transaction JSON object contains
            the hash of the inner transaction in case of a multisig transaction.</li>
    </ol>

    <p>In first case the implementer of the client side software is responsible for
        transferring the hash to the cosignatories while in second case the NEM network
        will do it for you.</p>

    <p>The standard client NCC uses the second method. It lets you handle multisig accounts in a convenient way.</p>

    <p>
        Currently, we recommend to use at least three cosignatories in different locations when
        using the multisig account feature. If one of the cosignatory's private key gets
        compromised you should immediately remove that account from the list of
        cosignatories and afterwards add a new cosignatory
        (see chapter <a href="#adding-and-removing-cosignatories">Adding and removing cosignatories</a>
        on how to do this).</p>

    <p><b>If a private key is stored on a computer that computer should not be used
        for surfing the internet or doing other unsafe things.</b></p>

    <h2>Creating a signed transaction</h2>
    <p>This chapter explains which data from the transactions you need to sign and what JSON object
        you to send to NIS.</p>

    <h3>Gathering data for the signature</h3>
    <p>To create a transaction signature you need to sign an array of bytes extracted from the transaction.
       Since there is more than one type of transaction the byte array will have a different structure for
       different types of transactions. Nevertheless the first part of the byte array has the same structure
       for every transaction.
       Note that:</p>

    <li>
        when the field denotes a number the endianess matters.
    </li>
    <li>
        the order in which the fields are concatenated matters.
    </li>

    <h4colored>Common transaction part of the byte array</h4colored>
    <li>
        <b>Transaction type:</b> 4 bytes (integer). The following types are supported:
        <ul>
            <li>0x0101 (transfer transaction)</li>
            <li>0x0801 (importance transfer transaction)</li>
            <li>0x1001 (multisig aggregate modification transfer transaction)</li>
            <li>0x1002 (multisig signature transaction)</li>
            <li>0x1004 (multisig transaction)</li>
            <b>example (importance transfer transaction): </b> 0x01, 0x08, 0x00, 0x00
        </ul>
    </li>
    <li>
    <b>Version:</b> 4 bytes (integer). The following versions are supported:
        <ul>
			<p>
				For transfer transaction, importance transfer transaction, multisig transactions and
				multisig signature transactions the version must be
			</p>
            <li>0x68 << 24 + 1 (main network)</li>
            <li>0x98 << 24 + 1 (test network)</li>
            <b>Example (main network):</b> 0x01, 0x00, 0x00, 0x68
			<p></p><p>
				For multisig aggregate modification transactions the version must be
			</p>
			<li>0x68 << 24 + 2 (main network)</li>
			<li>0x98 << 24 + 2 (test network)</li>
			<b>Example (main network):</b> 0x02, 0x00, 0x00, 0x68
        </ul>
    </li>
    <li>
        <b>Timestamp:</b> 4 bytes (integer).
        <ul>
            <b>Example (timestamp = 0x129623):</b> 0x23, 0x96, 0x12, 0x00
        </ul>
    </li>
    <li>
        <b>Length of public key byte array (always 32):</b> 4 bytes (integer).
        <ul>
            <b>Always:</b> 0x20, 0x00, 0x00, 0x00
        </ul>
    </li>
    <li>
        <b>Public key bytes of signer:</b> 32 bytes.
        <ul>
            <b>Example:</b> 0x6d, 0xa3, 0x76, 0x07, 0x13, 0x01, 0x9e, 0x26, 0xb1, 0x86, 0x24, 0x3a,
                            0xb6, 0xec, 0xba, 0x9f, 0x70, 0x78, 0x4c, 0x59, 0x92, 0x3d, 0x68, 0x9a,
                            0xb5, 0x4d, 0x4b, 0x2b, 0xf0, 0xe2, 0x0f, 0x5d
        </ul>
    </li>
    <li>
        <b>Fee (micro nem):</b> 8 bytes (long).
        <ul>
            <b>Example (12 nem):</b> 0x00, 0x1b, 0xb7, 0x00, 0x00, 0x00, 0x00, 0x00
        </ul>
    </li>
    <li>
        <b>Deadline:</b> 4 bytes (integer).
        <ul>
            <b>Example (deadline = 0x147824):</b> 0x24, 0x78, 0x14, 0x00
        </ul>
    </li>

    <h4colored>Transfer transaction part</h4colored>
    <li>
        <b>Length of recipient address (always 40):</b> 4 bytes (integer).
        <ul>
            <b>Always:</b> 0x28, 0x00, 0x00, 0x00
        </ul>
    </li>
    <li>
        <b>Recipient address:</b> 40 bytes (using UTF8 encoding).
        <ul>
            <b>Example ("NACCH2WPJYVQ3PLGMVZVRK5JI6POTJXXHLUG3P4J"):</b> 0x4e, 0x41, 0x43, 0x43, 0x48, 0x32, 0x57, 0x50,
            0x4a, 0x59, 0x56, 0x51, 0x33, 0x50, 0x4c, 0x47, 0x4d, 0x56, 0x5a, 0x56, 0x52, 0x4b, 0x35, 0x4a, 0x49, 0x36,
            0x50, 0x4f, 0x54, 0x4a, 0x58, 0x58, 0x48, 0x4c, 0x55, 0x47, 0x33, 0x50, 0x34, 0x4a
        </ul>
    </li>
    <li>
        <b>Amount (micro nem):</b> 8 bytes (long).
        <ul>
            <b>Example (1234 NEM):</b> 0x80, 0x58, 0x8d, 0x49, 0x00, 0x00, 0x00, 0x00
        </ul>
    </li>
    <li>
        <b>Length of message field:</b> 4 bytes (integer). Note: if the length is 0 then the following fields do not apply.
        <ul>
            <b>Example:</b> 0x24, 0x00, 0x00, 0x00
        </ul>
    </li>
    <li>
        <b>Message type:</b> 4 bytes (integer). The following message types are supported.
        <ul>
            <li>0x01 (plain message)</li>
            <li>0x02 (secure, i.e. encrypted, message)</li>
            <b>Example:</b> 0x01, 0x00, 0x00, 0x00
        </ul>
    </li>
    <li>
        <b>Length of payload:</b> 4 bytes (integer).
        <ul>
            <b>Example:</b> 0x05, 0x00, 0x00, 0x00
        </ul>
    </li>
    <li>
        <b>Payload:</b> UTF8 encoded string.
        <ul>
            <b>Example ("Hello"):</b> 0x48, 0x65, 0x6c, 0x6c, 0x6f
        </ul>
    </li>

    <h4colored>Importance transfer transaction part</h4colored>
    <li>
        <b>Importance transfer mode:</b> 4 bytes (integer). The following modes are supported:
        <ul>
            <li>0x01 (Activate)</li>
            <li>0x02 (Deactivate)</li>
            <b>Example (mode Activate):</b> 0x01, 0x00, 0x00, 0x00
        </ul>
    </li>
    <li>
        <b>Length of remote account public key byte array (always 32):</b> 4 bytes (integer).
        <ul>
            <b>Always:</b> 0x20, 0x00, 0x00, 0x00
        </ul>
    </li>
    <li>
        <b>Public key bytes of remote account:</b> 32 bytes.
        <ul>
            <b>Example:</b> 0x6d, 0xa3, 0x76, 0x07, 0x13, 0x01, 0x9e, 0x26, 0xb1, 0x86, 0x24, 0x3a,
            0xb6, 0xec, 0xba, 0x9f, 0x70, 0x78, 0x4c, 0x59, 0x92, 0x3d, 0x68, 0x9a,
            0xb5, 0x4d, 0x4b, 0x2b, 0xf0, 0xe2, 0x0f, 0x5d
        </ul>
    </li>

    <h4colored>Aggregate modification transaction part</h4colored>
    <li>
        <b>Number of cosignatory modifications:</b> 4 bytes (integer).
        <ul>
            <b>Example:</b> 0x03, 0x00, 0x00, 0x00
        </ul>
    </li>
    <p>The following part is repeated for every cosignatory modification</p>
    <li>
        <b>Length of cosignatory modification structure:</b> 4 bytes (integer).
        <ul>
            <b>Always:</b> 0x28, 0x00, 0x00, 0x00
        </ul>
    </li>
    <li>
        <b>Modification type:</b> 4 bytes (integer). The following modification types are supported:
        <ul>
            <li>0x01 (Add cosignatory)</li>
            <li>0x02 (Delete cosignatory)</li>
            <b>Example (Delete):</b> 0x02, 0x00, 0x00, 0x00
        </ul>
    </li>
    <li>
        <b>Length of cosignatory's public key byte array (always 32):</b> 4 bytes (integer).
        <ul>
            <b>Always:</b> 0x20, 0x00, 0x00, 0x00
        </ul>
    </li>
    <li>
        <b>Public key bytes of cosignatory:</b> 32 bytes.
        <ul>
            <b>Example:</b> 0x6d, 0xa3, 0x76, 0x07, 0x13, 0x01, 0x9e, 0x26, 0xb1, 0x86, 0x24, 0x3a,
            0xb6, 0xec, 0xba, 0x9f, 0x70, 0x78, 0x4c, 0x59, 0x92, 0x3d, 0x68, 0x9a,
            0xb5, 0x4d, 0x4b, 0x2b, 0xf0, 0xe2, 0x0f, 0x5d
        </ul>
    </li>
	<p>The following part describes the minimum cosignatories modification</p>
	<li>
		<b>Length of minimum cosignatories modification structure:</b> 4 bytes (integer).
		<ul>
			<b>Always:</b> 0x04, 0x00, 0x00, 0x00
		</ul>
	</li>
	<li>
		<b>Relative change:</b> 4 bytes (integer).
		<ul>
			<b>Example (relative change of 2):</b> 0x02, 0x00, 0x00, 0x00
		</ul>
	</li>

    <h4colored>Multisig signature transaction part</h4colored>
    <li>
        <b>Length of hash object (hash of the corresponding multisig transaction):</b> 4 bytes (integer).
        <ul>
            <b>Always:</b> 0x24, 0x00, 0x00, 0x00
        </ul>
    </li>
    <li>
        <b>Length of hash:</b> 4 bytes (integer).
        <ul>
            <b>Always:</b> 0x20, 0x00, 0x00, 0x00
        </ul>
    </li>
    <li>
        <b>SHA3 hash bytes:</b> 32 bytes.
        <ul>
            <b>Example:</b> 0x7d, 0x76, 0xfe, 0x26, 0xc4, 0x54, 0x61, 0xf7, 0x4b, 0xcb, 0x76, 0xac,
            0xae, 0xb0, 0x17, 0x39, 0x9e, 0xbe, 0x50, 0xaa, 0x71, 0x46, 0xe2, 0x62, 0x57, 0x39,
            0x5f,0xbb,0xc0,0x25,0xac,0xb7
        </ul>
    </li>
    <li>
        <b>Length of address of the corresponding multisig account (always 40):</b> 4 bytes (integer).
        <ul>
            <b>Always:</b> 0x28, 0x00, 0x00, 0x00
        </ul>
    </li>
    <li>
        <b>Multisig account address:</b> 40 bytes (using UTF8 encoding).
        <ul>
            <b>Example ("NACCH2WPJYVQ3PLGMVZVRK5JI6POTJXXHLUG3P4J"):</b> 0x4e, 0x41, 0x43, 0x43, 0x48, 0x32, 0x57, 0x50,
            0x4a, 0x59, 0x56, 0x51, 0x33, 0x50, 0x4c, 0x47, 0x4d, 0x56, 0x5a, 0x56, 0x52, 0x4b, 0x35, 0x4a, 0x49, 0x36,
            0x50, 0x4f, 0x54, 0x4a, 0x58, 0x58, 0x48, 0x4c, 0x55, 0x47, 0x33, 0x50, 0x34, 0x4a
        </ul>
    </li>

    <h4>Multisig transaction part</h4>
    <li>
        <b>Length of inner transaction object. This can be a transfer, an importance transfer or an aggregate modification transaction.</b>
        <ul>
            <b>Example:</b> 0x74, 0x00, 0x00, 0x00
        </ul>
    </li>
    <p>What follows here is the inner transaction object. The structure is one of the structures
        described above transactions (excluding signature transactions).</p>

    <h4colored>Building the byte array</h4colored>
    <p>To build the final byte array that needs to be signed, simply concatenate the common part for a transaction and the type specific part.
    For example if you want to build the byte array for a transfer transaction you have as common something that looks like</p>

    <p>0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6f, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x68, 0x32, 0x03, 0xb4,
        0x55, 0x09, 0x0e, 0x2f, 0xfe, 0xd6, 0x48, 0x53, 0x6c, 0x99, 0x01, 0x4d, 0x1c, 0xa9, 0x2c, 0x10, 0x47, 0xaf, 0xbc, 0xae,
        0x58, 0x05, 0x7b, 0xb6, 0xa6, 0x98, 0xc8, 0x0b, 0x80, 0x84, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00</p>

    <p>and a transfer transaction specific part</p>

    <p>0x28, 0x00, 0x00, 0x00, 0x54, 0x41, 0x49, 0x34, 0x35, 0x32, 0x53, 0x37, 0x44, 0x4c, 0x36, 0x57, 0x48, 0x57, 0x54, 0x5a,
        0x5a, 0x32, 0x57, 0x33, 0x44, 0x49, 0x4d, 0x34, 0x32, 0x36, 0x58, 0x57, 0x49, 0x4a, 0x4b, 0x4c, 0x55, 0x4e, 0x58, 0x4e,
        0x4b, 0x54, 0x37, 0x4c, 0x40, 0x2f, 0x07, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00</p>

    <p>which gives you the final array</p>

    <p>0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6f, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x68, 0x32, 0x03, 0xb4,
        0x55, 0x09, 0x0e, 0x2f, 0xfe, 0xd6, 0x48, 0x53, 0x6c, 0x99, 0x01, 0x4d, 0x1c, 0xa9, 0x2c, 0x10, 0x47, 0xaf, 0xbc, 0xae,
        0x58, 0x05, 0x7b, 0xb6, 0xa6, 0x98, 0xc8, 0x0b, 0x80, 0x84, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        0x28, 0x00, 0x00, 0x00, 0x54, 0x41, 0x49, 0x34, 0x35, 0x32, 0x53, 0x37, 0x44, 0x4c, 0x36, 0x57, 0x48, 0x57, 0x54, 0x5a,
        0x5a, 0x32, 0x57, 0x33, 0x44, 0x49, 0x4d, 0x34, 0x32, 0x36, 0x58, 0x57, 0x49, 0x4a, 0x4b, 0x4c, 0x55, 0x4e, 0x58, 0x4e,
        0x4b, 0x54, 0x37, 0x4c, 0x40, 0x2f, 0x07, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00</p>

    <p>Signing this array will give you the 64 byte long signature.</p>

    <h4colored>Calculating the hash of a transaction</h4colored>
    <p>NIS uses the SHA3-256 hash function. To create a hash of a transaction you need to hash the byte array of the transaction.
       See the section above to learn how to build the byte array from a transaction.</p>

    <h3>Sending the data to NIS</h3>

    <p>After preparing the data as described in the last section you can send the array and the corresponding signature via a
        RequestAnnounce request</p>

    <api post>/transaction/announce</api>
    <desc>
        <p class=NemNoSpacing>Creates and broadcasts a transaction. The private key is not involved.</p>
    </desc>

    <h4>Parameter:</h4>

    <table class=NemTableGrid>
        <tr>
            <td>
                <p class=JSON>requestAnnounce</p>
            </td>
            <td>
                <p class=NemNoSpacing>A RequestAnnounce JSON object as described in <appa>RequestAnnounce</appa>.</p>
            </td>
        </tr>
    </table>

    <h4>Example:</h4>

    <p class=NemNoSpacing>Request cannot be performed in a browser.</p>

    <h4>Example of returned JSON <a href="#nemAnnounceResult">NemAnnounceResult</a> object:</h4>

    <resp>
{
        "type":1,
        "code":1,
        "message":"SUCCESS",
        "transactionHash": {
        "data":"c1786437336da077cd572a27710c40c378610e8d33880bcb7bdb0a42e3d35586"
        },
        "innerTransactionHash": {
        "data":"cc317a7674d56352b4c711096a7594bd11908bf518293a191fc2faa12eac0fbb"
        }
}
    </resp>

    <h4>Possible Errors:</h4>

    <p>The possible erros are described in chapter 6.1.</p>

    <h2>Transaction fees</h2>

    <p>In order for the harvesters to have an incentive to run a node that is harvesting blocks,
        users have to pay a fee for every transaction that is going to be included in a block chain.</p>

    <p>Different transaction types have different fees. In order to get a transaction
        validated by a NIS, the fee provided must be at least the minimum fee.</p>

    <p>The following chart summarizes the minimum fees for each transaction type.
        All calculation are done with rounded amounts of XEM (i.e. micro XEM are ignored):</p>

    <table class=NemTableGrid>
        <tr>
            <td>
                <p class=JSON>Transfer transaction</p>
            </td>
            <td>
                <p>The fee is the sum of the fee for transferring an amount of
					XEM and the fee for appending a message to the transaction.</p>
                <p>1) Fees for transferring XEM to another account:<br />
                    a) If the amount transferred is less than 8 XEM then the
                    fee is 10 – amount XEM.<br />
                    Example:<br />
                    Transferring 6 XEM costs 4 XEM fee.<br />
                    b) If the amount transferred is greater or equal 8 XEM
                    then the fee is<br />
                    max(2, 99 * arctan(amount / 150000)) XEM.<br />
                    Example:<br />
                    Transferring 100000 XEM costs 58 XEM.</p>
                <p>2) Fees for appending a message to a transaction:<br />
                    If no message or an empty message is append it costs
                    0 XEM. Else the fee is calculated as<br />
                    2 * max(1, message length / 16)<br />
                    Example:<br />
                    The unencrypted message „The New Economy
                    Movement will change the world!!!” has a length 49
                    characters and thus will cost 2 * 49/16 = 6 XEM.</p>
            </td>
        </tr>
        <tr>
            <td>
                <p class=JSON>Importance transfer transaction</p>
            </td>
            <td>
                <p>6 XEM</p>
            </td>
        </tr>
        <tr>
            <td>
                <p class=JSON>Aggregate modification transaction</p>
            </td>
            <td>
                <p>10 + 6 * number of modifications + 6 (if a min cosignatory change is involved)<br />
                    Example:<br />
                    Adding 3 cosignatories to an account without changing the min cosignatories will cost<br />
                    10 + 6 * 3 = 28 XEM.<br />
					Adding 3 cosignatories to an account and changing the min cosignatories will cost<br />
					10 + 6 * 3 + 6 = 34 XEM.<br />
				</p>
            </td>
        </tr>
        <tr>
            <td>
                <p class=JSON>Multisig transaction</p>
            </td>
            <td>
                <p>6 XEM</p>
            </td>
        </tr>
        <tr>
            <td>
                <p class=JSON>Multisig signature transaction</p>
            </td>
            <td>
                <p>6 XEM</p>
            </td>
        </tr>
    </table>

    <h1>Requests for additional information from NIS</h1>

    <p>Several requests supply additional information about the internal status of NIS.</p>

    <div class="warning">Those requests may get dropped in future versions of NIS
        without further notice, you should not rely on their existence.</div>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h2>Monitoring the network time</h2>

	<api get>/debug/time-synchronization</api>


	<desc>
	<p class=NemNoSpacing>Gets an array of time synchronization
	results as described in <appa>TimeSynchronizationResult</appa>. You can monitor the change in network time with this information.</p>
	</desc>

	<h4>No parameter:</h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/debug/time-synchronization">http://127.0.0.1:7890/debug/time-synchronization</a></p>

	<h4>Example of returned array of JSON <a href="#timeSynchronizationResult">TimeSynchronizationResult</a> objects:</h4>

	<resp>
{
       "data": [
       {
              "dateTime": "2014-11-19 19:23:04",
              "currentTimeOffset": 1747,
              "change": 57
       },
       {
              "dateTime": "2014-11-19 19:24:17",
              "currentTimeOffset": 1776,
              "change": 29
       },
       {
              "dateTime": "2014-11-19 19:25:18",
              "currentTimeOffset": 1729,
              "change": -47
       }]
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>None.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h2>Monitoring incoming and outgoing calls</h2>

	<!-- ---- ---- ---- ---- ---- ---- -->
	<api get>/debug/connections/incoming</api>


	<desc>
	<p class=NemNoSpacing>Gets an audit collection of incoming
	calls as described in <appa>AuditCollection</appa>. You can monitor the
	outstanding and recent incoming requests with this information.</p>
	</desc>

	<h4>No parameter:</h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/debug/connections/incoming">http://127.0.0.1:7890/debug/connections/incoming</a></p>

	<h4>Example of returned JSON <a href="#auditCollection">AuditCollection</a> object:</h4>

	<resp>
{
       "outstanding": [
       {
              "path": "/debug/connections/incoming",
              "start-time": 9317306,
              "host": "127.0.0.1",
              "elapsed-time": 0,
              "id": 4070
       }],
       "most-recent": [
       {
              "path": "/debug/connections/incoming",
              "start-time": 9317306,
              "host": "127.0.0.1",
              "elapsed-time": 0,
              "id": 4070
       },
       {
              "path": "/chain/score",
              "start-time": 9317303,
              "host": "95.16.203.168",
              "elapsed-time": 3,
              "id": 4069
       }]
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>None.</p>

	<!-- ---- ---- ---- ---- ---- ---- -->
	<api get>/debug/connections/outgoing</api>


	<desc>
	<p class=NemNoSpacing>Gets an audit collection of outgoing
	calls as described in <appa>AuditCollection</appa>. You can monitor the
	outstanding and recent outgoing requests with this information.</p>
	</desc>

	<h4>No parameter:</h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/debug/connections/outgoing">http://127.0.0.1:7890/debug/connections/outgoing</a></p>

	<h4>Example of returned JSON <a href="#auditCollection">AuditCollection</a> object:</h4>

	<resp>
{
       "outstanding": [
       {
              "path": "/chain/blocks-after",
              "start-time": 9317511,
              "host": "88.12.55.125",
              "elapsed-time": 6,
              "id": 6452
       }],
       "most-recent": [
       {
              "path": "/chain/blocks-after",
              "start-time": 9317511,
              "host": "88.12.55.125",
              "elapsed-time": 6,
              "id": 6452
       },
       {
              "path": "/chain/hashes-from",
              "start-time": 9317511,
              "host": "88.12.55.125",
              "elapsed-time": 6,
              "id": 6451
       }]
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>None.</p>

	<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
	<h2>Monitoring timers</h2>

	<api get>/debug/connections/timers</api>


	<desc>
	<p class=NemNoSpacing>Gets an array of task monitor structures
	as described in <appa>NemAsyncTimerVisitor</appa>. You can monitor
	the statistics for periodic tasks with this information.</p>
	</desc>

	<h4>No parameter:</h4>

	<h4>Example:</h4>

	<p><a href="http://127.0.0.1:7890/debug/timers">http://127.0.0.1:7890/debug/timers</a></p>

	<h4>Example of returned array of JSON <a href="#nemAsyncTimerVisitor">NemAsyncTimerVisitor</a> objects:</h4>

	<resp>
{
       "data": [
       {
              "last-delay-time": 3000,
              "executions": 1024,
              "failures": 0,
              "successes": 1024,
              "last-operation-start-time": 9317695,
              "is-executing": 0,
              "name": "FORAGING",
              "average-operation-time": 0,
              "last-operation-time": 0
       },
       {
              "last-delay-time": 74181,
              "executions": 71,
              "failures": 0,
              "successes": 71,
              "last-operation-start-time": 9317654,
              "is-executing": 0,
              "name": "REFRESH",
              "average-operation-time": 6,
              "last-operation-time": 7
       }]
}
	</resp>

	<h4>Possible Errors:</h4>

	<p class=NemNoSpacing>None.</p>


	<h1>Appendix A: Description of the JSON Structures</h1>

    <h2>AccountHistoricalDataViewModel</h2>
    <desc>
        <p class=NemNoSpacing>Nodes can support a feature for retrieving historical data of accounts.
            If a node supports this feature, it will return an array of AccountHistoricalDataViewModel objects.</p>
    </desc>

    <h4>JSON structure by example:</h4>

    <resp>
{
        "height": 8976,
        "address": "NALICELGU3IVY4DPJKHYLSSVYFFWYS5QPLYEZDJJ",
        "balance": 80670000000,
        "vestedBalance": 13949175142,
        "unvestedBalance": 66720824858,
        "importance": 0.00008166760846617221,
        "pageRank": 0.0006944567083595363
}
    </resp>

	<fields>
		<f name="height">The height for which the data is valid.</f>
		<f name="address">The address of the account.</f>
		<f name="balance">The balance of the account.</f>
		<f name="vestedBalance">The vested part of the balance.</f>
		<f name="unvestedBalance">The unvested part of the balance.</f>
		<f name="importance">The importance of the account.</f>
		<f name="pageRank">The page rank part of the importance.</f>
	</fields>

	<h2>AccountImportanceViewModel</h2>

	<desc>
	<p class=NemNoSpacing>Each account is assigned an importance
	in the NEM network. The ability of an account to generate new blocks is
	proportional to its importance. The importance is a number between 0 and 1.</p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{
       "address": "TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS"
       "importance":
       {
           "isSet": 1,
           "score": 0.0011561555164258449,
           "ev": 0.004367936531009263,
           "height": 38413
       }
}
	</resp>

	<fields>
		<f name="address">The address of the account.</f>
		<f name="importance">Substructure that describes the importance of the account.</f>
		<f name="isSet">Indicates if the fields &quot;score&quot;, &quot;ev&quot; and &quot;height&quot; are available.isSet can have the values 0 or 1. In case isSet is 0 the fields are not available.</f>
		<f name="score">The importance of the account. The importance ranges between 0 and 1.</f>
		<f name="ev">The page rank portion of the importance. The page rank ranges between 0 and 1.</f>
		<f name="height">The height at which the importance calculation was performed.</f>
	</fields>

	<h2>AccountInfo</h2>

	<desc>
	<p class=NemNoSpacing>The account structure describes basic information for an account.</p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{
       "address": "TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS",
       "balance": 124446551689680,
       "vestedBalance": 1041345514976241,
       "importance": 0.010263666447108395,
       "publicKey": "a11a1a6c17a24252e674d151713cdf51991ad101751e4af02a20c61b59f1fe1a",
       "label": null,
       "harvestedBlocks": 645
}
	</resp>

	<h4>Description of the fields:</h4>

	<fields>
		<f name="address">The address of the account.</f>
		<f name="balance">The balance of the account in micro NEM.</f>
		<f name="vestedBalance">The vested part of the balance of the account in micro NEM.</f>
		<f name="importance">The importance of the account.</f>
		<f name="publicKey">The public key of the account.</f>
		<f name="label">The label of the account (not used, always null).</f>
		<f name="harvestedBlocks">The number blocks that the account already harvested.</f>
	</fields>

	<h2>AccountMetaData</h2>

	<desc>
	<p class=NemNoSpacing>The account meta data describes
	additional information for the account. See <a href="#account-related-requests">Account related requests</a> for details.</p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{
       "status": "LOCKED",
       "remoteStatus": "ACTIVE",
        "cosignatoryOf" : [
            &lt;AccountInfo&gt;,
            &lt;AccountInfo&gt;
        ],
        "cosignatories" : [
            &lt;AccountInfo&gt;,
            &lt;AccountInfo&gt;
        ]
}
	</resp>

	<h4>Description of the fields:</h4>

	<table class=NemTableGrid>
		<tr>
			<td>
				<p class=JSON>status</p>
			</td>
			<td>
				<p>The harvesting status of a queried account.</p>
				<p>The harvesting status can be one of the following values:</p>
				<vals>
				&quot;UNKNOWN&quot;: The harvesting status of the account is not known.
				&quot;LOCKED&quot;: The account is not harvesting.
				&quot;UNLOCKED&quot;: The account is harvesting.
				</vals>
			</td>
		</tr>
		<tr>
			<td>
				<p class=JSON>remoteStatus</p>
			</td>
			<td>
				<p>The status of remote harvesting of a queried account.</p>
				<p>The remote harvesting status can be one of the following values:</p>
				<vals>
				&quot;REMOTE&quot;: The account is a remote account and therefore remoteStatus is not applicable for it.
				&quot;ACTIVATING&quot;: The account has activated remote harvesting but it is not yet active.
				&quot;ACTIVE&quot;: The account has activated remote harvesting and remote harvesting is active.
				&quot;DEACTIVATING&quot;: The account has deactivated remote harvesting but remote harvesting is still active.
				&quot;INACTIVE&quot;: The account has inactive remote harvesting, or it has deactivated remote harvesting and deactivation is operational.
				</vals>
			</td>
		</tr>
        <tr>
            <td><p class="JSON">cosignatoryOf</p></td>
            <td>
                <p>JSON array of  AccountInfo structures. The account is cosignatory for each of the accounts in the array.</p>
            </td>
        </tr>
        <tr>
            <td><p class="JSON">cosignatories</p></td>
            <td>
                <p>JSON array of  AccountInfo structures. The array holds all accounts that are a cosignatory for this account.</p>
            </td>
        </tr>
	</table>

	<h2>AccountMetaDataPair</h2>

	<desc>
	<p class=NemNoSpacing>The account meta data pair includes
	durable information for an account and additional information about its state.</p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{
    "account":
        &lt;AccountInfo&gt;,
    "meta":
        &lt;AccountMetaData&gt;
}
	</resp>

	<fields>
		<f name="account">Contains the account object.</f>
		<f name="&lt;AccountInfo&gt;">The account object as described in <a href="#accountInfo">AccountInfo</a>.</f>
		<f name="meta">Contains the account meta data object.</f>
		<f name="&lt;AccountMetaData&gt;">The account meta data object as described in <a href="#accountMetaData">AccountMetaData</a>.</f>
	</fields>

    <h2>AccountPrivateKeyTransactionsPage</h2>

    <desc>
    <p>The account private key transactions page contains data that NIS needs to
        retrieve a set of transactions from the database. The data includes the private
        key of the account for which transactions are retrieved. Use requests that use
        this structure only when NIS is running locally.</p>
    <p>The fields "hash" and "id" are optional.</p>
	</desc>

    <h4>JSON structure by example:</h4>
    <resp>
{
    "value": "68e4f79f886927de698df4f857de2aada41ccca6617e56bb0d61623b35b08cc0",
    "hash": "44e4968e5aa35fe182d4def5958e23cf941c4bf809364afb4431ebbf6a18c039",
    "id": "12345"
}
    </resp>

	<fields>
		<f name="value">The private key as hexadecimal string.</f>
		<f name="hash">The optional hash value.</f>
		<f name="id">The optional transaction id.</f>
	</fields>

	<h2>ApplicationMetaData</h2>

	<desc>
	<p class=NemNoSpacing>The application meta data object
	supplies additional information about the application running on a node.</p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{
       "currentTime": 9189086,
       "application": "NEM Infrastructure Server",
       "startTime": 9060202,
       "version": "0.4.30-BETA",
       "signer": "CN=NEM Community,OU=Development Team,O=NEM,L=Internet,ST=web,C=WD"
}
	</resp>

	<fields>
		<f name="currentTime">The current network time, i.e. the number of seconds that have elapsed since the creation of the nemesis block.</f>
		<f name="application">The name of the application running on the node.</f>
		<f name="startTime">The network time when the application was started.</f>
		<f name="version">The application version.</f>
		<f name="signer">The signer of the certificate used by the application.</f>
	</fields>

	<h2>AuditCollection</h2>

	<desc>
	<p class=NemNoSpacing>An audit collection consists of two
	arrays, containing information about incoming requests from other nodes. The
	first array contains information about outstanding (i.e. not yet processed
	requests) and the second array contains information about the most recent
	requests. The audit collection is for debug purposes.</p>
	</desc>

	<h4>JSON structure by example:</h4>
	<resp>
{
       "outstanding": [{
              "path": "/chain/score",
              "start-time": 9020618,
              "host": "86.124.91.183",
              "elapsed-time": 5,
              "id": 797725
       }],
       "most-recent": [{
              "path": "/push/transaction",
              "start-time": 9020621,
              "host": "hachi.nem.ninja",
              "elapsed-time": 2,
              id": 797750
       }]
}
	</resp>

	<fields>
		<f name="path">The relative URL path.</f>
		<f name="start-time">The number of seconds elapsed since the creation of the nemesis block.</f>
		<f name="host">The host which initiated the request.</f>
		<f name="elapsed-time">The time in seconds that has elapsed since the request was received.</f>
		<f name="id">The unique id of the request.</f>
	</fields>

	<h2>Block</h2>

	<desc>
	<p class=NemNoSpacing>A block is the structure that contains
	the transaction information. A block can contain up to 120 transactions. Blocks
	are generated and signed by accounts and are the instrument by which
	information is spread in the network.</p>
	</desc>

	<h4>JSON structure by example (main network):</h4>

	<resp>
{
       "timeStamp": 9022656,
       "signature": "256ebcfa4f92e2881963359c51095a390b9f4d1b3fee75ae19f96d5e6bcf055abbcaae3e55bcc17e6214924e4e6a9ebbe77357236b1a235e944950b851bda804",
       "prevBlockHash":
       {
              "data": "0a3d6bea020bb1a503364c37d57392342f368389bb23b05799c54d536d94749b"
       },
       "type": 1,
       "transactions": [
              Transaction1, Transaction2, &hellip;, Transaction11
       ],
       "version": 1744830465,
       "signer": "6c66ea288522990db7a0a63c9c20f532cdcb68dc3c9544fb20f7322c92ceadbb",
       "height": 39324
}
	</resp>

	<fields>
		<f name="timeStamp">The number of seconds elapsed since the creation of the nemesis block.</f>
		<f name="Signature">The signature of the block. The signature was generated by the
			signer and can be used to validate that the block data was not modified by a
			node.</f>
		<f name="prevBlockHash">The sha3-256 hash of the last block as hex-string.</f>
		<f name="type">The block type. There are currently two block types used:
			<vals>
				-1: Only the nemesis block has this type.
				1: Regular block type.
			</vals>
		</f>
		<f name="transactions">The array of transaction structures. See <appa>Transaction</appa> for more details about this structure.</f>
		<f name="version">The block version. The following versions are supported.
			<li>0x68 << 24 + 1 (1744830465 as 4 byte integer): the main network version</li>
			<li>0x98 << 24 + 1 (-1744830463 as 4 byte integer): the test network version</li></f>
		<f name="signer">The public key of the harvester of the block as hexadecimal number.</f>
		<f name="height">The height of the block. Each block has a unique height.
			Subsequent blocks differ in height by 1.</f>
	</fields>

	<h2>BlockChainScore</h2>

	<desc>
	<p class=NemNoSpacing>The block chain score is a measure how
	good the block chain is. The higher the score, the better the block chain is.</p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{
       "score": "17a3077c927d9a7e"
}
	</resp>

	<fields>
		<f name="score">The score is an integer greater or equal to zero. It is submitted in hexadecimal format.</f>
	</fields>

	<h2>BlockHeight</h2>

	<desc>
	<p class=NemNoSpacing>The block height describes the position
	of the block within the block chain. The first block of the chain has height
	one. Each subsequent block has a height which is one higher than the previous
	block.</p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{
       "height": 2649
}
	</resp>

	<fields>
		<f name="height">The height is an integer greater than zero.</f>
	</fields>

	<h2>BootNodeRequest</h2>

	<desc>
	<p class=NemNoSpacing>The BootNodeRequest JSNON object is used
	to transfer the relevant data for booting a local node to NIS. With the boot
	data NIS can create the local node object and connect to the network.</p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{
       "metaData":
       {
              "application":"NIS"
       },
       "endpoint":
       {
              "protocol":"http",
              "port":7890,
              "host":"localhost"
       },
       "identity":
       {
              "private-key":"a6cbd01d04edecfaef51df9486c111abb6299c764a00206eb1d01f4587491b3f",
              "name":"Alice"
       }
}
	</resp>

	<h4>Description of the fields:</h4>

	<fields>
		<f name="metaData">Denotes the beginning of the metaData substructure.</f>
		<f name="application">The application name.</f>
		<f name="endpoint">Denotes the beginning of the endpoint substructure.</f>
		<f name="protocol">The protocol to use (only HTTP supported as for now).</f>
		<f name="port">The port to use.</f>
		<f name="host">The IP address to use.</f>
		<f name="identity">Denotes the fof the identity substructure.</f>
		<f name="private-key">The private key used for creating the identity.</f>
		<f name="name">The name of the node (can be anything).</f>
	</fields>

	<h2>CommunicationTimeStamps</h2>

	<desc>
	<p class=NemNoSpacing>Communication timestamps contain
	information about the network time of a remote NIS. NEM uses a time
	synchronization mechanism to synchronize time across the network. Each node
	maintains a network time which is the time of the computer clock plus an offset
	which compensates for the deviation from the computer clocks of other nodes.</p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{
       "sendTimeStamp": 9145477789,
       "receiveTimeStamp": 9145477789
}
	</resp>

	<fields>
		<f name="sendTimeStamp">The network time at the moment the reply was sent.</f>
		<f name="receiveTimeStamp">The network time at the moment the request was received.</f>
	</fields>

	<h2>ExplorerBlockViewModel</h2>

	<desc>
	<p class=NemNoSpacing>The following structure is used by the
	NEM block chain explorer for convenience reason. The data is similar but not
	identical to that of a <a href="#block">Block</a>.</p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{
        "data":[
            {
                "txes":[
                    &lt;ExplorerTransferViewModel&gt;,
                    &vellip;
                    &lt;ExplorerTransferViewModel&gt;
                ],
                "block": &lt;Block&gt; ,
                "hash":"a6f62c62eedf4fafe6991e5cf31eae440963577c919f4eae86b4db8f8e572dce",
                "difficulty": 23456345897
            },
            &hellip;
        ]
}
	</resp>

	<fields>
		<f name="txes">Array containing the transactions of the block.</f>
		<f name="&lt;ExplorerTransferViewModel&gt;">The ExplorerBlockViewModel object as described in <a href="#explorerTransferViewModel">ExplorerTransferViewModel</a></f>
		<f name="block">Entry containing a JSON block object.</f>
		<f name="&lt;Block&gt;">The Block object as described in <appa>Block</appa></f>
		<f name="hash">The hash of the block as hexadecimal string.</f>
		<f name="difficulty">The block difficulty.</f>
	</fields>

	<h2>ExplorerTransferViewModel</h2>

	<desc>
	<p class=NemNoSpacing>The following structure is used by the
	NEM block chain explorer for convenience reason. The data is similar but not
	identical to that of a <a href="#transaction">Transaction</a> structure.</p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{
       "tx": &lt;Transaction&gt;,
       "hash": "5cba4614e52af19417fb53c4bdf442a57b9f558aee17ece530a5220da55cf47d",
       "innerHash": "ae3b107f1216e1ccf12b6f3c3c555bc1d95311747338ce66f539ea2c18c0aa57"
}
	</resp>

	<fields>
		<f name="tx">Entry containing the JSON Transaction object.</f>
		<f name="&lt;Transaction&gt;">The Transaction object. Depending on the type of the transaction the structure will look different. See <appa>Transaction objects</appa> for the different transaction types.</f>
		<f name="hash">The hash of the transaction.</f>
		<f name="innerHash">The hash of the inner transaction. This entry is only available for multisig transactions</f>
	</fields>

	<h2>ExtendedNodeExperiencePair</h2>

	<desc>
	<p class=NemNoSpacing>When exchanging data with other nodes
	the result of the communication is divided into three different outcomes:
	success, neutral and failure. In the cases of success and failure the result is
	saved to be able to judge the quality of a node. This has influence on the
	probability that a certain node is selected as partner.</p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{ 
       "node": 
       { 
              &lt;Node&gt; 
       }, 
       "syncs": 822, 
       "experience": 
       { 
              "s": 357, 
              "f": 0 
       } 
} 
	</resp>

	<fields>
		<f name="node">Denotes the beginning of the of the Node substructure.</f>
		<f name="&lt;Node&gt;">The remote Node object as described in <a href="#node">Node</a>.</f>
		<f name="syncs">The number of synchronization attempts the node had with the remote node.</f>
		<f name="experience">Denotes the beginning of the of the NodeExperience substructure.</f>
		<f name="s">The number of successful communications with the remote node.</f>
		<f name="f">The number of failed communications with the remote node.</f>
	</fields>

	<h2>HarvestInfo</h2>

	<desc>
	<p class=NemNoSpacing>A HarvestInfo object contains
	information about a block that an account harvested.</p>
	</desc>

	<h4>JSON structure by example:</h4>
	<resp>
{ 
       "timeStamp": 8963798, 
       "id": 254378,
       "difficulty": 46534789865332,
       "totalFee": 2041299054, 
       "height": 38453 
} 
	</resp>

	<fields>
		<f name="timeStamp">The number of seconds elapsed since the creation of the nemesis block.</f>
		<f name="id">The database id for the harvested block.</f>
		<f name="difficulty">The block difficulty. The initial difficulty was set to 100000000000000. The block difficulty is always between one tenth and ten times the initial difficulty.</f>
		<f name="totalFee">The total fee collected by harvesting the block.</f>
		<f name="height">The height of the harvested block.</f>
	</fields>

    <h2>KeyPairViewModel</h2>

    <desc>
        <p class=NemNoSpacing>A KeyPairViewModel object contains
            information about a new account. Information includes the private key,
            the public key and the address</p>
    </desc>

    <h4>JSON structure by example:</h4>
    <resp>
{
    "privateKey": "0962c6505d02123c40e858ff8ef21e2b7b5466be12c4770e3bf557aae828390f",
    "publicKey": "c2e19751291d01140e62ece9ee3923120766c6302e1099b04014fe1009bc89d3",
    "address": "NCKMNCU3STBWBR7E3XD2LR7WSIXF5IVJIDBHBZQT"
}
    </resp>

    <fields>
        <f name="privateKey">The private key of the account as hexadeciaml string.</f>
        <f name="publicKey">The public key of the account as hexadeciaml string.</f>
        <f name="address">The address of the account.</f>
    </fields>

    <h2>Transaction objects</h2>

    <h3>Importance Transfer Transaction</h3>
    <desc>
	<p class=NemNoSpacing>NIS has the ability to transfer the importance of one
        account to another account for harvesting. The account receiving the
        importance is called the remote account. Importance transfer transactions
        are part of the secure harvesting feature of NEM. Once an importance
        transaction has been included in a block it needs 24 hours to become active.</p>
	</desc>

    <h4>JSON structure by example (main network):</h4>
    <resp>
{
    "timeStamp": 9111526,
    "signature": "651a19ccd09c1e0f8b25f6a0aac5825b0a20f158ca4e0d78f2abd904a3966b6e3599a47b9ff199a3a6e1152231116fa4639fec684a56909c22cbf6db66613901",
    "fee": 3000000,
    "mode": 1,
    "remoteAccount": "cc6c9485d15b992501e57fe3799487e99de272f79c5442de94eeb998b45e0144",
    "type": 257,
    "deadline": 9154726,
    "version": 1744830465,
    "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
}
    </resp>

    <fields>
        <f name="timeStamp">The number of seconds elapsed since the creation of
            the nemesis block.</f>
        <f name="signature">The transaction signature (missing if part of a multisig
            transaction).</f>
        <f name="fee">The fee for the transaction. The higher the fee, the higher the
            priority of the transaction. Transactions with high priority get included in
            a block before transactions with lower priority.</f>
        <f name="mode">
            The mode. Possible values are:
            <vals>
                1: Activate remote harvesting.
                2: Deactivate remote harvesting.
            </vals>
        </f>
        <f name="remoteAccount">The public key of the receiving account as
            hexadecimal string.</f>
        <f name="type">The transaction type.</f>
        <f name="deadline">The deadline of the transaction. The deadline is given as
            the number of seconds elapsed since the creation of the nemesis block.
            If a transaction does not get included in a block before the deadline is
            reached, it is deleted.</f>
        <f name="version">The version of the structure.</f>
        <f name="signer">The public key of the account that created the transaction.</f>
    </fields>

    <h3>MultisigAggregateModificationTransaction</h3>
    <desc>
        <p>Multisig aggregate modification transactions are part of the NEM's multisig
            account system. A multisig aggregate modification transaction holds an array
            of multisig cosignatory modifications and a single multisig minimum cosignatories
			modification inside the transaction. A multisig aggregate
            modification transaction can be wrapped by a multisig transaction.
			Aggregate modification transactions that use the minCosignatories field need to have
			version 0x68000002 (decimal 1744830466) for mainnet and 0x98000002 (decimal -1744830462)
			for testnet.
		</p>
    </desc>

    <h4>JSON structure by example (main network):</h4>
    <resp>
{
	"timeStamp": 9111526,
	"signature": "651a19ccd09c1e0f8b25f6a0aac5825b0a20f158ca4e0d78f2abd904a3966b6e3599a47b9ff199a3a6e1152231116fa4639fec684a56909c22cbf6db66613901",
	"fee": 3000000,
	"type": 257,
	"deadline": 9154726,
	"version": 1744830466,
	"signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a",
	"modifications": [
		&lt;MultisigCosignatoryModification&gt;,
		&lt;MultisigCosignatoryModification&gt;
	],
	"minCosignatories" : {
		"relativeChange" : 2
	}
}
    </resp>
    <fields>
        <f name="timeStamp">The number of seconds elapsed since the creation of the nemesis block.</f>
        <f name="signature">The transaction signature (missing if part of a multisig transaction).</f>
        <f name="fee">The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.</f>
        <f name="type">The transaction type.</f>
        <f name="deadline">The deadline of the transaction. The deadline is given as the number of seconds elapsed since the creation of the nemesis block. If a transaction does not get included in a block before the deadline is reached, it is deleted.</f>
        <f name="version">The version of the structure.</f>
        <f name="signer">The public key of the account that created the transaction.</f>
		<f name="modifications">The JSON array of multisig modifications.</f>
		<f name="minCosignatories">JSON object that holds the minimum cosignatories modification.</f>
		<f name="relativeChange">Value indicating the relative change of the minimum cosignatories.</f>
    </fields>

	<h3>MultisigCosignatoryModification</h3>
	<desc><p>Multisig cosignatory modifications are part of the NEM's multisig account system.
		With a multisig cosignatory modification a cosignatory is added to or deleted from a multisig
		account. Multisig cosignatory modifications are part of a multisig aggregate modification
		transactions, see details there.</p></desc>
	<h4>JSON structure by example:</h4>
	<resp>
{
	"modificationType": 1,
	"cosignatoryAccount": "213150649f51d6e9113316cbec5bf752ef7968c1e823a28f19821e91daf848be"
}
	</resp>
	<fields>
		<f name="modificationType">The type of modification. Possible values are:
			<vals>
				1: Add a new cosignatory.
				2: Delete an existing cosignatory.
			</vals></f>
		<f name="cosignatoryAccount">The public key of the cosignatory account as hexadecimal string</f>
	</fields>

	<h3>MultisigSignatureTransaction</h3>
    <desc><p>Multisig signature transactions are part of the NEM's multisig account
        system. Multisig signature transactions are included in the corresponding
        multisig transaction and are the way a cosignatory of a multisig account can
        sign a multisig transaction for that account.</p></desc>

    <h4>JSON structure by example (test network):</h4>
    <resp>
{
	"timeStamp": 9111526,
	"signature": "651a19ccd09c1e0f8b25f6a0aac5825b0a20f158ca4e0d78f2abd904a3966b6e3599a47b9ff199a3a6e1152231116fa4639fec684a56909c22cbf6db66613901",
	"fee": 3000000,
	"type": 257,
	"deadline": 9154726,
	"version": -1744830463,
	"signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a",
	"otherHash": {
		"data": "44e4968e5aa35fe182d4def5958e23cf941c4bf809364afb4431ebbf6a18c039"
	},
	"otherAccount": "TDGIMREMR5NSRFUOMPI5OOHLDATCABNPC5ID2SVA"
}
    </resp>
    <fields>
        <f name="timeStamp">The number of seconds elapsed since the creation of the nemesis block.</f>
        <f name="signature">The transaction signature.</f>
        <f name="fee">The fee for the transaction.</f>
        <f name="type">The transaction type.</f>
        <f name="deadline">The deadline of the transaction. The deadline is given as the number of seconds elapsed since the creation of the nemesis block. If a transaction does not get included in a block before the deadline is reached, it is deleted.</f>
        <f name="version">The version of the structure.</f>
        <f name="signer">The public key of the account that created the transaction.</f>
        <f name="otherHash">The hash of the inner transaction of the corresponding multisig transaction.</f>
        <f name="otherAccount">The address of the corresponding multisig account.</f>
    </fields>

    <h3>MultisigTransaction</h3>
    <desc><p>Multisig transaction are the only way to make transaction from
        a multisig account to another account. A multisig transaction carries another
        transaction inside (often referred to as "inner" transaction). The inner
        transaction can be a transfer, an importance transfer or an aggregate
        modification transaction. A multisig transaction also has multisig signature
        transactions from the cosignatories of the multisig account inside.</p></desc>

    <h4>JSON structure by example (test network):</h4>
    <resp>
{
	"timeStamp": 9111526,
	"signature": "651a19ccd09c1e0f8b25f6a0aac5825b0a20f158ca4e0d78f2abd904a3966b6e3599a47b9ff199a3a6e1152231116fa4639fec684a56909c22cbf6db66613901",
	"fee": 3000000,
	"type": 257,
	"deadline": 9154726,
	"version": -1744830463,
	"signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a",
	"otherTrans": &lt;inner transaction&gt;,
	"signatures":[
		&lt;MultisigSignatureTransaction&gt;,
		&lt;MultisigSignatureTransaction&gt;
	]
}
    </resp>
	<fields>
	<f name="timeStamp"> The number of seconds elapsed since the creation of the nemesis block.</f>
        <f name="signature"> The transaction signature.</f>
        <f name="fee"> The fee for the transaction.</f>
        <f name="type"> The transaction type.</f>
        <f name="deadline"> The deadline of the transaction. The deadline is given as the number of seconds elapsed since the creation of the nemesis block. If a transaction does not get included in a block before the deadline is reached, it is deleted.</f>
        <f name="version"> The version of the structure.</f>
        <f name="signer"> The public key of the account that created the transaction.</f>
        <f name="otherTrans"> The inner transaction. The inner transaction can be a transfer transaction, an importance transfer transaction or a multisig aggregate modification transaction. The inner transaction does not have a  valid signature.</f>
        <f name="signatures"> The JSON array of MulsigSignatureTransaction objects.</f>
	</fields>
    
	<h3>TransferTransaction</h3>

	<desc> <p class=NemNoSpacing>Transactions contain data about account activity. They are collected and stored in blocks.</p></desc>

    <h4>JSON structure by example (test network):</h4>
	<resp>
{ 
	"timeStamp": 9111526, 
	"amount": 1000000000, 
	"signature": "651a19ccd09c1e0f8b25f6a0aac5825b0a20f158ca4e0d78f2abd904a3966b6e3599a47b9ff199a3a6e1152231116fa4639fec684a56909c22cbf6db66613901", 
	"fee": 3000000, 
	"recipient": "TDGIMREMR5NSRFUOMPI5OOHLDATCABNPC5ID2SVA", 
	"type": 257, 
	"deadline": 9154726, 
	"message": 
	{ 
		"payload": "74657374207472616e73616374696f6e", 
		"type": 1 
	}, 
	"version": -1744830463,
	"signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a" 
} 
	</resp>

	<fields>
		<f name="timeStamp">The number of seconds elapsed since the creation of the nemesis block.</f>
		<f name="amount">The amount of micro NEM that is transferred from sender to recipient.</f>
		<f name="signature">The transaction signature.</f>
		<f name="fee">The fee for the transaction. The higher the fee, the higher the
				priority of the transaction. Transactions with high priority get included in
				a block before transactions with lower priority.</f>
		<f name="recipient">The address of the recipient.</f>
		<f name="type">The transaction type.</f>
		<f name="deadline">The deadline of the transaction. The deadline is given as the
				number of seconds elapsed since the creation of the nemesis block. If a
				transaction does not get included in a block before the deadline is reached, it
				is deleted.</f>
		<f name="message">Optionally a transaction can contain a message. In this case the
				transaction contains a message substructure. If not the field is null.</f>
		<f name="payload">
				Optional field in case the transaction contains a message. The
				payload is the actual (possibly encrypted) message data.</f>
		<f name="type">
				Optional field in case the transaction contains a message. The
				field holds the message type information. Possible message types are:
				<vals>
				1: The message is not encrypted.
				2: The message is encrypted.
				</vals>
		</f>
		<f name="version">The version of the structure.</f>
		<f name="signer">The public key of the account that created the transaction.</f>
	</fields>

	<h2>NemAnnounceResult</h2>
	<desc><p>The NemAnnounceResult extends the <a href="#nemRequestResult">NemRequestResult</a>
        by supplying the additional fields 'transactionHash' and in case of a multisig transaction 'innerTransactionHash'.</p></desc>

    <h4>JSON structure by example:</h4>
	<resp>
{
    "type": 4,
    "code": 6,
    "message": "status",
    "transactionHash": {
        "data":"c1786437336da077cd572a27710c40c378610e8d33880bcb7bdb0a42e3d35586"
    },
    "innerTransactionHash": {
        "data": "44e4968e5aa35fe182d4def5958e23cf941c4bf809364afb4431ebbf6a18c039"
    }
}
	</resp>
	<fields>
		<f name="type"> See description of <a href="#nemRequestResult">NemRequestResult</a>.</f>
        <f name="code"> See description of <a href="#nemRequestResult">NemRequestResult</a>.</f>
        <f name="message"> See description of <a href="#nemRequestResult">NemRequestResult</a>.</f>
        <f name="transactionHash"> The JSON hash object of the transaction.</f>
        <f name="innerTransactionHash"> The JSON hash object of the inner transaction or null if the transaction is not a multisig transaction.</f>
	</fields>

    <h2>NemAsyncTimerVisitor</h2>
	<desc><p>NIS uses timers to schedule periodic
	tasks. Those tasks are monitored and their result is memorized. The
	NemAsyncTimeVisitor structure holds  the information.</p></desc>

    <h4>JSON structure by example:</h4>
	<resp>
{ 
       "last-delay-time": 3000, 
       "executions": 1024, 
       "failures": 0, 
       "successes": 1024, 
       "last-operation-start-time": 9317695, 
       "is-executing": 0, 
       "name": "FORAGING", 
       "average-operation-time": 0, 
       "last-operation-time": 0 
} 
	</resp>

	<fields>
		<f name="last-delay-time">The number of milliseconds since the last execution of the timer.</f>
		<f name="executions">The number of times the task was executed.</f>
		<f name="failures">The number times the task failed.</f>
		<f name="successes">The number times the task was successful.</f>
		<f name="last-operation-start-time">The time at which the task started last time.</f>
		<f name="is-executing">True if the task is executing, false otherwise.</f>
		<f name="name">The name of the task.</f>
		<f name="average-operation-time">The number of seconds the task needed on average.</f>
		<f name="last-operation-time">The number of seconds the task needed the last time.</f>
	</fields>

	<h2>NemRequestResult</h2>

	<p>Some requests such as announcing a new
	transaction return detailed information about the outcome of the request. In
	those cases the result of the request is returned in a special JSON object
	called NemRequestResult. The structure is typically used for requests that
	perform validation or return a status.</p>

	<h4>JSON structure by example:</h4>

	<resp>
{ 
       "type": 4, 
       "code": 6, 
       "message": "status" 
}  
	</resp>

	<fields>
		<f name="type"><p>The type is dependent on the request which was answered.</p>
			<p>The interpretation of the code field depends on the type. Currently the following
			types are supported:</p>
			<p>            </p>
			<vals>
				1: The result is a validation result.
				2: The result is a heart beat result.
				4: The result indicates a status.
			</vals>
		</f>
		<f name="code">The meaning of the code is dependent on the type.
			For type 1 (validation result) only 0 and 1 mean there was no
			failure. For a complete list of validation results see <alnk>Appendix B: NIS Errors</alnk>
			The following codes are the most frequent ones occurring:
			<vals>
				0:Neutral result. A typical example would be that a node validates an incoming transaction and realizes that it already knows about the transaction. In this case it is neither a success (meaning the node has a new transaction) nor a failure (because the transaction itself is valid).
				1:Success result. A typical example would be that a node validates a new valid transaction.
				2:Unknown failure. The validation failed for unknown reasons.
				3:The entity that was validated has already past its deadline.
				4:The entity used a deadline which lies too far in the future.
				5:There was an account involved which had an insufficient balance to perform the operation.
				6:The message supplied with the transaction is too large.
				7:The hash of the entity which got validated is already in the database.
				8:The signature of the entity could not be validated.
				9:The entity used a timestamp that lies too far in the past.
				10:The entity used a timestamp that lies in the future which is not acceptable.
				11:The entity is unusable.
				12:The score of the remote block chain is inferior (although a superior score was promised).
				13:The remote block chain failed validation.
				14:There was a conflicting importance transfer detected.
				15:There were too many transaction in the supplied block.
				16:The block contains a transaction that was signed by the harvester.
				17:A previous importance transaction conflicts with a new transaction.
				18:An importance transfer activation was attempted while previous one is active.
				19:An importance transfer deactivation was attempted but is not active.
			</vals>
			<p>            </p>
			<p>For type 2 the following codes are supported:</p>
			<vals>
				1:Successful heart beat detected.
			</vals>
			<p></p>
			<p>For type 3 the following codes are supported:</p>
			<vals>
				0:Unknown status.
				1:NIS is stopped.
				2:NIS is starting.
				3:NIS is running.
				4:NIS is booting the local node (implies NIS is running).
				5:The local node is booted (implies NIS is running).
				6:The local node is synchronized (implies NIS is running and the local node is booted).
				7:There is no remote node available (implies NIS is running and the local node is booted).
				8:NIS is currently loading the block chain.
			</vals>
		</f>
	</fields>

	<h2>NisNodeInfo</h2>

	<desc>
	<p class=NemNoSpacing>The NisNodeInfo object provides detailed information about a node.</p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{ 
       "node": { 
              &lt;Node&gt; 
       }, 
       "nisInfo": { 
              &lt;ApplicationMetaData&gt; 
       } 
} 
	</resp>

	<fields>
		<f name="node">Denotes the beginning of the node substructure.</f>
		<f name="&lt;Node&gt;">The Node object as described in <a href="#node">Node</a>.</f>
		<f name="nisInfo">Denotes the beginning of the application meta data substructure.</f>
		<f name="&lt;ApplicationMetaData&gt;">The ApplicationMetaData object as described in <a href="#applicationMetaData">ApplicationMetaData</a>.</f>
	</fields>

	<h2>Node</h2>

	<desc>
	<p class=NemNoSpacing>Nodes are the entities that perform
	communication in the network like sending and receiving data. A node has an
	identity which is tied to an account through which the node can identify itself
	to the network. The communication is done through the endpoint of the node.
	Additionally a node provides meta data information.</p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{ 
       "metaData": 
       {
              "features": 1,
              "networkId": 104,
              "application": "NIS", 
              "version": "0.4.30-BETA", 
              "platform": "Oracle Corporation (1.8.0_05) on Windows 8.1" 
       }, 
       "endpoint": 
       { 
              "protocol": "http", 
              "port": 7890, 
              "host": "85.25.36.97" 
       }, 
       "identity": 
       { 
              "name": "Hi, I am Alice2", 
              "public-key": "3302e7703ee9f364c25bbfebb9c12ac91fa9dcd69e09a5d4f3830d71505a2350" 
       } 
} 
	</resp>

	<fields>
		<f name="metaData">Denotes the beginning of the meta data substructure.</f>
		<f name="features">The number of features the nodes has.</f>
		<f name="networkId"><p>The network id. The following network ids are supported:</p>
			<li>104 (hex 0x68): The main network id.</li>
			<li>152 (hex 0x98): The test network id.</li>
		</f>
		<f name="application">The name of the application that is running the node.</f>
		<f name="version">The version of the application.</f>
		<f name="platform">The underlying platform (OS, java version).</f>
		<f name="endpoint">Denotes the beginning of the endpoint substructure.</f>
		<f name="protocol">The protocol used for the communication (HTTP or HTTPS).</f>
		<f name="port">The port used for the communication.</f>
		<f name="host">The IP address of the endpoint.</f>
		<f name="identity">Denotes the beginning of the identity substructure.</f>
		<f name="name">The name of the node.</f>
		<f name="public-key">The public key used to identify the node.</f>
	</fields>

	<h2>NodeCollection</h2>

	<desc>
	<p class=NemNoSpacing>A NodeCollection object holds arrays of nodes
	with different statuses. The following statuses are supported:</p>
	</desc>

	<fields>
		<f name="inactive">A connection to the node cannot be established.</f>
		<f name="active">A connection can be established and the remote node responds in a timely manner.</f>
		<f name="busy">A connection can be established but the node cannot provide
			information within the timeout limits.</f>
		<f name="failure">A fatal error occurs when trying to establish a connection or the
			node couldn't authenticate itself correctly.</f>
		<f name="data">Generic status indicating the node collection just lists nodes without
			saying anything about the status of the node.</f>
	</fields>

	<h4>JSON structure by example:</h4>

	<resp>
{ 
       "inactive": [ 
              &lt;Node&gt;, 
              &lt;Node&gt; 
       ], 
       "active": [ 
              &lt;Node&gt;, 
              &lt;Node&gt; 
       ], 
       "busy": [ 
              &lt;Node&gt;, 
              &lt;Node&gt; 
       ], 
       "failure": [ 
              &lt;Node&gt;, 
              &lt;Node&gt; 
       ], 
} 
	</resp>

	<fields>
		<f name="inactive">Denotes the beginning of the array of inactive nodes.</f>
		<f name="active">Denotes the beginning of the array of active nodes.</f>
		<f name="busy">Denotes the beginning of the array of busy nodes.</f>
		<f name="failure">Denotes the beginning of the array of failing nodes.</f>
		<f name="&lt;Node&gt;">The Node object as described in <a href="#node">Node</a>.</f>
	</fields>

	<h2>PrivateKey</h2>

	<desc>
	<p class=NemNoSpacing>A private key is a key to an account.
	Anyone having the private key to an account can initiate any account related
	action. <strong>Therefore a private key must be kept secret at all costs.</strong></p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{
	"value": "68e4f79f886927de698df4f857de2aada41ccca6617e56bb0d61623b35b08cc0",
}
	</resp>

	<fields>
		<f name="value">The 256 bit value of the private key as hexadecimal string.</f>
	</fields>

    <h2>RequestAnnounce</h2>

    <desc>
        <p class=NemNoSpacing>A RequestAnnounce object is used
            to transfer the transaction data and the signature to NIS in order to initiate and
            broadcast a transaction.</p>
    </desc>

    <h4>JSON structure by example:</h4>

    <resp>
{
        "data": "010100000100000000000000200000002b76078fa709bbe675
                 2222b215abc7ec0152ffe831fb4f9aed3e7749a425900a0009
                 3d0000000000000000002800000054444e46555946584f5353
                 334e4e4c4f35465a5348535a49354c33374b4e514945485055
                 4d584c54c0d45407000000000b00000001000000030000000c
                 3215",
        "signature": "db2473513c7f0ce9f8de6345f0fbe773
                      dc687eb571123d08eab4d98f96849eae
                      b63fa8756fb6c59d9b9d0e551537c1cd
                      ad4a564747ff9291db4a88b65c97c10d"
}
    </resp>

	<fields>
		<f name="data">The transaction data as string. The string is created by
			first creating the corresponding byte array (see chapter 6.7)
			and then converting the byte array to a hexadecimal string.</f>
		<f name="signature">The signature for the transaction as hexadecimal string.</f>
	</fields>

	<h2>RequestPrepareAnnounce</h2>

	<desc>
	<p class=NemNoSpacing>A RequestPrepareAnnounce object is used
	to transfer transaction data and a private key to NIS in order to initiate and
	broadcast a transaction.</p>
	</desc>

	<h4>JSON structure by example (test network):</h4>

	<resp>
{ 
       "transaction": 
       { 
              "timeStamp": 9111526, 
              "amount": 1000000000, 
              "fee": 3000000, 
              "recipient": "TDGIMREMR5NSRFUOMPI5OOHLDATCABNPC5ID2SVA", 
              "type": 257, 
              "deadline": 9154726, 
              "message": 
              { 
                     "payload": "74657374207472616e73616374696f6e", 
                     "type": 1 
              }, 
              "version": -1744830463,
              "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a" 
       }, 
       "privateKey": "68e4f79f886927de698df4f857de2aada41ccca6617e56bb0d61623b35b08cc0"
}
	</resp>

	<fields>
		<f name="transaction">Denotes the beginning of the transaction data part. The
			transaction data is described in <appa>Transaction</appa>. The field 'signature is
			missing since the transaction is not signed at this point.</f>
		<f name="privateKey">The private key which NIS will use to sign the transaction.</f>
	</fields>
	<h2>TimeSynchronizationResult</h2>

	<desc>
	<p class=NemNoSpacing>A time synchronization result is the
	outcome of the network time synchronization of a node with other remote nodes.
	To agree upon a common time nodes need to synchronize time every hour.</p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{ 
       "dateTime": "2014-11-16 20:47:06", 
       "currentTimeOffset": 2786, 
       "change": 36 
} 
	</resp>

	<fields>
		<f name="dateTime">The date and time when the synchronization was performed.</f>
		<f name="currentTimeOffset">The current offset to the local computer clock in milliseconds.</f>
		<f name="change">The change in milliseconds compared to the last synchronization.</f>
	</fields>

	<h2>TransactionMetaData</h2>

	<desc>
	<p class=NemNoSpacing>Transactions meta data object contains
	additional information about the transaction.</p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{ 
       "height": 40706,
        "id": 2769,
        "hash": {
            "data":"37c34ead4c3fe6af42d994135798262f785ba2d807c02ac3608bc10da12e5f87"
        }
}
	</resp>

	<fields>
		<f name="height">The height of the block in which the transaction was included.</f>
		<f name="id">The id of the transaction.</f>
		<f name="hash">The transaction hash.</f>
	</fields>

	<h2>TransactionMetaDataPair</h2>

	<desc>
	<p class=NemNoSpacing>Transactions meta data object contains
	additional information about the transaction.</p>
	</desc>

	<h4>JSON structure by example:</h4>

	<resp>
{ 
       "meta": 
              &lt;TransactionMetaData&gt;, 
       "transaction": 
              &lt;Transaction&gt; 
} 
	</resp>

	<fields>
		<f name="meta">Contains the transaction meta data object.</f>
		<f name="&lt;TransactionMetaData&gt;">The transaction meta data object as described in <a
				href="#transactionMetaData">TransactionMetaData</a>.</f>
		<f name="Transaction">Contains the transaction object.</f>
		<f name="&lt;Transaction&gt;">The transaction object as described in <a
				href="#transaction">Transaction</a>.</f>
	</fields>

	<h2>UnconfirmedTransactionMetaData</h2>
	<desc>The unconfirmed transaction meta data contains the hash of the inner transaction in case the transaction is a multisig transaction. This data is need to initiate a multisig signature transaction.</desc>
	<resp>
{
	data": "d7c9e33421e43bf4a5d6e21304c8096c599142755d581bd6e9037f41545a5873"
}
	</resp>
	<fields>
		<f name="data">The hash of the inner transaction or null if the transaction is not a multisig transaction.</f>
	</fields>

	<h2>UnconfirmedTransactionMetaDataPair</h2>
	<desc>Transactions meta data object contains additional information about the transaction.</desc>
	<resp>
{
	"meta":
		&lt;UnconfirmedTransactionMetaData&gt;,
	"transaction":
		&lt;Transaction&gt;
}
	</resp>
	<fields>
		<f name="meta"> Contains the transaction meta data object.</f>
		<f name="&lt;UnconfirmedTransactionMetaData&gt;"> The transaction meta data object as described in UnconfirmedTransactionMetaData.</f>
		<f name="transaction"> Contains the transaction object.</f>
		<f name="&lt;Transaction&gt;"> The transaction object as described in Transaction.</f>
	</fields>


	<h2>Error object</h2>

	<desc>
	<p class=NemNoSpacing>If NIS encounters an error due to either
	invalid requests or internal problems, it returns a JSON error object. The
	interpretation of the error object is dependant on the context. See <alnk>Appendix B: NIS Errors</alnk> for detailed information about possible errors.</p>
	</desc>

	<h4>JSON structure by example</h4>

	<resp>
{ 
       "timeStamp": 9108808, 
       "error": "Bad Request", 
       "message": "address must be valid", 
       "status": 400 
} 
	</resp>

	<fields>
		<f name="timeStamp">The number of seconds elapsed since the creation of the nemesis block.</f>
		<f name="error">The general description of the error.</f>
		<f name="message">The detailed error message.</f>
		<f name="Status">The HTTP status.</f>
	</fields>

	<h1>Appendix B: NIS Errors</h1>

	<p>In case NIS encounters an error while
	processing a request it returns a JSON error object whose structure is
	described in <appa>Error object</appa>. This chapter describes the
	errors messages that can be returned from NIS.</p>

	<h2>Error messages</h2>

	<dl>
		<dt>Request method 'GET' not supported</dt>
		<dd>The request was performed as GET request but was expected to be a POST request.</dd>

		<dt>address must be valid:</dt>
		<dd>At least one address supplied in the request was invalid. Addresses are validated before processing a request. If validation fails, an error containing this message is returned.</dd>

		<dt>FAILURE_SERVER_LIMIT:</dt>
		<dd>The number of accounts that are allowed to harvest on NIS was exceeded.</dd>

		<dt>JSON Object was expected:</dt>
		<dd>A parameter is missing in the request.</dd>

		<dt>FAILURE_UNKNOWN_ACCOUNT:</dt>
		<dd>The account specified in the request is not known.</dd>

		<dt>block not found in the db</dt>
		<dd>The block that was requested could not be found in the database.</dd>

		<dt>height must be positive</dt>
		<dd>The block height supplied in a request was zero or negative. Block height must always be greater than zero.</dd>

		<dt>network has not been booted yet</dt>
		<dd>Most requests need the node that should answer the request to be already booted. If node is not booted yet, this error message will be returned.</dd>

		<dt>network boot was already attempted</dt>
		<dd>It was attempted to boot an already booted node. Nodes can only be booted once.</dd>

		<dt>remote 123.45.67.89 attempted to call local /node/boot</dt>
		<dd>It was attempted to boot a remote node.  Only local node can be booted.</dd>

		<dt>FAILURE_PAST_DEADLINE</dt>
		<dd>The deadline for the entity has already expired. The deadline must always lie in the future.</dd>

		<dt>FAILURE_FUTURE_DEADLINE</dt>
		<dd>The deadline lies too far in the future.  Deadlines are only allowed to lie up to 24 hours in the future.</dd>

		<dt>FAILURE_INSUFFICIENT_BALANCE</dt>
		<dd>The account does not have enough funds.</dd>

		<dt>FAILURE_MESSAGE_TOO_LARGE</dt>
		<dd>The message for the transaction exceeds the limit of 512 bytes.</dd>

		<dt>FAILURE_HASH_EXISTS</dt>
		<dd>The hash of the entity already exists either in the cache or in the database.</dd>

		<dt>FAILURE_SIGNATURE_NOT_VERIFIABLE</dt>
		<dd>The signature of the entity failed upon verification.</dd>

		<dt>FAILURE_TIMESTAMP_TOO_FAR_IN_PAST</dt>
		<dd>The timestamp of the entity lies to far in the past.</dd>

		<dt>FAILURE_TIMESTAMP_TOO_FAR_IN_FUTURE</dt>
		<dd>The timestamp of the entity lies too far in the future.</dd>

		<dt>FAILURE_INELIGIBLE_BLOCK_SIGNER</dt>
		<dd>Validation failed because the block had an ineligible signer. This usually occurs when remote harvesting is in the process of being activated or deactivated.</dd>

		<dt>FAILURE_ENTITY_UNUSABLE_OUT_OF_SYNC</dt>
		<dd>The entity cannot be processed because the remote node is out of synchronization with the local node. This happens frequently when a node is not fully synchronized and receives a new block with much larger height than its own chain.</dd>

		<dt>FAILURE_INSUFFICIENT_FEE</dt>
		<dd>The supplied transaction has an insufficient fee.</dd>

		<dt>FAILURE_NEMESIS_ACCOUNT_TRANSACTION_AFTER_NEMESIS_BLOCK</dt>
		<dd>The supplied transaction has the nemesis account as sender and cannot be included in a normal block.</dd>

		<dt>FAILURE_TRANSACTION_CACHE_TOO_FULL</dt>
		<dd>The transaction was rejected because the transaction cache is too full. This happens when an account tries to send too many transactions in a short time. To improve the chance that the transaction gets accepted you can try to raise the transaction fee.</dd>

		<dt>FAILURE_WRONG_NETWORK</dt>
		<dd>Entity was rejected because it has the wrong network specified.</dd>

		<dt>FAILURE_CANNOT_HARVEST_FROM_BLOCKED_ACCOUNT</dt>
		<dd>Block was rejected because it was harvested by a blocked account (typically a reserved NEM fund).</dd>

		<dt>FAILURE_DESTINATION_ACCOUNT_HAS_NONZERO_BALANCE</dt>
		<dd>The importance cannot be transferred to an account with nonzero balance.</dd>

		<dt>FAILURE_IMPORTANCE_TRANSFER_IN_PROGRESS</dt>
		<dd>The transaction is conflicting because there is already a transfer of importance in progress.</dd>

		<dt>FAILURE_IMPORTANCE_TRANSFER_NEEDS_TO_BE_DEACTIVATED</dt>
		<dd>The transaction is conflicting because the importance was already transferred.</dd>

		<dt>FAILURE_IMPORTANCE_TRANSFER_IS_NOT_ACTIVE</dt>
		<dd>The transaction is conflicting because no importance has been transferred yet.</dd>

		<dt>FAILURE_TRANSACTION_NOT_ALLOWED_FOR_REMOTE</dt>
		<dd>Validation failed because transaction is using remote account in an improper way.</dd>

		<dt>FAILURE_MULTISIG_NOT_A_COSIGNER</dt>
		<dd>The multisig transaction was rejected because the signer of the transaction is not a cosignatory of the sender account of the inner transaction.</dd>

		<dt>FAILURE_MULTISIG_INVALID_COSIGNERS</dt>
		<dd>Validation failed because the cosignatories attached to a multisig transaction were invalid.</dd>

		<dt>FAILURE_MULTISIG_NO_MATCHING_MULTISIG</dt>
		<dd>The signature transaction was rejected because the corresponding multisig transaction was not found.</dd>

		<dt>FAILURE_TRANSACTION_NOT_ALLOWED_FOR_MULTISIG</dt>
		<dd>The transaction was rejected because the signer is a multisig account. Multisig accounts are not allowed to initiate any transaction (only cosignatories are allowed to do so).</dd>

		<dt>FAILURE_MULTISIG_ALREADY_A_COSIGNER</dt>
		<dd>The transaction was rejected because it tried to add a cosignatory to a multisig account which already has this cosignatory.</dd>

		<dt>FAILURE_MULTISIG_MODIFICATION_MULTIPLE_DELETES</dt>
		<dd>The transaction was rejected because it tried to remove multiple cosignatories at once. It is only allowed to remove one cosignatory at a time.</dd>

		<dt>FAILURE_MULTISIG_MODIFICATION_REDUNDANT_MODIFICATIONS</dt>
		<dd>The transaction was rejected because it tried to do redundant modifications. This can happen if a transaction tries to add the same cosignatory two time.</dd>

		<dt>FAILURE_CONFLICTING_MULTISIG_MODIFICATION</dt>
		<dd>The transaction was rejected because it contained conflicting modifications to a multisig account. This can for instance happen if a transaction tries to add and then delete the same cosignatory.</dd>

		<dt>FAILURE_TOO_MANY_MULTISIG_COSIGNERS</dt>
		<dd>The transaction was rejected because it contains too many cosignatories. The maximum number of cosignatories allowed for a multisig account is 32.</dd>

		<dt>FAILURE_MULTISIG_ACCOUNT_CANNOT_BE_COSIGNER</dt>
		<dd>Validation failed because a multisig modification would result in a multisig account being a cosigner.</dd>

		<dt>FAILURE_MULTISIG_MIN_COSIGNATORIES_OUT_OF_RANGE</dt>
		<dd>Validation failed because the minimum number of cosignatories is negative or larger than the number of cosignatories.</dd>
	</dl>

</div>

</body>

</html>
