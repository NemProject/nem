<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<link href="style.css" rel="stylesheet" type="text/css">
</link></meta></head>
<body>
<div class="document">
<p class="NemTitle" style="margin-bottom:88.0pt;"><img src="image002.jpg"/></p>
<p class="NemTitleText">NEM NIS API Documentation</p>
<p class="NemSubtitle">Version 1.17</p>
<p class="NemSubtitle"><time datetime="2015-08-13 18:37:00Z">18:37, August 13, 2015</time></p>
<p style="page-break-before:always"></p>
<p class="NemTocHeading">Contents</p>
<div id="toc"><ol>
<li><a href="#introduction">Introduction</a>
<ol>
<li><a href="#general-information">General Information</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#requests">Requests</a></li>
</ol>
</li>
<li><a href="#NIS-status-related-requests">NIS status related requests</a>
<ol>
<li><a href="#heart-beat-request">Heart beat request</a></li>
<li><a href="#status-request">Status Request</a></li>
</ol>
</li>
<li><a href="#account-related-requests">Account related requests</a>
<ol>
<li><a href="#retrieving-account-data">Retrieving account data</a>
<ol>
<li><a href="#generating-new-account-data">Generating new account data</a></li>
<li><a href="#requesting-the-account-data">Requesting the account data</a></li>
<li><a href="#requesting-the-original-account-data-for-a-delegate-account">Requesting the original account data for a delegate account</a></li>
<li><a href="#requesting-the-account-status">Requesting the account status</a></li>
<li><a href="#requesting-transaction-data-for-an-account">Requesting transaction data for an account</a></li>
<li><a href="#transaction-data-with-decoded-messages">Transaction data with decoded messages</a></li>
<li><a href="#requesting-harvest-info-data-for-an-account">Requesting harvest info data for an account</a></li>
<li><a href="#retrieving-account-importances-for-accounts">Retrieving account importances for accounts</a></li>
<li><a href="#retrieving-namespaces-that-an-account-owns">Retrieving namespaces that an account owns</a></li>
<li><a href="#retrieving-mosaic-definitions-that-an-account-has-created">Retrieving mosaic definitions that an account has created</a></li>
<li><a href="#retrieving-mosaics-that-an-account-owns">Retrieving mosaics that an account owns</a></li>
<li><a href="#locking-and-unlocking-accounts">Locking and unlocking accounts</a></li>
<li><a href="#retrieving-the-unlock-info">Retrieving the unlock info</a></li>
</ol>
</li>
<li><a href="#retrieving-historical-account-data">Retrieving historical account data</a></li>
</ol>
</li>
<li><a href="#block-chain-related-requests">Block chain related requests</a>
<ol>
<li><a href="#requesting-the-block-chain-status-information">Requesting the block chain status information</a>
<ol>
<li><a href="#block-chain-height">Block chain height</a></li>
<li><a href="#block-chain-score">Block chain score</a></li>
<li><a href="#last-block-of-the-block-chain-score">Last block of the block chain score</a></li>
</ol>
</li>
<li><a href="#requesting-parts-of-the-block-chain">Requesting parts of the block chain</a>
<ol>
<li><a href="#getting-a-block-with-a-given-hash">Getting a block with a given hash</a></li>
<li><a href="#getting-a-block-with-a-given-height">Getting a block with a given height</a></li>
<li><a href="#getting-part-of-a-chain">Getting part of a chain</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#node-related-requests">Node related requests</a>
<ol>
<li><a href="#requesting-information-about-a-node">Requesting information about a node</a>
<ol>
<li><a href="#basic-node-information">Basic node information</a></li>
<li><a href="#extended-node-information">Extended node information</a></li>
</ol>
</li>
<li><a href="#request-for-discovering-the-neighborhood-of-a-node">Request for discovering the neighborhood of a node</a>
<ol>
<li><a href="#complete-neighborhood">Complete neighborhood</a></li>
<li><a href="#reachable-neighborhood">Reachable neighborhood</a></li>
<li><a href="#active-neighborhood">Active neighborhood</a></li>
<li><a href="#maximum-chain-height-in-the-active-neighborhood">Maximum chain height in the active neighborhood</a></li>
</ol>
</li>
<li><a href="#requesting-node-experiences">Requesting node experiences</a></li>
<li><a href="#booting-the-local-node">Booting the local node</a></li>
</ol>
</li>
<li><a href="#namespaces-and-mosaics">Namespaces and Mosaics</a>
<ol>
<li><a href="#namespaces">Namespaces</a>
<ol>
<li><a href="#retrieving-root-namespaces">Retrieving root namespaces</a></li>
<li><a href="#retrieving-a-specific-namespace">Retrieving a specific namespace</a></li>
</ol>
</li>
<li><a href="#mosaics">Mosaics</a>
<ol>
<li><a href="#retrieving-mosaic-definitions">Retrieving mosaic definitions</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#initiating-transactions">Initiating transactions</a>
<ol>
<li><a href="#initiating-a-transaction">Initiating a transaction</a></li>
<li><a href="#initiating-a-transfer-transaction">Initiating a transfer transaction</a>
<ol>
<li><a href="#version-1-transfer-transactions">Version 1 transfer transactions</a></li>
<li><a href="#version-2-transfer-transactions">Version 2 transfer transactions</a></li>
</ol>
</li>
<li><a href="#converting-an-account-to-a-multisig-account">Converting an account to a multisig account</a></li>
<li><a href="#initiating-a-multisig-transaction">Initiating a multisig transaction</a>
<ol>
<li><a href="#cosigning-multisig-transaction">Cosigning multisig transaction</a></li>
</ol>
</li>
<li><a href="#adding-and-removing-cosignatories">Adding and removing cosignatories</a></li>
<li><a href="#how-to-use-a-multisig-account">How to use a multisig account</a></li>
<li><a href="#provisioning-a-namespace">Provisioning a namespace</a></li>
<li><a href="#creating-mosaics">Creating mosaics</a>
<ol>
<li><a href="#creating-a-mosaic-definition">Creating a mosaic definition</a></li>
<li><a href="#altering-a-mosaic-definition">Altering a mosaic definition</a></li>
<li><a href="#changing-the-mosaic-supply">Changing the mosaic supply</a></li>
</ol>
</li>
<li><a href="#creating-a-signed-transaction">Creating a signed transaction</a>
<ol>
<li><a href="#gathering-data-for-the-signature">Gathering data for the signature</a></li>
<li><a href="#sending-the-data-to-NIS">Sending the data to NIS</a></li>
</ol>
</li>
<li><a href="#transaction-fees">Transaction fees</a></li>
</ol>
</li>
<li><a href="#requests-for-additional-information-from-NIS">Requests for additional information from NIS</a>
<ol>
<li><a href="#monitoring-the-network-time">Monitoring the network time</a></li>
<li><a href="#monitoring-incoming-and-outgoing-calls">Monitoring incoming and outgoing calls</a></li>
<li><a href="#monitoring-timers">Monitoring timers</a></li>
</ol>
</li>
<li><a href="#appendix-A:-description-of-the-JSON-structures">Appendix A: Description of the JSON Structures</a>
<ol>
<li><a href="#accountHistoricalDataViewModel">AccountHistoricalDataViewModel</a></li>
<li><a href="#accountImportanceViewModel">AccountImportanceViewModel</a></li>
<li><a href="#accountInfo">AccountInfo</a></li>
<li><a href="#accountMetaData">AccountMetaData</a></li>
<li><a href="#accountMetaDataPair">AccountMetaDataPair</a></li>
<li><a href="#accountPrivateKeyTransactionsPage">AccountPrivateKeyTransactionsPage</a></li>
<li><a href="#applicationMetaData">ApplicationMetaData</a></li>
<li><a href="#auditCollection">AuditCollection</a></li>
<li><a href="#block">Block</a></li>
<li><a href="#blockChainScore">BlockChainScore</a></li>
<li><a href="#blockHeight">BlockHeight</a></li>
<li><a href="#bootNodeRequest">BootNodeRequest</a></li>
<li><a href="#communicationTimeStamps">CommunicationTimeStamps</a></li>
<li><a href="#explorerBlockViewModel">ExplorerBlockViewModel</a></li>
<li><a href="#explorerTransferViewModel">ExplorerTransferViewModel</a></li>
<li><a href="#extendedNodeExperiencePair">ExtendedNodeExperiencePair</a></li>
<li><a href="#harvestInfo">HarvestInfo</a></li>
<li><a href="#keyPairViewModel">KeyPairViewModel</a></li>
<li><a href="#transaction-objects">Transaction objects</a>
<ol>
<li><a href="#importanceTransferTransaction">ImportanceTransferTransaction</a></li>
<li><a href="#mosaicDefinitionCreationTransaction">MosaicDefinitionCreationTransaction</a></li>
<li><a href="#mosaicSupplyChangeTransaction">MosaicSupplyChangeTransaction</a></li>
<li><a href="#multisigAggregateModificationTransaction">MultisigAggregateModificationTransaction</a></li>
<li><a href="#multisigCosignatoryModification">MultisigCosignatoryModification</a></li>
<li><a href="#multisigSignatureTransaction">MultisigSignatureTransaction</a></li>
<li><a href="#multisigTransaction">MultisigTransaction</a></li>
<li><a href="#provisionNamespaceTransaction">ProvisionNamespaceTransaction</a></li>
<li><a href="#transferTransaction">TransferTransaction</a></li>
</ol>
</li>
<li><a href="#mosaic">Mosaic</a></li>
<li><a href="#mosaicDefinition">MosaicDefinition</a></li>
<li><a href="#mosaicDefinitionMetaDataPair">MosaicDefinitionMetaDataPair</a></li>
<li><a href="#mosaicProperties">MosaicProperties</a></li>
<li><a href="#mosaicLevy">MosaicLevy</a></li>
<li><a href="#mosaicId">MosaicId</a></li>
<li><a href="#namespace">Namespace</a></li>
<li><a href="#namespaceMetaDataPair">NamespaceMetaDataPair</a></li>
<li><a href="#nemAnnounceResult">NemAnnounceResult</a></li>
<li><a href="#nemAsyncTimerVisitor">NemAsyncTimerVisitor</a></li>
<li><a href="#nemRequestResult">NemRequestResult</a></li>
<li><a href="#nisNodeInfo">NisNodeInfo</a></li>
<li><a href="#node">Node</a></li>
<li><a href="#nodeCollection">NodeCollection</a></li>
<li><a href="#privateKey">PrivateKey</a></li>
<li><a href="#requestAnnounce">RequestAnnounce</a></li>
<li><a href="#requestPrepareAnnounce">RequestPrepareAnnounce</a></li>
<li><a href="#timeSynchronizationResult">TimeSynchronizationResult</a></li>
<li><a href="#transactionMetaData">TransactionMetaData</a></li>
<li><a href="#transactionMetaDataPair">TransactionMetaDataPair</a></li>
<li><a href="#unconfirmedTransactionMetaData">UnconfirmedTransactionMetaData</a></li>
<li><a href="#unconfirmedTransactionMetaDataPair">UnconfirmedTransactionMetaDataPair</a></li>
<li><a href="#error-object">Error object</a></li>
</ol>
</li>
<li><a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a>
<ol>
<li><a href="#error-messages">Error messages</a></li>
</ol>
</li>
</ol>
</div>
<hr/>
<div>
<h4>Changes since 1.16</h4>
<ul>
<li>Added JSON structures for <a href="#mosaic">Mosaic</a>, <a href="#mosaicDefinition">MosaicDefinition</a>,
                <a href="#mosaicDefinitionMetaDataPair">MosaicDefinitionMetaDataPair</a>, <a href="#mosaicProperties">MosaicProperties</a>,
                <a href="#mosaicLevy">MosaicLevy</a>, <a href="#mosaicId">MosaicId</a>, <a href="#namespace">Namespace</a> and
                <a href="#namespaceMetaDataPair">NamespaceMetaDataPair</a>.</li>
<li>Added or updated JSON structures for <a href="#mosaicDefinitionCreationTransaction">MosaicDefinitionCreationTransaction</a>,
                <a href="#mosaicSupplyChangeTransaction">MosaicSupplyChangeTransaction</a>, <a href="#provisionNamespaceTransaction">ProvisionNamespaceTransaction</a> and
                <a href="#transferTransaction">TransferTransaction</a></li>
<li>Added chapters <a href="#namespaces">Namespaces</a> and <a href="#mosaics">Mosiacs</a> to introduce the concept of NEM namespaces and mosaics.</li>
<li>Added chapters <a href="#provisioning-a-namespace">Provisioning a namespace</a> and <a href="#creating-mosaics">Creating mosaics</a>.</li>
<li>Updated chapter <a href="#initiating-a-transfer-transaction">Initiating a transfer transaction</a>.</li>
<li>Added chapters <a href="#retrieving-namespaces-that-a-account-owns">Retrieving namespaces that an account owns</a>,
                <a href="#retrieving-mosaic-definitions-that-an-account-has-created">Retrieving mosaic definitions that an account has created</a> and
                <a href="#retrieving-mosaics-that-an-account-owns">Retrieving mosaics that an account owns</a></li>
<li>Added chapters <a href="#retrieving-root-namespaces">Retrieving root namespaces</a>,
                <a href="#retrieving-a-specific-namespace">Retrieving a specific namespace</a> and
                <a href="#retrieving-mosaic-definitions">Retrieving mosaic definitions</a></li>
</ul>
<h4>Changes since 1.15</h4>
<ul>
<li>updated chapter 6.8 to reflect correct fee calculation for aggregate modification transactions.</li>
</ul>
<h4>Changes since 1.14</h4>
<ul>
<li>updated chapter 6.3, 6.5 and appendix A 8.19.2 to reflect that aggregate modification transactions need to have version 2.</li>
</ul>
<h4>Changes since 1.13</h4>
<ul>
<li>added chapter 3.1.10 <a href="#retrieving-the-unlock-info"> Retrieving the unlock info</a></li>
</ul>
<h4>Changes since 1.12</h4>
<ul>
<li>updated chapter 6.3 - 6.5 to reflect the m of n multisig account changes</li>
<li>updated chapter 6.7.1 to reflect the m of n multisig account changes</li>
<li>updated structure <a href="#multisigAggregateModificationTransaction">MultisigAggregateModificationTransaction</a> </li>
<li>replaced table tag with fields tag</li>
<li>updated structures that have changed</li>
<li>added missing error messages</li>
</ul>
<h4>Changes since 1.11</h4>
<ul>
<li>updated chapter 3.1.2 <a href="#requesting-the-account-data"> Requesting the account data</a></li>
<li>added chapter 3.1.3 <a href="#requesting-the-original-account-data-for-a-delegate-account"> Requesting the original account data for a delegate account</a></li>
<li>updated structure <a href="#accountInfo">AccountInfo</a></li>
</ul>
<h4>Changes since 1.10</h4>
<ul>
<li>added chapter 3.2 <a href="#retrieving-historical-account-data"> Retrieving historical account data</a></li>
<li>added structure <a href="#accountHistoricalDataViewModel">AccountHistoricalDataViewModel</a></li>
</ul>
<h4>Changes since 1.9</h4>
<ul>
<li>corrected the fee formula for aggregate modification transactions in the fee table</li>
</ul>
<h4>Changes since 1.8</h4>
<ul>
<li>updated document to reflect the possible versions (main and test network) of the block and transactions structures</li>
<li>updated structure <a href="#node">Node</a></li>
</ul>
<h4>Changes since 1.7</h4>
<ul>
<li>added chapter 6.7 <a href="#creating-a-signed-transaction"> Creating a signed transaction</a> and added structure <a href="#requestAnnounce">RequestAnnounce</a></li>
<li>updated structures <a href="#transactionMetaData">TransactionMetaData</a>, <a href="#nemAnnounceResult">NemAnnounceResult</a></li>
</ul>
<h4>Changes since 1.6</h4>
<ul>
<li>added table with <a href="#transaction-fees">transaction fees</a></li>
<li>fixed description of <a href="#requestPrepareAnnounce">RequestPrepareAnnounce</a></li>
</ul>
<h4>Changes since 1.5</h4>
<ul>
<li>added <a href="#generating-new-account-data">Generating new account data</a></li>
<li>updated <a href="#requesting-the-account-data">Requesting the account data</a></li>
<li>updated structures <a href="#keyPairViewModel">KeyPairViewModel</a>, <a href="#accountMetaData">AccountMetaData</a></li>
</ul>
</div>
<hr/>
<h1 id="introduction">Introduction</h1>
<h2 id="general-information">General Information</h2>
<p>The NEM Infrastructure Server (short: NIS) was written in Java. It needs Java 8 to run. It can run with at least 512MB memory for the java virtual machine but we recommend at least 1GB.</p>
<h2 id="installation">Installation</h2>
<p>NIS can be installed either via installer using the URL <a href="http://bob.nem.ninja/installer/">NEM Infrastructure Server</a> or as stand-alone package which is hosted on <a href="http://bob.nem.ninja/">http://bob.nem.ninja/</a>. The installer only supports 64 bit versions of Java. The current stand-alone version as of this writing is <a href="http://bob.nem.ninja/nis-ncc-0.5.13.tgz">nis-ncc-0.5.13.tgz</a>. When using the installer both installation and the start-up of the software is automatic. The stand-alone version needs to be unzipped to a directory of your choice. It is then started by running runNis.bat (windows) or nix.runNis.sh (linux) from the command prompt.</p>
<h2 id="requests">Requests</h2>
<p>NIS uses port 7890 to communicate with its clients. It accepts both HTTP GET and POST requests.</p>
<p>Assuming that the NIS is running locally, HTTP GET requests can be executed from a browser and have the form:</p>
<p><a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a>&lt;path to API request&gt;?&lt;parameters&gt; for example:</p>
<p><a href="http://127.0.0.1:7890/account/get?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS">http://127.0.0.1:7890/account/get?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS</a></p>
<p>HTTP POST request usually cannot be executed from within the browser unless you use a plugin which is able to do it. HTTP POST requests use JSON structures in the request body to supply data to NIS.</p>
<p>Both request types return (if any data is returned) data using JSON structures. <a href="#appendix-A:-description-of-the-JSON-structures">Appendix A: Description of the JSON Structures</a> explains all JSON structures used in this document.</p>
<h1 id="NIS-status-related-requests">NIS status related requests</h1>
<p>There are two requests by which you can get information about the status of NIS. The /heartbeat request gives you information if the node is up and responsive. The /status request gives more detailed information about the state of NIS. Both requests return a NemRequestResult object. See <span><em>Appendix A:</em> <a href="#nemRequestResult">NemRequestResult</a></span> for more details on the interpretation of a NemRequestResult.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h2 id="heart-beat-request">Heart beat request</h2>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/heartbeat</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Determines if NIS is up and responsive.</p>

<h4>No Parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/heartbeat">http://127.0.0.1:7890/heartbeat</a></p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
	"code": 1,
	"type": 2,
	"message": "ok"
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">If there is no response to this request,
	NIS is either not running or is in a state where it can't serve requests.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h2 id="status-request">Status Request</h2>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/status</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Determines the status of NIS.</p>

<h4>No Parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/status">http://127.0.0.1:7890/status</a></p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{ 
	"code": 6, 
	"type": 4, 
	<b>"message": "status"</b>
}</samp></pre>
<p class="NemNoSpacing">The code can be interpreted as follows:</p>
<div class="FakeList"><p class="NemNoSpacing">0:<span class="sep"> </span> Unknown status.</p><p class="NemNoSpacing">1:<span class="sep"> </span> NIS is stopped.</p><p class="NemNoSpacing">2:<span class="sep"> </span> NIS is starting.</p><p class="NemNoSpacing">3:<span class="sep"> </span> NIS is running.</p><p class="NemNoSpacing">4:<span class="sep"> </span> NIS is booting the local node (implies NIS is running).</p><p class="NemNoSpacing">5:<span class="sep"> </span> The local node is booted (implies NIS is running).</p><p class="NemNoSpacing">6:<span class="sep"> </span> The local node is synchronized (implies NIS is running and the local node is booted).</p><p class="NemNoSpacing">7:<span class="sep"> </span> NIS local node does not see any remote NIS node (implies running and booted).</p><p class="NemNoSpacing">8:<span class="sep"> </span> NIS is currently loading the block chain from the database. In this state NIS cannot serve any requests.</p></div>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">If there is no response to this request,
	NIS is either not running or is in a state where it can't serve requests.</p>
<h1 id="account-related-requests">Account related requests</h1>
<p>This chapter will guide you through the
	process of retrieving account information from a NEM Infrastructure Server. The
	information that can be retrieved is the durable account data, its meta data
	and information about transactions and harvested blocks.</p>
<p>NIS supports two different kind of accounts: normal accounts and multsig (short for: multi signature) accounts:</p>
<h4>Normal accounts:</h4>
<p>Normal accounts are created and controlled
	by a private key. Any action for the account like sending NEM to another
	account via a transfer transaction is signed with this private key. If an
	attacker gains knowledge of the private key, he/she can rob the account. The
	private key must therefore be kept secret by all means.</p>
<h4>Multisig accounts:</h4>
<p>Multisig accounts can be created by
	converting a normal account to a multisig account via a <b>aggregate
	modification transaction</b>. This adds cosignatories to the account. After that
	modification, only the cosignatories can initiate an action for the account.
	Any action must be signed by all cosignatories. This makes a multisig account
	significantly more secure than a normal account. When a single cosignatory
	private key is gained by an attacker, the attacker still can't initiate any
	action on the account since <b>all</b> cosignatories must sign. It is strongly
	recommended to convert any account holding a significantly high amount of NEM
	into a multisig account with at least 3 cosignatories. Once converted to a
	multisig account, the original private key for the account plays no role any
	more.</p>
<p>Durable data is either stored in the
	database or can be calculated from other database data. The corresponding JSON
	object is described in <span><em>Appendix A:</em> <a href="#accountInfo">AccountInfo</a></span>. It has the fields:</p>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">address</p>
</td>
<td>
<p>Each account has a unique address. First letter of an address indicate
				the network the account belongs to. Currently two networks are defined: the
				test network whose account addresses start with a capital <b>T</b> and the main
				network whose account addresses always start with a capital <b>N</b>. Addresses have
				always a length of 40 characters and are <a href="http://en.wikipedia.org/wiki/Base32">base-32</a> encoded.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">balance</p>
</td>
<td>
<p>Each account has a balance which is an integer greater or equal to
				zero and denotes the number of <b>micro</b> NEMs which the account owns. Thus a
				balance of 123456789 means the account owns 123.456789 NEM. A balance is
				split into its vested and unvested part. Only the vested part is relevant for
				the importance calculation. For transfers from one account to another only
				the balance itself is relevant.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">importance</p>
</td>
<td>
<p>Each account is assigned an importance. The importance is a
				decimal number between 0 and 1. It denotes the probability of an account to
				harvest the next block in case the account has harvesting turned on and all
				other accounts are harvesting too. The exact formula for calculating the
				importance is not public yet. Accounts need at least 10k <b>vested</b> NEM to be
				included in the importance calculation.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">publicKey</p>
</td>
<td>
<p>The public key of an account can be used
				to verify signatures of the account. Only accounts that have already
				published a transaction have a public key assigned to the account. Otherwise
				the field is null.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">label</p>
</td>
<td>
<p>This field is not used yet and is always null.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">harvestedBlocks</p>
</td>
<td>
<p>Harvesting is the process of generating new blocks. The field
				denotes the number of blocks that the account harvested so far. For a new
				account the number is 0.</p>
</td>
</tr>
</table>
<p>The meta data for an account describes the
	harvesting status of an account, and in case that the account is a cosignatory
	of at least one multisig account, the list of those multisig accounts. An
	account can either harvest with its current importance or delegate the
	harvesting to a so called remote account. In the latter case the remote account
	uses the importance of the original account to harvest. The corresponding JSON
	object and the possible values for the status/remoteStatus are described in
	<span><em>Appendix A:</em> <a href="#accountMetaDataPair">AccountMetaDataPair</a></span>. The meta
	data consists of the following fields:</p>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">status</p>
</td>
<td>
<p>This field describes the harvesting status of an account.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">remoteStatus</p>
</td>
<td>
<p>The field describes the status of remote harvesting.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">cosignatoryOf</p>
</td>
<td>
<p>Array of AccountInfo structures that describe the multisig
				accounts that this account is cosignatory of.</p>
</td>
</tr>
</table>
<p>Known accounts have at least one incoming
	transaction. The corresponding JSON objects are described in <span><em>Appendix A:</em> <a href="#transaction">Transaction</a></span>, <a href="#transactionMetaData">TransactionMetaData</a> and <a href="#transactionMetaDataPair">TransactionMetaDataPair</a>.</p>
<p>A transaction has always the following fields:</p>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">timeStamp</p>
</td>
<td>
<p>The number of seconds elapsed since the creation of the nemesis
				block. Future timestamps are not allowed. Transaction validation detects
				future timestamps and returns an error in that case. Network time
				synchronization ensures that any NEM software component will use valid timestamps
				when creating transactions.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">signature</p>
</td>
<td>
<p>The transaction signature. The transaction signature is validated
				using the supplied public key in the field signer. If the signature is not
				valid, an error is returned from validation.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">fee</p>
</td>
<td>
<p>The fee for the transaction. The higher the fee, the higher is the
				priority of the transaction. Transactions with high priority get included in
				a block before transactions with lower priority. If the sender does not have
				enough funds the validation will result in an error</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">type</p>
</td>
<td>
<p>The transaction type. Currently the following types of
				transactions are supported:</p>
<div class="FakeList"><p class="NemNoSpacing">0x101:<span class="sep"> </span> Transfer of NEM from sender to recipient.</p><p class="NemNoSpacing">0x801:<span class="sep"> </span> Transfer of importance from sender to remote account.</p><p class="NemNoSpacing">0x1001:<span class="sep"> </span> An aggregate modification transaction, which converts a normal account into a multisig account.</p><p class="NemNoSpacing">0x1002:<span class="sep"> </span> A multisig signature transaction which is used to sign a multisig transaction.</p><p class="NemNoSpacing">0x1003:<span class="sep"> </span> A multisig transaction, which is used for multisig accounts.</p></div>
</td>
</tr>
<tr>
<td>
<p class="JSON">deadline</p>
</td>
<td>
<p>The deadline of the transaction. The deadline is given as the
				number of seconds elapsed since the creation of the nemesis block. If a
				transaction does not get included in a block before the deadline is reached,
				it is deleted.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">version</p>
</td>
<td>
<p>The version of the structure. The following version are currently support.</p>
<li>0x68 &lt;&lt; 24 + 1 (1744830465 as 4 byte integer): the main network version</li>
<li>0x98 &lt;&lt; 24 + 1 (-1744830463 as 4 byte integer): the test network version</li>
</td>
</tr>
<tr>
<td>
<p class="JSON">signer</p>
</td>
<td>
<p>The public key of the account that created the transaction. The
				public key is encoded as hexadecimal string.</p>
</td>
</tr>
</table>
<p>Depending on the type of the transaction, there are additional fields which are specific to given type.
        For instance a transfer transaction will have the additional fields.</p>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">recipient</p>
</td>
<td>
<p>The address of the recipient. If the address is not valid an error
				is returned from validation.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">message</p>
</td>
<td>
<p>Optionally a transfer transaction can contain a message.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">payload</p>
</td>
<td>
<p>Optional field in case the transaction contains a message. The
				payload is the actual (possibly encrypted) message data. The payload is
				allowed to have a maximal size of 512 bytes. Transaction validation detects
				if the limit is exceeded and returns an error in this case.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">type</p>
</td>
<td>
<p>Optional field in case the transaction contains a message. The
				field holds the message type information. Possible message types are:</p>
<div class="FakeList"><p class="NemNoSpacing">1:<span class="sep"> </span> The message is not encrypted.</p><p class="NemNoSpacing">2:<span class="sep"> </span> The message is encrypted.</p></div>
</td>
</tr>
</table>
<p>Please refer to <a href="#appendix-A:-description-of-the-JSON-structures">Appendix A</a> for detailed information on the various transactions types and
	their additional fields.</p>
<p>Transaction meta data contains only following field:</p>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">height</p>
</td>
<td>
<p>The height of the block in which the transaction was included.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">id</p>
</td>
<td>
<p>The id of the transaction.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">hash</p>
</td>
<td>
<p>The hash of the transaction.</p>
</td>
</tr>
</table>
<p></p>
<p>Accounts can harvest (i.e. generate new)
	blocks if they are lucky. The account which harvests a block collects the fees
	which are included in the transactions in the block. The information which
	blocks were harvested by an account can be requested. The request returns an
	array of HarvestInfo JSON objects. For an example see <span><em>Appendix A:</em> <a href="#harvestInfo">HarvestInfo</a></span></p>
<p>A harvest info object has the following fields:</p>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">timeStamp</p>
</td>
<td>
<p>The number of seconds elapsed since the creation of the nemesis block.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">id</p>
</td>
<td>
<p>The database id for the block.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">difficulty</p>
</td>
<td>
<p>The block difficulty.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">totalFee</p>
</td>
<td>
<p>The total fee collected by harvesting the block.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">height</p>
</td>
<td>
<p>The height of the harvested block.</p>
</td>
</tr>
</table>
<p></p>
<p>It is possible to request an array with the
	importance information for all accounts. The request returns an array of
	AccountImportanceViewModel JSON objects. For an example see
	<span><em>Appendix A:</em> <a href="#accountImportanceViewModel">AccountImportanceViewModel</a></span>.</p>
<p>An account importance view model has the following fields:</p>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">address</p>
</td>
<td>
<p>The address of the account.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">importance</p>
</td>
<td>
<p>Substructure that describes the importance of the account.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">isSet</p>
</td>
<td>
<p>Indicates if the fields "score", "ev" and "height" are available.</p>
<p>isSet can have the values 0 or 1. In case isSet is 0 the following fields are not available.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">score</p>
</td>
<td>
<p>The importance of the account. The importance ranges between 0 and 1.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">ev</p>
</td>
<td>
<p>The page rank portion of the importance. The page rank ranges between 0 and 1.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">height</p>
</td>
<td>
<p>The height at which the importance calculation was performed.</p>
</td>
</tr>
</table>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h2 id="retrieving-account-data">Retrieving account data</h2>
<h3 id="generating-new-account-data">Generating new account data</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/account/generate</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Generates a <a href="#keyPairViewModel">KeyPairViewModel</a>.</p>

<h4>No Parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/account/generate">http://127.0.0.1:7890/account/generate</a></p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
    "privateKey": "0962c6505d02123c40e858ff8ef21e2b7b5466be12c4770e3bf557aae828390f",
    "address": "NCKMNCU3STBWBR7E3XD2LR7WSIXF5IVJIDBHBZQT",
    "publicKey": "c2e19751291d01140e62ece9ee3923120766c6302e1099b04014fe1009bc89d3"
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">None.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="requesting-the-account-data">Requesting the account data</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/account/get</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets an <a href="#accountMetaDataPair">AccountMetaDataPair</a> for an account.</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">address</p>
</td>
<td>
<p class="NemNoSpacing">The address of the account.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/account/get?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS">http://127.0.0.1:7890/account/get?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS</a></p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
    "account":
    {
        "address": "TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS",
        "balance": 124446551689680,
        "vestedBalance": 104443451691625,
        "importance": 0.010263666447108395,
        "publicKey": "a11a1a6c17a24252e674d151713cdf51991ad101751e4af02a20c61b59f1fe1a",
        "label": null,
        "harvestedBlocks": 645
    },
    "meta":
    {
        "cosignatoryOf": [ ],
        "cosignatories": [ ],
        "status": "LOCKED",
        "remoteStatus": "ACTIVE"
    }
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">If the address parameter is not valid, NIS returns an error. See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for details about errors.</p>
<p></p>
<p>Alternatively you can retrieve the account data by providing the public key for the account:</p>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/account/get/from-public-key</td></tr></table>
<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">publicKey</p>
</td>
<td>
<p class="NemNoSpacing">The public key of the account as hex string.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/account/get/from-public-key?publicKey=f9bd190dd0c364261f5c8a74870cc7f7374e631352293c62ecc437657e5de2cd">http://127.0.0.1:7890/account/get/from-public-key?publicKey=f9bd190dd0c364261f5c8a74870cc7f7374e631352293c62ecc437657e5de2cd</a></p>
<p>The returned JSON object has the same structure as in the first example.</p>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">If the public key parameter is not valid, NIS returns an error. See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for details about errors.</p>
<h3 id="requesting-the-original-account-data-for-a-delegate-account">Requesting the original account data for a delegate account</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/account/get/forwarded</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Given a delegate (formerly known as remote) account's address, gets the <a href="#accountMetaDataPair">AccountMetaDataPair</a>
			for the account for which the given account is the delegate account. If the given account address is not a delegate account for any account, the
		request returns the <a href="#accountMetaDataPair">AccountMetaDataPair</a> for the given address.</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">address</p>
</td>
<td>
<p class="NemNoSpacing">The address of the delegate account.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/account/get/forwarded?address=NC2ZQKEFQIL3JZEOB2OZPWXWPOR6LKYHIROCR7PK">http://127.0.0.1:7890/account/get/forwarded?address=NC2ZQKEFQIL3JZEOB2OZPWXWPOR6LKYHIROCR7PK</a></p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
	"account":
    {
        "address": "NALICE2A73DLYTP4365GNFCURAUP3XVBFO7YNYOW",
        "balance": 11793338398661,
        "vestedBalance": 10890953464862,
        "importance": 0.001264596432148395,
        "publicKey": "bdd8dd702acb3d88daf188be8d6d9c54b3a29a32561a068b25d2261b2b2b7f02",
        "label": null,
        "harvestedBlocks": 742
    },
    "meta":
    {
        "cosignatoryOf": [ ],
        "cosignatories": [ ],
        "status": "LOCKED",
        "remoteStatus": "ACTIVE"
    }
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">If the address parameter is not valid, NIS returns an error. See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for details about errors.</p>
<p></p>
<p>Alternatively you can retrieve the original account data by providing the public key of the delegate account:</p>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/account/get/forwarded/from-public-key</td></tr></table>
<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">publicKey</p>
</td>
<td>
<p class="NemNoSpacing">The public key of the account as hex string.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/account/get/forwarded/from-public-key?publicKey=bdd8dd702acb3d88daf188be8d6d9c54b3a29a32561a068b25d2261b2b2b7f02">http://127.0.0.1:7890/account/get/forwarded/from-public-key?publicKey=bdd8dd702acb3d88daf188be8d6d9c54b3a29a32561a068b25d2261b2b2b7f02</a></p>
<p>The returned JSON object has the same structure as in the first example.</p>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">If the public key parameter is not valid, NIS returns an error. See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for details about errors.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="requesting-the-account-status">Requesting the account status</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/account/status</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets the <a href="#accountMetaData">AccountMetaData</a> from an account.</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">Address</p>
</td>
<td>
<p class="NemNoSpacing">The address of the account.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/account/status?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS">http://127.0.0.1:7890/account/status?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS</a></p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
    "cosignatoryOf": [ ],
    "status": "LOCKED",
    "remoteStatus": "ACTIVE"
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">If the address parameter is not valid,
	NIS returns an error. See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for details about errors.</p>
<h3 id="requesting-transaction-data-for-an-account">Requesting transaction data for an account</h3>
<p>A transaction is said to be incoming with
	respect to an account if the account is the recipient of the transaction. In
	the same way outgoing transaction are the transactions where the account is the
	sender of the transaction. Unconfirmed transactions are those transactions that
	have not yet been included in a block. Unconfirmed transactions are <b>not</b>
	guaranteed to be included in any block.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h4>Incoming transactions</h4>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/account/transfers/incoming</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets an array of <a href="#transactionMetaDataPair">TransactionMetaDataPair</a> objects
    where the recipient has the address given as parameter to the request. A
	maximum of 25 transaction meta data pairs is returned. The returned transaction
	meta data pairs are sorted in descending order in which they were written to
	the database.</p>
<p class="NemNoSpacing"> The second parameter is optional. When it's not present, the
	request will return newest transactions according to the above criteria. When hash
	is supplied as second parameter, the request will return up to 25 transactions
	that appeared directly before the transaction that has the supplied hash sorted
	according to the above criteria.</p>
<p class="NemNoSpacing">The third parameter is optional. When an
	id is supplied as third parameter, the request will return up to 25
	transactions that appeared directly before the transaction that has the
	supplied id sorted according to the above criteria.</p>
<p class="NemNoSpacing">If less than 25 transactions fulfill the
	requirements, only those transactions are returned.</p>
<p class="NemNoSpacing"></p>

<h4>Parameters:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">address</p> </td>
<td>
<p class="NemNoSpacing">The address of the account.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">hash</p>
</td>
<td>
<p class="NemNoSpacing">The 256 bit sha3 hash of the
				transaction up to which transactions are returned.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">id </p>
</td>
<td>
<p class="NemNoSpacing">The transaction id up to which
				transactions are returned.</p>
</td>
</tr>
</table>
<h4></h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/account/transfers/incoming?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS&amp;hash=949583a20ebdfdcb58277eb42fef3e66e9e6bbfc47304d8741a82c68f7c53a2">http://127.0.0.1:7890/account/transfers/incoming?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS&amp;hash=949583a20ebdfdcb58277eb42fef3e66e9e6bbfc47304d8741a82c68f7c53a2</a></p>
<h4>Example of returned JSON object (test network):</h4>
<pre><samp class="JSON">{
       "data": [
       {
              "meta":
              {
                     "id": 71245,
                     "height": 40706,
                     "hash": {
                         "data":"15c373ad4c3fe6af47d1941379ff262f785bdcfa07c02ac3608bc10da27d5e82"
                     }
              },
              "transaction":
              {
                     "timeStamp": 9106400,
                     "amount": 1000000000,
                     "signature": "449cd76ea8bda2220b3d6ad6f8db5f81d4e68ad3d4b0c3db9a3c267355657639eabed3dbcef8e0cc22953ae2b36a22ee7dc6327484c9649cccd686a511eca105",
                     "fee": 3000000,
                     "recipient": "TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS",
                     "type": 257,
                     "deadline": 9149600,
                     "message":
                     {
                           "payload": "280000005444334b32493543524850595634425a5a5a4c335850454e4",
                           "type": 2
                     },
                     "version": -1744830463,
                     "signer": "c20a1dffe699c7a68328986273265e33fceebe074f274240ef890dd80ad55ed6"
              }
       },
       {
              "meta":
              {
                     "id": 71356,
                     "height": 40629,
                     "hash": {
                         "data":"37c34ead4c3fe6af42d994135798262f785ba2d807c02ac3608bc10da12e5f87"
                     }
              },
              "transaction":
              {
                     "timeStamp": 9101541,
                     "amount": 49997995000000,
                     "signature": "57c3c48d2ae8b24240b57d72493f498cfeb61e2ab87237dc0e08c51007d5c7f15847d0e08c0286e68a72028925db5fa809ca9d57e2cb6eebe11822176a834c0b",
                     "fee": 2005000000,
                     "recipient": "TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS",
                     "type": 257,
                     "deadline": 9144741,
                     "message":
                     {
                           "payload": "526f6262657279212121",
                           "type": 1
                     },
                     "version": -1744830463,
                     "signer": "546e4fb9c81db84e04d8e9e67380db0fe1f540df09a527fb995b589b5695ae24"
              }
       }]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">If the address parameter is not valid or
	the id cannot be found in the database, NIS returns an error. See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for details about errors.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h4>Outgoing transactions</h4>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/account/transfers/outgoing</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets an array of transaction meta data
	pairs where the recipient has the address given as parameter to the request. A
	maximum of 25 transaction meta data pairs is returned. For details about
	sorting and discussion of the second parameter see <a href="#incoming-transactions">Incoming transactions</a>.</p>

<h4>Parameters:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">address</p>
</td>
<td>
<p class="NemNoSpacing">The address of the account.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">hash</p>
</td>
<td>
<p class="NemNoSpacing">The 256 bit sha3 hash of the
				transaction up to which transactions are returned.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">id </p>
</td>
<td>
<p class="NemNoSpacing">The transaction id up to which
				transactions are returned.</p>
</td>
</tr>
</table>
<h4></h4>
<h4>Example:</h4>
<p class="NemNoSpacing"><a href="http://127.0.0.1:7890/account/transfers/outgoing?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS&amp;hash=949583a20ebdfdcb58277eb42fef3e66e9e6bbfc47304d8741a82c68f7c53a22">http://127.0.0.1:7890/account/transfers/outgoing?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS&amp;hash=949583a20ebdfdcb58277eb42fef3e66e9e6bbfc47304d8741a82c68f7c53a22</a></p>
<h4>Example of returned JSON object (test network):</h4>
<pre><samp class="JSON">{
       "data": [
       {
              "meta":
              {
                     "id": 70498,
                     "height": 40803,
                     "hash": {
                         "data":"37c34ead4c3fe6af42d994135798262f785ba2d807c02ac3608bc10da12e5f87"
                     }
              },
              "transaction":
              {
                     "timeStamp": 9111526,
                     "amount": 1000000000,
                     "signature": "651a19ccd09c1e0f8b25f6a0aac5825b0a20f158ca4e0d78f2abd904a3966b6e3599a47b9ff199a3a6e1152231116fa4639fec684a56909c22cbf6db66613901",
                     "fee": 3000000,
                     "recipient": "TDGIMREMR5NSRFUOMPI5OOHLDATCABNPC5ID2SVA",
                     "type": 257,
                     "deadline": 9154726,
                     "message":
                     {
                           "payload": "74657374207472616e73616374696f6e",
                           "type": 1
                     },
                     "version": -1744830463,
                     "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
              }
       }]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">If the address parameter is not valid or
	the id cannot be found in the database, NIS returns an error. See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for details about errors.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h4>All transactions</h4>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/account/transfers/all</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets an array of transaction meta data
	pairs for which an account is the sender or receiver. A maximum of 25
	transaction meta data pairs is returned. For details about sorting and
	discussion of the second parameter see <a href="#incoming-transactions">Incoming transactions</a>.</p>

<h4>Parameters:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">address</p>
</td>
<td>
<p class="NemNoSpacing">The address of the account.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">hash</p>
</td>
<td>
<p class="NemNoSpacing">The 256 bit sha3 hash of the
				transaction up to which transactions are returned.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">id </p>
</td>
<td>
<p class="NemNoSpacing">The transaction id up to which
				transactions are returned.</p>
</td>
</tr>
</table>
<h4></h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/account/transfers/all?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS&amp;hash=949583a20ebdfdcb58277eb42fef3e66e9e6bbfc47304d8741a82c68f7c53a22">http://127.0.0.1:7890/account/transfers/all?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS&amp;hash=949583a20ebdfdcb58277eb42fef3e66e9e6bbfc47304d8741a82c68f7c53a22</a></p>
<h4>Example of returned JSON object:</h4>
<p class="NemNoSpacing">See example for <a href="#incoming-transactions">Incoming transactions</a> or <a href="#outgoing-transactions">Outgoing transactions</a>.</p>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">If the address parameter is not valid or
	the id cannot be found in the database, NIS returns an error. See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for details about errors.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h4>Unconfirmed transactions</h4>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/account/unconfirmedTransactions</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets the array of transactions for which
	an account is the sender or receiver and which have not yet been included in a
	block. The returned structure is UnconfirmedTransactionMetaDataPair see
	<span><em>Appendix A:</em> <a href="#unconfirmedTransactionMetaDataPair">UnconfirmedTransactionMetaDataPair</a></span></p>

<h4>Parameters:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">address</p>
</td>
<td>
<p class="NemNoSpacing">The address of the account.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/account/unconfirmedTransactions?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS">http://127.0.0.1:7890/account/unconfirmedTransactions?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS</a></p>
<h4>Example of returned JSON object (test network):</h4>
<pre><samp class="JSON">{
       "meta": {
           "data": "d7c9e33421e43bf4a5d6e21304c8096c599142755d581bd6e9037f41545a5873"
       },
       "data": [
       {
              "timeStamp": 9131839,
              "amount": 1000000000,
              "signature": "0acface77696a54340a7da8592750ea0410f62717d07e4df30e09718092521262465df5c4d98d32cd9d6e8699d66e016ec8db716d20090ad99cc16f7a6d13904",
              "fee": 2000000,
              "recipient": "TDGIMREMR5NSRFUOMPI5OOHLDATCABNPC5ID2SVA",
              "type": 257,
              "deadline": 9175039,
              "message": {
                     "payload": "",
                     "type": 1
              },
              "version": -1744830463,
              "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
       }]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">If the address parameter is not valid,
	NIS returns an error. See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> Errors for details about errors.</p>
<h3 id="transaction-data-with-decoded-messages">Transaction data with decoded messages</h3>
<p>All the requests for retrieving transaction data for an account which were described in previous part
        do not decode any message contained in a transaction.
        The following requests are similar to the ones above but are able to return transaction data with decoded messages.
        Decoding requires the private key of an account for which transactions are requested.
    Therefore the following requests <b>should only be done when NIS is running locally</b>.</p>
<h4>Incoming/outgoing/all transactions with decoded messages</h4>
<table class="NemApiGrid"><tr><td>API path:</td><td class="post" rowspan="2">Request type: <b>POST</b></td></tr><tr><td class="path">/local/account/transfers/incoming</td></tr></table>
<table class="NemApiGrid"><tr><td>API path:</td><td class="post" rowspan="2">Request type: <b>POST</b></td></tr><tr><td class="path">/local/account/transfers/outgoing</td></tr></table>
<table class="NemApiGrid"><tr><td>API path:</td><td class="post" rowspan="2">Request type: <b>POST</b></td></tr><tr><td class="path">/local/account/transfers/all</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">The request returns incoming/outgoing/all transactions as described in the previous chapter.
        The only difference is that if a transaction contains an encoded message, this message will be decoded before it is
        sent to the requester.</p>

<h4>Parameters:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">page</p>
</td>
<td>
<p class="NemNoSpacing">An AccountPrivateKeyTransactionsPage
                    JSON object as described in <span><em>Appendix A:</em> <a href="#accountPrivateKeyTransactionsPage">AccountPrivateKeyTransactionsPage</a></span></p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p>Request cannot be performed in a browser.</p>
<h4>Example of returned JSON object:</h4>
<p>See section: <a href="#requesting-transaction-data-for-an-account">Requesting transaction data for an account</a></p>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">If the private key is not supplied, NIS returns an error.
        See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for details about errors.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="requesting-harvest-info-data-for-an-account">Requesting harvest info data for an account</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/account/harvests</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets an array of harvest info objects
	for an account.</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">address</p>
</td>
<td>
<p class="NemNoSpacing">The address of the account.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">hash </p>
</td>
<td>
<p class="NemNoSpacing">The 256 bit sha3 hash of the block up to which harvested blocks are returned.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/account/harvests?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS&amp;hash=81d52a7df4abba8bb1613bcc42b6b93cf3114524939035d88ae8e864cd2c34c8">http://127.0.0.1:7890/account/harvests?address=TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS&amp;hash=81d52a7df4abba8bb1613bcc42b6b93cf3114524939035d88ae8e864cd2c34c8</a></p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
       "data": [{
              "timeStamp": 8879051,
              "blockHash": {
                     "data": "be3bb308ce33625f0dab64fd31b9ebe1c50dd4b94b43b03c228f481ab82458c3"
              },
              "totalFee": 102585065,
              "height": 37015
       }]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">If the address parameter is not valid or
	the hash cannot be found in the database, NIS returns an error. See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> Errors for details about errors.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="retrieving-account-importances-for-accounts">Retrieving account importances for accounts</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/account/importances</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets an array of account importance view model objects.</p>

<h4>No parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/account/importances">http://127.0.0.1:7890/account/importances</a></p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
       "data": [{
              "address": "TCYGT6GHZPNASMAXV7YCFCU5R5XTJKNNT66R4A4T",
              "importance": {
                     "isSet": 0
              }
       },
       {
              "address": "TD2JJJVPKDZFXWK3N3ZJLN7A5TGNOTM3J5EVSTIG",
              "importance": {
                     "score": 0.001222376902598832,
                     "ev": 0.004252356221747241,
                     "isSet": 1,
                     "height": 40926
              }
       }]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">None.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="retrieving-namespaces-that-an-account-owns">Retrieving namespaces that an account owns</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/account/namespaces</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets an array of namespace objects for a given account address. The parent parameter is optional.
            If supplied, only sub-namespaces of the parent namespace are returned.</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">address</p>
</td>
<td>
<p class="NemNoSpacing">The address of the account.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">parent </p>
</td>
<td>
<p class="NemNoSpacing">The optional parent namespace id.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/account/namespaces?address=TD3RXTHBLK6J3UD2BH2PXSOFLPWZOTR34WCG4HXH&amp;parent=makoto.metal">http://127.0.0.1:7890/account/namespaces?address=TD3RXTHBLK6J3UD2BH2PXSOFLPWZOTR34WCG4HXH&amp;parent=makoto.metal</a></p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
        "data": [{
        "fqn": "makoto.metal.coins",
        "owner": TD3RXTHBLK6J3UD2BH2PXSOFLPWZOTR34WCG4HXH",
        "height": 13465
        }]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">NIS returns an error if the address or the parent (if supplied) is invalid.
        See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for details about errors.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="retrieving-mosaic-definitions-that-an-account-has-created">Retrieving mosaic definitions that an account has created</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/account/mosaicDefinitions</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets an array of mosaic definition objects for a given account address. The parent parameter is optional.
            If supplied, only mosaic definitions for the given parent namespace are returned. The id parameter is optional and allows
            retrieving mosaic definitions in batches of 25 mosaic definitions. For more information how to use the id see
            <a href="#incoming-transactions">Incoming transactions</a>.
        </p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">address</p>
</td>
<td>
<p class="NemNoSpacing">The address of the account.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">parent</p>
</td>
<td>
<p class="NemNoSpacing">The optional parent namespace id.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">id</p>
</td>
<td>
<p class="NemNoSpacing">The optional mosaic definition database id up to which mosaic definitions are returned.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/account/mosaicDefinitions?address=TD3RXTHBLK6J3UD2BH2PXSOFLPWZOTR34WCG4HXH&amp;parent=makoto.metal.coins">http://127.0.0.1:7890/account/mosaicDefinitions?address=TD3RXTHBLK6J3UD2BH2PXSOFLPWZOTR34WCG4HXH&amp;parent=makoto.metal.coins</a></p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
        "data": [{
            "creator": "10cfe522fe23c015b8ab24ef6a0c32c5de78eb55b2152ed07b6a092121187100",
            "id": {
                "namespaceId": "makoto.metal.coins",
                "name": "silver coin"
            },
            "description": "Real silver coins, pure silver",
            "properties": [{
                "name": "divisibility",
                "value": "0"
            },{
                "name": "initialSupply",
                "value": "1000"
            },{
                "name": "supplyMutable",
                "value": "false"
            },{
                "name": "transferable",
                "value": "true"
            }]
        }]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">NIS returns an error if the address, the parent (if supplied) or the id (if supplied) is invalid.
        See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for details about errors.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="retrieving-mosaics-that-an-account-owns">Retrieving mosaics that an account owns</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/account/owned-mosaics/get</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets an array of mosaic objects for a given account address.</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">address</p>
</td>
<td>
<p class="NemNoSpacing">The address of the account.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/account/owned-mosaics/get?address=TD3RXTHBLK6J3UD2BH2PXSOFLPWZOTR34WCG4HXH">http://127.0.0.1:7890/account/owned-mosaics/get?address=TD3RXTHBLK6J3UD2BH2PXSOFLPWZOTR34WCG4HXH</a></p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
        "data": [{
            "mosaicId": {
                "namespaceId": "alice.drinks",
                "name": "orange juice"
            },
            "quantity": 123
        },{
            "mosaicId": {
                "namespaceId": "makoto.metal.coins",
                "name": "silver coin"
            },
            "quantity": 8
        }]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">NIS returns an error if the address is invalid.
        See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for details about errors.</p>
<h3 id="locking-and-unlocking-accounts">Locking and unlocking accounts</h3>
<p>Accounts that have at least 10000 vested
	NEM balance are allowed to harvest blocks. To do that the account must be
	unlocked. After start-up of NIS all accounts are locked by default.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h4>Unlocking the account (enables harvesting)</h4>
<table class="NemApiGrid"><tr><td>API path:</td><td class="post" rowspan="2">Request type: <b>POST</b></td></tr><tr><td class="path">/account/unlock</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Unlocks an account (starts harvesting).</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON"><b><span style="color:#C00000">privateKey</span></b></p>
</td>
<td>
<p class="NemNoSpacing">A PrivateKey JSON object as described in <span><em>Appendix A:</em> <a href="#privateKey">PrivateKey</a></span></p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p class="NemNoSpacing">Request cannot be performed in a browser.</p>
<h4>No return value</h4>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h4>Locking the account (stops harvesting)</h4>
<table class="NemApiGrid"><tr><td>API path:</td><td class="post" rowspan="2">Request type: <b>POST</b></td></tr><tr><td class="path">/account/lock</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Locks an account (stops harvesting).</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON"><b><span style="color:#C00000">privateKey</span></b></p>
</td>
<td>
<p class="NemNoSpacing">A PrivateKey JSON object as described in <span><em>Appendix A:</em> <a href="#privateKey">PrivateKey</a></span></p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p class="NemNoSpacing">Request cannot be performed in a browser.</p>
<h4>No return value</h4>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">Both requests return an error if the
	private key does not correspond to a known account or the account is not
	allowed to harvest. See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for details about errors.</p>
<h3 id="retrieving-the-unlock-info">Retrieving the unlock info</h3>
<p>Each node can allow users to harvest with their delegated key on that node.
		The NIS configuration has entries for configuring the maximum number of allowed harvesters
		and optionally allow harvesting only for certain account addresses. The unlock info gives
		information about the maximum number of allowed harvesters and how many harvesters are already
		using the node.
	</p>
<table class="NemApiGrid"><tr><td>API path:</td><td class="post" rowspan="2">Request type: <b>POST</b></td></tr><tr><td class="path">/account/unlocked/info</td></tr></table>
<h4>No parameter:</h4>
<h4>Example:</h4>
<p class="NemNoSpacing">Request cannot be performed in a browser.</p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
    "num-unlocked" : 2,
    "max-unlocked" : 3
}</samp></pre>
<h4>Possible Errors:</h4>
<p>None</p>
<h2 id="retrieving-historical-account-data">Retrieving historical account data</h2>
<p>The configuration for NIS offers the possibility for a node to expose additional features
    that other nodes don't want to offer. One of those features is the supply of historical account
    data like balance and importance information. To turn on this feature for your NIS, you need to add
    HISTORICAL_ACCOUNT_DATA to the list of optional features in the file config.properties.</p>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/account/historical/get</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets historical information for an account.</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">address</p>
</td>
<td>
<p class="NemNoSpacing">The address of the account.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">startHeight</p>
</td>
<td>
<p class="NemNoSpacing">The block height from which on the data should be supplied.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">endHeight</p>
</td>
<td>
<p class="NemNoSpacing">The block height up to which the data should be supplied.
                The end height must be greater than or equal to the start height.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">increment</p>
</td>
<td>
<p class="NemNoSpacing">The value by which the height is incremented between each data point.
                The value must be greater than 0. NIS can supply up to 1000 data points with one request.
                Requesting more than 1000 data points results in an error.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p><a href="http://bigalice3.nem.ninja:7890/account/historical/get?address=NALICELGU3IVY4DPJKHYLSSVYFFWYS5QPLYEZDJJ&amp;startHeight=17592&amp;endHeight=17592&amp;increment=1">
        http://bigalice3.nem.ninja:7890/account/historical/get?address=NALICELGU3IVY4DPJKHYLSSVYFFWYS5QPLYEZDJJ&amp;startHeight=17592&amp;endHeight=17592&amp;increment=1</a></p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
    [
        {
          "height": 17592,
          "address": "NALICELGU3IVY4DPJKHYLSSVYFFWYS5QPLYEZDJJ",
          "balance": 509676000000,
          "vestedBalance": 100999147150,
          "unvestedBalance": 408676852850,
          "importance": 0.00008857563463531297,
          "pageRank": 0.0007605047835049349
        }
    ]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">If the address is invalid, the start height is larger than the endheight, the increment
        is not a positive or the request results in more than 1000 data points an error is returned.</p>
<h1 id="block-chain-related-requests">Block chain related requests</h1>
<p>NEM builds a block chain which contains every
	bit of information needed. Subsequent blocks in the block chain have increasing
	heights that differ by one. Each block can contain transactions. Transactions
	build the basis of all account activity. It is therefore important to
	understand the concept and the structures of blocks and transactions.</p>
<p>Blocks are generated by accounts. If an
	account generates a block and the block gets included in the block chain, the
	generating account, called the harvester, gets all the transaction fees for
	transactions that are included in the block. A harvester will therefore usually
	include as many transactions as possible.</p>
<p>Transactions reflect all account
	activities. In order for a client to have an up to date balance for every
	account it is crucial to know about every transaction that occurred and
	therefore the client must have knowledge about every single block in the chain
	(one says: the client must be synchronized with the block chain).</p>
<p>Whenever timestamps are used, the time
	reflects the network time. NEM has a time synchronization mechanism which lets
	all node agree on how many seconds since the nemesis have elapsed. This common
	time is called network time.</p>
<p>The following chapters will first introduce
	the fields used in the block and transaction structure and then explain how a
	client can request parts of the block chain.</p>
<p>Blocks are transferred using a JSON Block
	object. <span><em>Appendix A:</em> <a href="#block">Block</a></span> has more information and an example JSON Block object. The
	following fields are in the structure:</p>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">timeStamp</p>
</td>
<td>
<p>The network time when the block was created.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">signature</p>
</td>
<td>
<p>The signature of the block. All blocks in the chain are signed by
				the harvesters.</p>
<p>This way any node can check if the block has been altered by some
				evil entity.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">prevBlockHash</p>
</td>
<td>
<p>The sha3-256 hash of the previous block as hexadecimal string.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">type</p>
</td>
<td>
<p>The block type. There are currently two block types used:</p>
<div class="FakeList"><p class="NemNoSpacing">-1:<span class="sep"> </span> Nemesis block type. This block type appears only once in the chain.</p><p class="NemNoSpacing">1:<span class="sep"> </span> Regular block type. All blocks with height &gt; 1 have this type.</p></div>
</td>
</tr>
<tr>
<td>
<p class="JSON">transactions</p>
</td>
<td>
<p>The array of transactions. See <span><em>Appendix A:</em> <a href="#transaction">Transaction</a></span>
				for more details. A block can contain up to 120 transactions.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">version</p>
</td>
<td>
<p>The block version. The following versions are supported:</p>
<li>0x68 &lt;&lt; 24 + 1 (1744830465 as 4 byte integer): the main network version</li>
<li>0x98 &lt;&lt; 24 + 1 (-1744830463 as 4 byte integer): the test network version</li>
</td>
</tr>
<tr>
<td>
<p class="JSON">signer</p>
</td>
<td>
<p>The public key of the harvester of the block as hexadecimal
				string.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">height</p>
</td>
<td>
<p>The height of the block. Each block has a unique height.
				Subsequent blocks differ in height by 1.</p>
</td>
</tr>
</table>
<p>Transactions were already discussed in
	chapter 2 <a href="#account-related-requests">Account related requests</a>. See also <span><em>Appendix A:</em> <a href="#transaction">Transaction</a></span>
	for an example JSON transaction object.</p>
<h2 id="requesting-the-block-chain-status-information">Requesting the block chain status information</h2>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="block-chain-height">Block chain height</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/chain/height</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets the current height of the block chain.</p>

<h4>No parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/chain/height">http://127.0.0.1:7890/chain/height</a></p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
       "height": 42799
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">None.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="block-chain-score">Block chain score</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/chain/score</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets the current score of the block
	chain. The higher the score, the better the chain. During synchronization,
	nodes try to get the best block chain in the network.</p>

<h4>No parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/chain/score">http://127.0.0.1:7890/chain/score</a></p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
       "score": "18722d5a7d590deb"
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">None.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="last-block-of-the-block-chain-score">Last block of the block chain score</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/chain/last-block</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets the current last block of the
	chain.</p>

<h4>No parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/chain/last-block">http://127.0.0.1:7890/chain/last-block</a></p>
<h4>Example of returned JSON object (main network):</h4>
<pre><samp class="JSON">{
       "timeStamp": 9232968,
       "signature": "0a1351ef3e9b19c601e804a6d329c9ade662051d1da2c12c3aec9934353e421c79de7d8e59b127a8ca9b9d764e3ca67daefcf1952f71bc36f747c8a738036b05",
       "prevBlockHash": {
              "data": "58efa578aea719b644e8d7c731852bb26d8505257e03a897c8102e8c894a99d6"
       },
       "type": 1,
       "transactions": [
       ],
       "version": 1744830465,
       "signer": "2afca04d2cb8d16cf3656274bc55b95e60be823cfb7230d82f791ed42a309ee7",
       "height": 42804
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">None.</p>
<h2 id="requesting-parts-of-the-block-chain">Requesting parts of the block chain</h2>
<p>NIS can supply either individual blocks
	identified by block height or block hash or can supply up to 10 blocks
	beginning at a certain height.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="getting-a-block-with-a-given-hash">Getting a block with a given hash</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/block/get</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets a block from the chain that has a
	given hash.</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">blockHash </p>
</td>
<td>
<p class="NemNoSpacing">The 256 bit sha3 hash of the block.
				The hash must be supplied as hexadecimal string.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/block/get?blockHash=58efa578aea719b644e8d7c731852bb26d8505257e03a897c8102e8c894a99d6">http://127.0.0.1:7890/block/get?blockHash=58efa578aea719b644e8d7c731852bb26d8505257e03a897c8102e8c894a99d6</a></p>
<h4>Example of returned JSON object (main network):</h4>
<pre><samp class="JSON">{
       "timeStamp": 9232942,
       "signature": "005f91b8908fc173a428ff8e8c4a0ee0d69e4004aed0d08f27690b6b6672ef74ccc6b89695bed5f29b0f4a812cb84bfa459f52a4e14a11e574793969f0e1a30f",
       "prevBlockHash": {
              "data": "f721e563b4431594c5af6f6be0a913f47f0aca6c3b8ee6a703bfe175ee54babf"
       },
       "type": 1,
       "transactions": [
       ],
       "version": 1744830465,
       "signer": "78e121cc1cf63424651ec64251e78efda81386c9f5e9eb4cb08b2a2192c9dce5",
       "height": 42803
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">If the block hash is not found in the
	database, NIS will return a JSON error object. See <span><em>Appendix A:</em> <a href="#error-object">Error object</a></span> or more information of the error object and <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for the error message.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="getting-a-block-with-a-given-height">Getting a block with a given height</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="post" rowspan="2">Request type: <b>POST</b></td></tr><tr><td class="path">/block/at/public</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets a block from the chain that has the given height.</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">blockHeight </p>
</td>
<td>
<p class="NemNoSpacing">A BlockHeight JSON object as described
				in <span><em>Appendix A:</em> <a href="#blockHeight">BlockHeight</a></span>.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p class="NemNoSpacing">Request cannot be performed in a browser.</p>
<h4>Example of returned JSON object (test network):</h4>
<pre><samp class="JSON">{
       "timeStamp": 9232942,
       "signature": "005f91b8908fc173a428ff8e8c4a0ee0d69e4004aed0d08f27690b6b6672ef74ccc6b89695bed5f29b0f4a812cb84bfa459f52a4e14a11e574793969f0e1a30f",
       "prevBlockHash": {
              "data": "f721e563b4431594c5af6f6be0a913f47f0aca6c3b8ee6a703bfe175ee54babf"
       },
       "type": 1,
       "transactions": [
       ],
       "version": -1744830463,
       "signer": "78e121cc1cf63424651ec64251e78efda81386c9f5e9eb4cb08b2a2192c9dce5",
       "height": 42803
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">If the block with the specified height
	cannot be found in the database, NIS will return a JSON error object. See <span><em>Appendix A:</em> <a href="#error-object">Error object</a></span> or more information of the error object and <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> the error message.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="getting-part-of-a-chain">Getting part of a chain</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="post" rowspan="2">Request type: <b>POST</b></td></tr><tr><td class="path">/local/chain/blocks-after</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets up to 10 blocks after given block height from the chain.
        If the database contains less than 10 block after the given height, then less blocks are returned.
        The returned data is an array of <a href="#explorerBlockViewModel">ExplorerBlockViewModel</a> JSON objects.</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">blockHeight </p>
</td>
<td>
<p class="NemNoSpacing">A BlockHeight JSON object as described
				in <span><em>Appendix A:</em> <a href="#blockHeight">BlockHeight</a></span>.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p class="NemNoSpacing">Request cannot be performed in a browser.</p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
	"data":[{
		"txes":[{
			"tx": &lt;ExplorerViewModelTransaction&gt;
			"tx": &lt;ExplorerViewModelTransaction&gt;
		}],
		"block": &lt;Block&gt;
		"hash":"8ca8a3e01ac0eb482e668fda74141984ba118b027fc5f1f67d2d36a38bf48c49"
	}]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">If the block height supplied is not
	positive, NIS will return a JSON error object. See <span><em>Appendix A:</em> <a href="#error-object">Error object</a></span><b> </b>for more information of the error
	object and <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for the error message.</p>
<h1 id="node-related-requests">Node related requests</h1>
<p>Nodes are the entities that exchange data
	in a network. A node is essentially a NIS instance running on a computer. To be
	able to communicate with the network, a node needs to be booted. Through node
	requests it is possible to discover other nodes in the network, learn about
	other nodes experiences and get information about their current chain height.</p>
<p>Node structure consists of 3 parts:
	identity, endpoint and meta data:</p>
<p>Every node is tied to an identity which is
	represented by an account. That way nodes are easier to identify. A node is
	given an identity during the boot process.</p>
<p>The endpoint of a node holds information
	about the IP address, the port and the protocol used for communication.</p>
<p>The meta data holds additional information
	about the NIS version and the platform NIS is running on.</p>
<p>A node groups the set of neighbor nodes
	into several subsets by assigning a status to each node. The possible statuses
	are:</p>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">active</p>
</td>
<td>
<p>Nodes that have this status can be successfully communicated with.
				Whenever a node is selecting a node for communication, it will pick a node
				from the set of active nodes.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">inactive</p>
</td>
<td>
<p>Inactive nodes are nodes with which it is not possible to
				establish a connection.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">busy</p>
</td>
<td>
<p>A node is set to status 'busy' if a connection can be established
				but the node did not answer a request within a certain time limit.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">failure</p>
</td>
<td>
<p>The status failure is assigned to a remote node in case there is
				severe error during communication. This can for instance be due to the remote
				node using a different protocol or the remote node using an identity
				different from what was expected.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">unknown</p>
</td>
<td>
<p>This status is given to a node if there is no information about
				the status available.</p>
</td>
</tr>
</table>
<p><span><em>Appendix A:</em> <a href="#node">Node</a></span> has more information and an example JSON Node object. A node object has the following fields:</p>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">name</p>
</td>
<td>
<p>The name of the node. This can be any string.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">public-key</p>
</td>
<td>
<p>The public key used to identify the node.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">protocol</p>
</td>
<td>
<p>The protocol used for the communication (currently only HTTP is
				supported).</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">port</p>
</td>
<td>
<p>The port used for the communication.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">host</p>
</td>
<td>
<p>The IP address of the endpoint.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">application</p>
</td>
<td>
<p>The name of the application that is running the node.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">version</p>
</td>
<td>
<p>The version of the application.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">platform</p>
</td>
<td>
<p>The underlying platform (OS, java version).</p>
</td>
</tr>
</table>
<h2 id="requesting-information-about-a-node">Requesting information about a node</h2>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="basic-node-information">Basic node information</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/node/info</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets basic information about a node.
	Using IP 127.0.0.1 gets information about the local node.</p>

<h4>No parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/node/info">http://127.0.0.1:7890/node/info</a></p>
<h4>Example of returned JSON <a href="#node">Node</a></h4>
<pre><samp class="JSON">{
       "metaData":
       {
              "application": "NIS",
              "version": "0.4.33-BETA",
              "platform": "Oracle Corporation (1.8.0_25) on Windows 8"
       },
       "endpoint":
       {
              "protocol": "http",
              "port": 7890,
              "host": "81.224.224.156"
       },
       "identity":
       {
              "name": "Alice",
              "public-key": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
       }
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">In case the node has not been booted
	yet, NIS will return a JSON error object. See <span><em>Appendix A:</em> <a href="#error-object">Error object</a></span><b> </b>for more information of the error
	object and <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for the error message.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="extended-node-information">Extended node information</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/node/extended-info</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets extended information about a node.
	Using IP 127.0.0.1 gets extended information about the local node.</p>

<h4>No parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/node/extended-info">http://127.0.0.1:7890/node/extended-info</a></p>
<h4>Example of returned JSON <a href="#nisNodeInfo">NisNodeInfo</a> object:</h4>
<pre><samp class="JSON">{
       "node": {
              "metaData":
              {
                     "application": "NIS",
                     "version": "0.4.33-BETA",
                     "platform": "Oracle Corporation (1.8.0_25) on Windows 8"
              },
              "endpoint":
              {
                     "protocol": "http",
                     "port": 7890,
                     "host": "81.224.224.156"
              },
              "identity":
              {
                     "name": "Alice",
                     "public-key": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
              }
       },
       "nisInfo":
       {
              "currentTime": 9288341,
              "application": "NEM Infrastructure Server",
              "startTime": 9238484,
              "version": "0.4.33-BETA",
              "signer": "CN=VeriSign Class 3 Code Signing 2010 CA,OU=Terms of use at https://www.verisign.com/rpa (c)10,OU=VeriSign Trust Network,O=VeriSign\\, Inc.,C=US"
       }
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">In case the node has not been booted
	yet, NIS will return a JSON error object. See <span><em>Appendix A:</em> <a href="#error-object">Error object</a></span><b> </b>for more information of the error
	object and <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for the error message.</p>
<h2 id="request-for-discovering-the-neighborhood-of-a-node">Request for discovering the neighborhood of a node</h2>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="complete-neighborhood">Complete neighborhood</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/node/peer-list/all</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets an array of all known nodes in the
	neighborhood.</p>

<h4>No parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/node/peer-list/all">http://127.0.0.1:7890/node/peer-list/all</a></p>
<h4>Example of returned JSON <a href="#nodeCollection">NodeCollection</a> object (&lt;Node&gt;
		denotes a <a href="#node">Node</a> object):</h4>
<pre><samp class="JSON">{
       "inactive": [
              &lt;Node&gt;,
              &lt;Node&gt;
       ],
       "active": [
              &lt;Node&gt;,
              &lt;Node&gt;
       ],
       "busy": [
              &lt;Node&gt;,
              &lt;Node&gt;
       ],
       "failure": [
              &lt;Node&gt;,
              &lt;Node&gt;
       ]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">In case the node has not been booted
	yet, NIS will return a JSON error object. See <span><em>Appendix A:</em> <a href="#error-object">Error object</a></span><b> </b>for more information of the error
	object and <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for the error message.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="reachable-neighborhood">Reachable neighborhood</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/node/peer-list/reachable</td></tr></table>
<h4>Description:</h4>
<p>Gets an array of all nodes with status 'active' in the neighborhood.</p>

<h4>No parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/node/peer-list/reachable">http://127.0.0.1:7890/node/peer-list/reachable</a></p>
<h4>Example of returned JSON <a href="#nodeCollection">NodeCollection</a> object (&lt;Node&gt;
		denotes a <a href="#node">Node</a> object):</h4>
<pre><samp class="JSON">{
       "data": [
              "metaData":
              {
                     "application": "NIS",
                     "version": "0.4.33-BETA",
                     "platform": "Oracle Corporation (1.8.0_25) on Windows 8"
              },
              "endpoint":
              {
                     "protocol": "http",
                     "port": 7890,
                     "host": "81.224.224.156"
              },
              "identity":
              {
                     "name": "Alice",
                     "public-key": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
              },
       ]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">In case the node has not been booted
	yet, NIS will return a JSON error object. See <span><em>Appendix A:</em> <a href="#error-object">Error object</a></span><b> </b>for more information of the error
	object and <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for the error message.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="active-neighborhood">Active neighborhood</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/node/peer-list/active</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets an array of active nodes in the
	neighborhood that are selected for broadcasts.</p>

<h4>No parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/node/peer-list/active">http://127.0.0.1:7890/node/peer-list/active</a></p>
<h4>Example of returned JSON <a href="#nodeCollection">NodeCollection</a> object (&lt;Node&gt;
		denotes a <a href="#node">Node</a> object):</h4>
<pre><samp class="JSON">{
       "data": [
              "metaData":
              {
                     "application": "NIS",
                     "version": "0.4.33-BETA",
                     "platform": "Oracle Corporation (1.8.0_25) on Windows 8"
              },
              "endpoint":
              {
                     "protocol": "http",
                     "port": 7890,
                     "host": "81.224.224.156"
              },
              "identity":
              {
                     "name": "Alice",
                     "public-key": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
              },
       ]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">In case the node has not been booted
	yet, NIS will return a JSON error object. See <span><em>Appendix A:</em> <a href="#error-object">Error object</a></span><b> </b>for more information of the error
	object and <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for the error message.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="maximum-chain-height-in-the-active-neighborhood">Maximum chain height in the active neighborhood</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/node/active-peers/max-chain-height</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Requests the chain height from every
	node in the active node list (described in <a href="#active-neighborhood">Active neighborhood</a>) and returns the maximum height seen.</p>

<h4>No parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/node/active-peers/max-chain-height">http://127.0.0.1:7890/node/active-peers/max-chain-height</a></p>
<h4>Example of returned JSON <a href="#blockHeight">BlockHeight</a> object:</h4>
<pre><samp class="JSON">{
       "height": 43920
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">In case the node has not been booted
	yet, NIS will return a JSON error object. See <span><em>Appendix A:</em> <a href="#error-object">Error object</a></span><b> </b>for more information of the error
	object and <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for the error message.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h2 id="requesting-node-experiences">Requesting node experiences</h2>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/node/experiences</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets an array of node experiences from
	another node. Each node saves its experiences with other nodes in an internal
	map. Sharing experiences helps nodes to select honest nodes for communication.</p>

<h4>No parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/node/experiences">http://127.0.0.1:7890/node/experiences</a></p>
<h4>Example of returned array of JSON <a href="#extendedNodeExperiencePair">ExtendedNodeExperiencePair</a> objects:</h4>
<pre><samp class="JSON">{
       "data": [
       {
              "node":
              "metaData":
              {
                     "application": "NIS",
                     "version": "0.4.33-BETA",
                     "platform": "Oracle Corporation (1.8.0_25) on Windows 8"
              },
              "endpoint":
              {
                     "protocol": "http",
                     "port": 7890,
                     "host": "81.224.224.156"
              },
              "identity":
              {
                     "name": "Alice",
                     "public-key": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
              },
              "syncs": 3,
              "experience":
              {
                     "s": 1,
                     "f": 0
              }
       }]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">In case the node has not been booted
	yet, NIS will return a JSON error object. See <span><em>Appendix A:</em> <a href="#error-object">Error object</a></span><b> </b>for more information of the error
	object and <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for the error message.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h2 id="booting-the-local-node">Booting the local node</h2>
<table class="NemApiGrid"><tr><td>API path:</td><td class="post" rowspan="2">Request type: <b>POST</b></td></tr><tr><td class="path">/node/boot</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Boots the local node and thus assign an account (the identity) to the local node.</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">bootNodeRequest </p>
</td>
<td>
<p class="NemNoSpacing">A BootNodeRequest JSON object as
				described in <span><em>Appendix A:</em> <a href="#bootNodeRequest">BootNodeRequest</a></span>.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p class="NemNoSpacing">Request cannot be performed in a
	browser.</p>
<h4>No return value</h4>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">In case the node has already been booted, NIS will return a JSON error object. See <span><em>Appendix A:</em> <a href="#error-object">Error object</a></span> for more information of the error
	object and <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for the error message.</p>
<h1 id="namespaces-and-mosaics">Namespaces and Mosaics</h1>
<h2 id="namespaces">Namespaces</h2>
<p>NEM supports the concept of namespaces which is the NEM analog of internet domain names.
        A namespace is an identification string that consists of one or more parts that are concatenated by dots, for example 'makoto.metals.silver'.
        All namespaces are unique and thus can only have one owner at a time.
        A namespace that has only one part is called a root namespace, otherwise sub-namespace.
        Root namespaces can be rented by accounts for the duration of one year. One month before the root namespace expires the rental contract
        can be renewed for another year. If a root namespace rental contract is renewed, all sub-namespaces are valid for another year as well.
        If the root namespace is not renewed, it exires together with all sub-namespaces. One month after a root namespace expires,
        another account is able to rent that root namespace. The new owner does not inherit the sub-namespaces from the previous owner however.
        An account can only rent a sub-namespace if it owns the corresponding root namespace.
    </p>
<p>
        Namespaces have certain restrictions with respected to the characters being allowed in the parts as well as the length of a part. A root namespace
        may have a length of 16 characters while sub-namespaces may have a length of 64 characters. Valid characters are:
        <li>a, b, c, ..., z, A, B, C, ..., Z, 0, 1, 2, ..., 9, _ , - </li>
        However a part is only allowed to begin with a letter from the alphabet, thus 'alice' is an allowed part for a root namespace while '1alice' is not.
        Certain strings are reserved and thus not allowed as namespace parts. Among the disallowed namespace parts are
        <li>nem, user, account, org, com, biz, net, edu, mil, gov and info.</li>
        This list is not final and can be extended in the future. Thus 'user.alice' or 'alice.user' are not allowed in the NEM namespace system.
        The namespace may have up to 3 parts, thus 'makoto.metals.silver' is valid while 'makoto.metals.silver.coin' is not.
    </p>
<p>
        A namespace rental contract is done via a <span><em>Appendix A:</em> <a href="#provisionNamespaceTransaction">ProvisionNamespaceTransaction</a></span>. In addition to the usual transaction fee there is a rental
        fee. This fee is paid to the so called rental fee sink which is a special account with address
        <li>NAMESPACEWH4MKFMBCVFERDPOOP4FK7MTBXDPZZA in the main net and</li>
<li>TAMESPACEWH4MKFMBCVFERDPOOP4FK7MTDJEYP35 in the test net.</li>
        The fee for renting a namespace for one year is
        <li>50000 XEM for a root namespace and</li>
<li>5000 XEM for a sub-namespace.</li>
</p>
<p>
        The ownership of a namespace is needed in order to create mosaics.
    </p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="retrieving-root-namespaces">Retrieving root namespaces</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/namespace/roots</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets the root namespaces. The requests supports paging, i.e. retrieving the root namespaces in batches of a specified size.
        The request returns an array of <a href="#namespaceMetaDataPair">NamespaceMetaDataPair</a> objects.</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">id</p>
</td>
<td>
<p class="NemNoSpacing">The topmost namespace database id up to which root namespaces are returned. The parameter is optional.
                If not supplied the most recent rented root namespaces are returned.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">pagesize</p>
</td>
<td>
<p class="NemNoSpacing">The number of namespace objects to be returned for each request. The parameter is optional.
                    The default value is 25, the minimum value is 5 and hte maximum value is 100.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/namespace/roots?id=26754">http://127.0.0.1:7890/namespace/roots?id=26754</a></p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
        "data": [{
            "meta":{
                "id":26264,
            },
            "namespace":{
                "fqn": "makoto.metal.coins",
                "owner": TD3RXTHBLK6J3UD2BH2PXSOFLPWZOTR34WCG4HXH",
                "height": 13465
            }
        },{
            "meta":{
                "id":25421,
            },
            "namespace":{
                "fqn": "gimre.vouchers",
                "owner": TDGIMREMR5NSRFUOMPI5OOHLDATCABNPC5ID2SVA",
                "height": 12392
            }
        }]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">None.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="retrieving-a-specific-namespace">Retrieving a specific namespace</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/namespace/get</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets the namespace with given id.</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">namespace</p>
</td>
<td>
<p class="NemNoSpacing">The namespace id.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/namespace/get?namespace=makoto.metal.coins">http://127.0.0.1:7890/namespace/get?namespace=makoto.metal.coins</a></p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
        "fqn": "makoto.metal.coins",
        "owner": TD3RXTHBLK6J3UD2BH2PXSOFLPWZOTR34WCG4HXH",
        "height": 13465
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">NIS returns an error if the namespace parameter is missing or invalid.
        See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for details about errors.</p>
<h2 id="mosaics">Mosaics</h2>
<p>
       NEM mosaics are assets that expose additional properties and other features. Each mosaic has an underlying mosaic definition.
        To be able to create a mosaic definition, an account must rent at least one root namespace which the mosaic definition can then refer to.
        The basic data for a mosaic definition consists of
        <li>
<b>mosaic id</b>: the mosaic id consists of two parts, a namespace id and a mosaic name. When representing the mosaic id as string
            the two parts are concatenated via a '*':<br>
            For example if the namespace id is 'makoto.metals.silver' and the mosaic name is 'coin' then the string representation would be 'makoto.metals.silver * coin'.
            Since mosaic ids should be unique, the mosaic name has to be unique within the namespace the mosaic definition refers to. The maximum length for a
            mosaic name is 32 characters. Allowed characters are
            <ol><li>a, b, c, ..., z, A, B, C, ..., Z, 0, 1, 2, ..., 9, ', _ , - </li></ol>
            but the first character must be a letter from the alphabet.
        </br></li>
<li>
<b>description</b>: Each definition needs a description of the mosaic. The description may not exceed a length of 512 characters. There is no
            limitation for the characters used in the description.
        </li>
<li>
<b>properties</b>: The behavior of a mosaic can be customized by a set of properties. If no properties are supplied then default properties are applied.
            Supported properties are:
            <ol>
<li><b>initialSupply</b>: The creator can specify an initial supply of mosaics when creating the definition.
                    The supply is given in entire units of the mosaic, <b>not</b> in smallest sub-units. The initial supply must be in the range
                    of 0 and 9,000,000,000. The default value is "1000".</li>
<li><b>divisibility</b>: The divisibility determines up to what decimal place the mosaic can be divided into. Thus a divisibility of 3
                    means that a mosaic can be divided into smallest parts of 0.001 mosaics, i.e. milli mosaics is the smallest sub-unit.
                    When transferring mosaics via a transfer transaction the quantity transferred is given in multiples of those smallest parts.<br>
                    The divisibility must be in the range of 0 and 6. The default value is "0".</br></li>
<li><b>supplyMutable</b>: The creator can choose between a definition that allows a mosaic supply change at a later point or an immutable supply.
                    Allowed values for the property are "true" and "false". The default value is "false".</li>
<li><b>transferable</b>: The creator can choose if the mosaic definition should allow for transfers of the mosaic among accounts other than
                    the creator. If the property 'transferable' is set to "false", only transfer transactions having the creator as sender or as recipient
                    can transfer mosaics of that type. If set to "true" the mosaics can be transferred to and from arbitrary accounts.
                    Allowed values for the property are thus "true" and "false". The default value is "true".</li>
</ol>
</li>
<li>
<b>levy</b>: The creator can demand that for each transfer of a mosaic of that type a special fee is collected from the sender and send to an
            account of his choice (thus the creator can specify his own account as recipient of this fee). The data for the levy is the following:
                <ol>
<li><b>fee type:</b> There are two fee types supported, absolute fee and percentile fee.
                    <ol><li>absolute fee:</li> The fee is specified as absolute quantity and thus does not depend on the quantity that is transferred.
                    <li>percentile fee:</li> The fee is specified as multiple of the percentile of the quantity that is transferred. The fee is thus
                    linearly increasing with the transferred mosaic quantity.</ol></li>
<li><b>recipient:</b> The recipient of the levy. This can be any account.</li>
<li><b>mosaic id:</b> The id of the mosaic in which the fee has to be paid. Any existing mosaic id can be specified.
                        If the creator wants the fee to be paid in XEM, then (s)he has to use the mosaic id 'nem * xem'.</li>
<li><b>fee:</b> The fee quantity. The interpretation is dependent on the field 'fee type', see above.</li>
</ol>
</li>
</p>
<p>
        A mosaic definition can be created via a <span><em>Appendix A:</em> <a href="#mosaicDefinitionCreationTransaction">MosaicDefinitionCreationTransaction</a></span>. In addition to the usual transaction fee there is a creation
        fee. This fee is paid to the so called creation fee sink which is a special account with address
        <li>NBMOSAICOD4F54EE5CDMR23CCBGOAM2XSIUX6TRS in the main net and</li>
<li>TBMOSAICOD4F54EE5CDMR23CCBGOAM2XSJBR5OLC in the test net.</li>
        The fee for creating a mosaic definition is 50000 XEM.
    </p>
<p>There is one predefined mosaic which represents the XEM coin. The data for this XEM mosaic is:
        <li>namespace: nem</li>
<li>name: xem</li>
<li>initial supply: 8,999,999,999</li>
<li>divisibility: 6</li>
<li>supply mutable: false</li>
<li>transferable: true</li>
<li>levy: none</li>
</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h3 id="retrieving-mosaic-definitions">Retrieving mosaic definitions</h3>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/namespace/mosaicDefinitions</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets the mosaic definitions for a given namespace. The request supports paging.
        The request return an array of <a href="#mosaicDefinitionMetaDataPair">MosaicDefinitionMetaDataPair</a> objects.</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">namespace</p>
</td>
<td>
<p class="NemNoSpacing">The namespace id.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">id</p>
</td>
<td>
<p class="NemNoSpacing">The topmost mosaic definition database id up to which root mosaic definitions are returned. The parameter is optional.
                    If not supplied the most recent mosaic definitiona are returned.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">pagesize</p>
</td>
<td>
<p class="NemNoSpacing">The number of mosaic definition objects to be returned for each request. The parameter is optional.
                    The default value is 25, the minimum value is 5 and hte maximum value is 100.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/namespace/mosaicDefinitions?namespace=makoto.metal.coins">http://127.0.0.1:7890/namespace/mosaicDefinitions?namespace=makoto.metal.coins</a></p>
<h4>Example of returned JSON object:</h4>
<pre><samp class="JSON">{
    "data": [{
        "meta" {
            "id": 3541
        },
        "mosaic": {
            "creator": "10cfe522fe23c015b8ab24ef6a0c32c5de78eb55b2152ed07b6a092121187100",
            "id": {
                "namespaceId": "makoto.metal.coins",
                "name": "silver coin"
            },
            "description": "Real silver coins, pure silver",
            "properties": [{
                 "name": "divisibility",
                 "value": "0"
            },{
                "name": "initialSupply",
                "value": "1000"
            },{
                "name": "supplyMutable",
                "value": "false"
            },{
                "name": "transferable",
                "value": "true"
            }]
        }
    }]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">NIS returns an error if the namespace parameter is missing or invalid.
        See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for details about errors.</p>
<h1 id="initiating-transactions">Initiating transactions</h1>
<p>Transactions are the way of transferring NEM and/or messages from one
        account to another. Once a transaction is initiated, it is still unconfirmed and
        thus not yet accepted by the network. At this point it is not yet clear if it will
        get included in a block. Never rely on a transaction which has the state
        'unconfirmed'. Once it is included in a block, the transaction gets processed and,
        in case of a transfer transaction, the amount stated in the transaction gets
        transferred from the sender's account to the recipient's account. Additionally
        the transaction fee is deducted from the sender's account. The transaction is
        said to have 0 confirmations at this point. When another block is added to the
        block chain the transaction has 1 confirmation. The next block added to the
        chain will give it 2 confirmations and so on.</p>
<p>Crypto currencies have the ability to roll back part the block chain. This is
        essential for being able to resolve forks of the block chain. There is however
        a maximum number of blocks that can be rolled back, this is called the rewrite
        limit. Hence forks can only be resolved up to a certain depth too. NEM has
        a rewrite limit of 360 blocks. Once a transaction has more than 360
        confirmations, it cannot be reversed. In real life, forks that are deeper than
        20 blocks do not happen, unless there was some severe problem with the
        block chain due to a bug in the code or an attack of some kind.</p>
<p>A client can initiate a transaction in two ways:</p>
<li>
        If the client is not able to sign the transaction data it can let the local NIS
        do the signing by sending a RequestPrepareAnnounce JSON object to NIS. See
        <span><em>Appendix A:</em> <a href="#requestPrepareAnnounce">RequestPrepareAnnounce</a></span> for more details.

        <div class="warning">
            The <span class="JSON">/transaction/prepare-announce</span> API
            should be <br> used only on <strong>TRUSTED</strong> and <strong>LOCAL</strong> nodes!
        </br></div>
<p>Note: keep in mind, that NCC does <strong>NOT</strong>
            use this API. It does all the transaction signing on it's own.
        </p>
</li>
<li>
        If the client has an ed25519 implementation and can thus sign the transaction it
        can send a RequestAnnounce JSON object to NIS. Doing so has the advantage that you
        can use an untrusted remote NIS for sending a transaction.
        See <span><em>Appendix A:</em> <a href="#requestAnnounce">RequestAnnounce</a></span> for more details on this object.
    </li>
<p>Since most client with depend on a local NIS to create the transaction signature
        Chapters 6.1 through 6.6 will explain transaction related actions using the first way.
        Chapter 6.7 explains the steps you have to take to gather the data that needs to be signed
        and how to initiate a transaction the second way.
        Note however that we will not explain how to create the signature itself since this involves
        some cryptographical concepts which are out of the scope of this document.
    </p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h2 id="initiating-a-transaction">Initiating a transaction</h2>
<table class="NemApiGrid"><tr><td>API path:</td><td class="post" rowspan="2">Request type: <b>POST</b></td></tr><tr><td class="path">/transaction/prepare-announce</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Creates and broadcasts a transaction.
	Since this request involves the private key of an account, it should only be
	sent to a <b>local</b> NIS.</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">requestPrepareAnnounce</p>
</td>
<td>
<p class="NemNoSpacing">A RequestPrepareAnnounce JSON object as described in <span><em>Appendix A:</em> <a href="#requestPrepareAnnounce">RequestPrepareAnnounce</a></span>.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p class="NemNoSpacing">Request cannot be performed in a
	browser.</p>
<h4>Example of returned JSON <a href="#nemAnnounceResult">NemAnnounceResult</a> object:</h4>
<pre><samp class="JSON">{
   "type":1,
   "code":1,
   "message":"SUCCESS",
   "transactionHash": {
      "data":"c1786437336da077cd572a27710c40c378610e8d33880bcb7bdb0a42e3d35586"
   },
   "innerTransactionHash": {
      "data":"cc317a7674d56352b4c711096a7594bd11908bf518293a191fc2faa12eac0fbb"
   }
}</samp></pre>
<h4>Possible Errors:</h4>
<p>There are various errors that can occur due
	to failure of transaction validation See <span><em>Appendix A:</em> <a href="#error-object">Error object</a></span><b> </b>for more information of the error
	object and <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for the error message.</p>
<p>The most common errors are:</p>
<ul>
<li>The sender account has not enough funds.</li>
<li>The timestamp is invalid because it lies too far in the future.</li>
<li>The deadline is invalid because it has already been passed.</li>
<li>The attached message is too large.</li>
<li>The transaction is already known.</li>
<li>There is another transaction conflicting with this transaction. This can happen when trying to transfer the importance to another account.</li>
</ul>
<h2 id="initiating-a-transfer-transaction">Initiating a transfer transaction</h2>
<p>NIS supports transfer transactions having version 1 or 2. Transfer transactions with version 1 can only transfer a message and XEM coins
    while version 2 transfer transactions can transfer a set of mosaics too.</p>
<h3 id="version-1-transfer-transactions">Version 1 transfer transactions</h3>
<p>Suppose you want to send 1000 NEM from sender account (referred hereafter as <em><b>'Alice'</b></em>):</p>
<p class="JSON">TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS</p>
<p>to recipient account: </p>
<p class="JSON">TBOBBSXX7BESJXDWGLP5Z7FM5HSTKUH5WIMPW562</p>
<p>The RequestPrepareAnnounce JSON object you have to send to NIS via a POST request would look similar to this (test network):</p>
<pre><code class="JSON">
{
        "transaction":
        {
            "timeStamp": 9111526,
            "amount": 1000000000,
            "fee": 3000000,
            "recipient": "TBOBBSXX7BESJXDWGLP5Z7FM5HSTKUH5WIMPW562",
            "type": 257,
            "deadline": 9154726,
            "message":
            {
                "payload": "",
                "type": 1
            },
            "version": -1744830463,
            "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
        },
        "privateKey": "00983bb01d05edecfaef55df9486c111abb6299c754a002069b1d0ef4537441bda"
}
    </code></pre>
<p>Note that there is no signature in the transaction part of the object since NIS will create the signature for you.
        Note also that the field 'version' contains both the network version and the transaction version as can be see when converting
        the value to the hexadecimal system: -1744830463 = 0x98000001 (network version 0x98 and transaction version 0x01).
        If the sender account has enough funds for the transaction NIS would respond with the JSON object</p>
<pre><samp class="JSON">{
        "type": 1,
        "code": 1,
        "message": "SUCCESS",
        "transactionHash": {
            "data":"c1786437336da077cd572a27710c40c378610e8d33880bcb7bdb0a42e3d35586"
        },
        "innerTransactionHash": {}
}</samp></pre>
<h3 id="version-2-transfer-transactions">Version 2 transfer transactions</h3>
<p>With transfer transactions version 2 you can just transfer messages and XEM as described in the previous chapter, the only difference
    being the field version which should have the value -1744830462 = 0x98000002 for testnet or 1744830466 = 0x68000002 for mainnet. </p>
<p>However, version 2 transfer transaction are more powerful as they let you transfer mosaics too.<br>
        Suppose you already have created a mosaic with id 'makoto.metals.silver * coin' with a divisibility of 0 and you want bundle the transfer
        of those silver coin mosaics with a transfer of 100 XEM for each silver coin. For transferring 3 silver coin mosaics and 300 XEM with a single
        transfer transaction you would issue a RequestPrepareAnnounce JSON object to NIS which looks like this:</br></p>
<pre><code class="JSON">
{
        "transaction":
        {
            "timeStamp": 9111526,
            "amount": 3000000,
            "fee": 30000000,
            "recipient": "TBOBBSXX7BESJXDWGLP5Z7FM5HSTKUH5WIMPW562",
            "type": 257,
            "deadline": 9154726,
            "message":
            {
                "payload": "",
                "type": 1
            },
            "version": -1744830462,
            "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
            "mosaics":[{
                "mosaicId":{
                    "namespaceId": "makoto.metals.silver",
                    "name": "coin"
                },
                "quantity": 1
            },{
                "mosaicId":{
                    "namespaceId": "nem",
                    "name": "xem"
                },
                "quantity": 100000000
            }]
        },
        "privateKey": "00983bb01d05edecfaef55df9486c111abb6299c754a002069b1d0ef4537441bda"
}
    </code></pre>
<p>There are 2 mosaics attached to the transfer transaction:
        <li>A mosaic with id 'makoto.metals.silver * coin' and quantity 1 which represents 1 smallest unit available for the mosaic.
            Since the divisibility of that mosaic is 0 (as assumed above) the quantity represents 1 whole unit, i.e. 1 coin.</li>
<li>A mosaic with id 'nem * xem' (which is the special XEM mosaic representing regular XEM coins) which has a divisibility of 6 and
            thus the quantity of 100000000 represents 100 XEM.</li>
        You can view the attachment as being a bag of mosaics holding in this example 1 silver coin mosaic and 100 XEM.
    </p>
<p>The amount field of the transaction is interpreted differently for the transaction due to the attachment. The number to multiply the quantities
        given in the attachment is given by dividing the amount by 1,000,000 (as of this version NIS does not support fractional transfers). So in this
        example 3,000,000 / 1,000,000 = 3 and thus 3 times the attachment is transferred resulting in 3 silver coin mosaics and 300 XEM being transferred
        to the recipient.</p>
<p>Common reason for the transaction to be rejected could be:
        <li>At least one mosaic specified in the attachment is unknown to NIS.</li>
<li>The sender does not own enough mosaics of at least type specified in the attachment.</li>
<li>At least one mosaic specified in the attachment is defined as not transferable and both sender and recipient are not the creator of that mosaic.</li>
</p>
<p>If the mosaic definition for the mosaic 'makoto.metals.silver * coin' has a levy section stating that for each transfer involving the silver coin mosaic
        10 XEM has to be paid to the recipient with address TDGOGOGOWZJ3HU4F6CUM5IKE7GHG4FFTF5BZ7JPW then the transfer transaction would automatically
        induce a transfer of 10 XEM from the transaction sender to TDGOGOGOWZJ3HU4F6CUM5IKE7GHG4FFTF5BZ7JPW.</p>
<h2 id="converting-an-account-to-a-multisig-account">Converting an account to a multisig account</h2>
<p>NIS natively supports m of n multisig accounts. This means an account can be converted into a multisig account
        having n cosignatories and m of those cosignatories need to sign a transaction from the multisig account in order
        to complete the transaction.
		To convert a normal account to a multisig account an aggregate modification transaction
        (see <span><em>Appendix A:</em> <a href="#multisigAggregateModificationTransaction">MultisigAggregateModificationTransaction</a></span>) must be sent to the network.
        Assuming you want to convert <em>Alice</em> with public key:</p>
<ul> Account <b>'Alice'</b>:
			<ul>
<li>public key: <span class="JSON">a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a</span></li>
</ul>
</ul>
<p>into a 2 of 3 multisig account meaning the account has 3 cosignatories and at least 2 cosignatories have to sign
		to complete a multisig transaction:</p>
<ol>
<li> Cosignatory <b>'Bob'</b>:
            <ul>
<li>address: <span class="JSON">TBOBBSXX7BESJXDWGLP5Z7FM5HSTKUH5WIMPW562</span></li>
<li>public key: <span class="JSON">6083df7119d43e815ed2967c795f806f6b73f8f92a56a7611e3848816ec50958</span></li>
</ul>
</li>
<li>Cosignatory <b>'jusan'</b>:
            <ul>
<li>address: <span class="JSON">TBJUSANZ63AKNJ57XMK6Y2IBH55UNNRXJFZRDTRW</span></li>
<li>public key: <span class="JSON">0662ed29cbfa7038530fb7f52df865eed6708d51bc7a24bcd05db35185b53c70</span></li>
</ul>
</li>
<li>Cosignatory <b>'go'</b>:
            <ul>
<li>address: <span class="JSON">TDGOGOGOWZJ3HU4F6CUM5IKE7GHG4FFTF5BZ7JPW</span></li>
<li>public key: <span class="JSON">cc61676a4275abcffd10a9ea1081091ff054a1a8a720429256aebf8034aab099</span></li>
</ul>
</li>
</ol>
<p>you would have to create a JSON object that looks similar to this (test network):</p>
<pre><code class="JSON">    {
        "transaction":
        {
            "timeStamp": 9111526,
            "fee": 28000000,
            "type": 4097,
            "deadline": 9154726,
            "version": -1744830462,
            "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a",
            "modifications": [
                {
                    "modificationType": 1,
                    "cosignatoryAccount": "6083df7119d43e815ed2967c795f806f6b73f8f92a56a7611e3848816ec50958"
                },{
                    "modificationType": 1,
                    "cosignatoryAccount": "0662ed29cbfa7038530fb7f52df865eed6708d51bc7a24bcd05db35185b53c70"
                },{
                    "modificationType": 1,
                    "cosignatoryAccount": "cc61676a4275abcffd10a9ea1081091ff054a1a8a720429256aebf8034aab099"
                }
            ],
            "minCosignatories" : {
                "relativeChange": 2
            }
        },
        "privateKey": "00983bb01d05edecfaef55df9486c111abb6299c754a002069b1d0ef4537441bda"
    }</code></pre>
<p>Note again that there is no signature since the transaction will be signed by NIS.</p>
<p>After the transaction is signed by NIS and is accepted by the network by
        including it into a block, the account Alice is now a 2 of 3 multisig account.
        From this point on, only the cosignatories can initiate a transaction for the
        account <em>Alice</em>. Also, any transaction from account <em>Alice</em>
        must be a multisig transaction.</p>
<h2 id="initiating-a-multisig-transaction">Initiating a multisig transaction</h2>
<p>As stated above, only one of the cosignatories (<em>Bob, Jusan and Go</em>)
        can create a transaction for the account <em>Alice</em>.</p>
<p>Lets assume <em>Bob</em> wants to start a transfer transaction which transfers
        1000 NEM from account <em>Alice</em> to account <em>Jusan</em>.<br>
        Since the account <em>Alice</em> is a multisig account the transfer transaction
        (in the JSON object the "otherTrans" structure) must be wrapped in
        a multisig transaction (see <span><em>Appendix A:</em> <a href="#multisigTransaction">MultisigTransaction</a></span>).
        The corresponding RequestPrepareAnnounce object would look similar to this (test network):</br></p>
<pre><code class="JSON">    {
        "transaction":
        {
            "timeStamp": 9111526,
            "fee": 3000000,
            "type": 4100,
            "deadline": 9154726,
            "version": -1744830463,
            "signer": "6083df7119d43e815ed2967c795f806f6b73f8f92a56a7611e3848816ec50958",
            "otherTrans": {
                "timeStamp": 9111526,
                "amount": 1000000000,
                "fee": 4000000,
                "recipient": "TBJUSANZ63AKNJ57XMK6Y2IBH55UNNRXJFZRDTRW",
                "type": 257,
                "deadline": 9154726,
                "message":
                {
                    "payload": "",
                    "type": 1
                },
                "version": -1744830463,
                "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
            },
            "signatures":[
            ]
        },
        "privateKey": "00a6e2526b5cc84f9174c4ff050ca352623061115951c649b36b08409c4ccb7b2e"
    }</code></pre>
<p>NIS will sign the transaction and publish it. The returned
        <a href="#NemAnnounceResult">NemAnnounceResult</a> object this time
        contains the hash of the inner transaction (<i>otherTrans</i> in the above structure):</p>
<pre><span class="JSON">    {
        "type": 1,
        "code": 1,
        "message": "SUCCESS"
    	"transactionHash": {
            "data":"c1786437336da077cd572a27710c40c378610e8d33880bcb7bdb0a42e3d35586"
        },
        "innerTransactionHash": {
            <b>"data": "44e4968e5aa35fe182d4def5958e23cf941c4bf809364afb4431ebbf6a18c039"</b>
        }
    }</span></pre>
<p>The hash is needed by the nodes that will create multisig signature transactions
        for the above transaction.</p>
<p>At this point the transaction cannot (and will not) be included in a block
        because none of the other cosignatories - <em>Jusan</em> and <em>Go</em> - has
        signed the transaction yet </p>
<h3 id="cosigning-multisig-transaction">Cosigning multisig transaction</h3>
<p> to do so, <em>Jusan</em> or <em>Go</em> must initiate a multisig signature transaction
        (see <span><em>Appendix A:</em> <a href="#multisigSignatureTransaction">MultisigSignatureTransaction</a></span>).
        <em>Jusan</em> has to create a RequestPrepareAnnounce JSON object that looks similar to this (test network):</p>
<pre><code class="JSON">    {
        "transaction":
        {
            "timeStamp": 9111526,
            "fee": 6000000,
            "type": 4098,
            "deadline": 9157365,
            "version": -1744830463,
            "signer": "0662ed29cbfa7038530fb7f52df865eed6708d51bc7a24bcd05db35185b53c70",
            "otherHash": {
                <b>"data": "44e4968e5aa35fe182d4def5958e23cf941c4bf809364afb4431ebbf6a18c039"</b>
            },
            <b>"otherAccount": "TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS"</b>
        },
        "privateKey": "00be34fdb20a9f6fed51376f0bab9f25ea7a48d610324588a6b203d0a1a6db4bc1"
    }</code></pre>
<p>Note that <em>Jusan</em> used the hash ('otherHash') returned by NIS
        from <em>Bob's</em> request.</p>
<p>After NIS has signed the transaction and sent it to the network,
        the signature transaction will be attached to the multisig transaction.<br>
        With <em>Jusan</em> having signed the multisig transaction that <em>Bob</em> initiated,
        two of the three cosignatories have signed the inner transfer transaction (<em>Bob</em>
		indirectly signed by initiating the multisig transaction) and thus the
        multisig transaction can be included in a block.
    </br></p>
<h2 id="adding-and-removing-cosignatories">Adding and removing cosignatories</h2>
<p>It is possible to modify the list of cosignatories for a multisig account. This is
        done via a aggregate modification transaction wrapped in a multisig transaction.</p>
<p>Suppose you want to add the cosignatory <em>Hachi</em> to the multisig
        account <em>Alice</em> and increase the minimum of cosignatories required to complete
	a transaction from 2 to 3.</p>
<ol start="4">
<li> Cosignatory <b>'hachi'</b>:
            <ul>
<li>address: <span class="JSON">TDHACHIMHRBBRHR57SR3BDBFFWDTYVSLGMFKIDOR</span></li>
<li>public key: <span class="JSON">6c66ea288522990db7a0a63c9c20f532cdcb68dc3c9544fb20f7322c92ceadbb</span></li>
</ul>
</li>
</ol>
<p>To do that, one of the existing cosignatories (assuming here it is <em>Jusan</em>)
        must initiate the corresponding multisig transaction (test network):</p>
<pre><code class="JSON">{
        "transaction":
        {
            "timeStamp": 9111526,
            "fee": 6000000,
            "type": 4100,
            "deadline": 9154726,
            "version": -1744830462,
            "signer": "6083df7119d43e815ed2967c795f806f6b73f8f92a56a7611e3848816ec50958",
            "otherTrans": {
                "timeStamp": 9111526,
                "fee": 16000000,
                "type": 4097,
                "deadline": 9154726,
                "version": -1744830462,
                "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a",
                "modifications": [
                    {
                    "modificationType": 1,
                    <b>"cosignatoryAccount": "6c66ea288522990db7a0a63c9c20f532cdcb68dc3c9544fb20f7322c92ceadbb"</b>
                    }
                ],
                "minCosignatories" : {
                    "relativeChange": 1
                }
            },
            "signatures":[
            ]
        },
        "privateKey": "00be34fdb20a9f6fed51376f0bab9f25ea7a48d610324588a6b203d0a1a6db4bc1"
    }</code> </pre>
<p>After NIS has signed and broadcasted the transaction to the network, one of the other
        two cosignatories needs to sign the transaction as well as explained in
        <a href="#initiating-a-multisig-transaction">Initiating a multisig transaction</a>.
        After the transaction was successfully included in a block, the account <em>Alice</em>
        is a 3 of 4 multisig account.</p>
<p>If at some later time <em>Bob, Jusan and Go</em> want to remove the
        cosignatory <em>Hachi</em> to make it a 2 of 3 multisig account again one of cosignatories could initiate a similar
        transaction as above but this time with <span class="JSON">"modificationType"</span>
        set to <b>2</b> (which means remove) and using a minimum cosignatories relative change value of <b>-1</b>.<br>
        For removing a cosignatory <em>all</em> cosignatories except the one being removed need to sign the transaction.
        Once approved by the network <em>Hachi</em> is no longer cosignatory of the multisig account <em>Alice.</em></br></p>
<div class="warning">
        Removal of accounts is <strong>NOT</strong> final and might be subject of change
    </div>
<h2 id="how-to-use-a-multisig-account">How to use a multisig account</h2>
<p>The purpose of multisig accounts is to make accounts safer. But this relies
        on the user not making mistakes when using multisig accounts.<br>
        If for instance all private keys of the cosignatories of a multisig account
        reside on a single computer then the multisig account is essentially as good
        as a normal account because if that computer gets compromised all private
        keys are disclosed to the attacks at once.</br></p>
<p>It is therefore essential to have the private key of the cosignatories on
        different computer preferably in different locations.</p>
<p>If you have read
        "<a href="#initiating-a-multisig-transaction">Initiating a multisig transaction</a>"
        you know that the cosignatories of a multisig transaction must know the hash
        of the inner transaction in order to be able to sign the multisig transaction.
        There are two ways of gaining knowledge of that hash:</p>
<ol>
<li>The initiator of the multisig transaction writes down the hash (which is
            included in the returned JSON object by NIS) and sends the hash to the cosignatories.</li>
<li>The cosignatories poll the unconfirmed transactions using their local NIS.
            As described in chapter
            <a href="#unconfirmed-transactions">Unconfirmed transactions</a>,
            the meta data part of an unconfirmed transaction JSON object contains
            the hash of the inner transaction in case of a multisig transaction.</li>
</ol>
<p>In first case the implementer of the client side software is responsible for
        transferring the hash to the cosignatories while in second case the NEM network
        will do it for you.</p>
<p>The standard client NCC uses the second method. It lets you handle multisig accounts in a convenient way.</p>
<p>
        Currently, we recommend to use at least three cosignatories in different locations when
        using the multisig account feature. If one of the cosignatory's private key gets
        compromised you should immediately remove that account from the list of
        cosignatories and afterwards add a new cosignatory
        (see chapter <a href="#adding-and-removing-cosignatories">Adding and removing cosignatories</a>
        on how to do this).</p>
<p><b>If a private key is stored on a computer that computer should not be used
        for surfing the internet or doing other unsafe things.</b></p>
<h2 id="provisioning-a-namespace">Provisioning a namespace</h2>
<p>This chapter explains what actions you have to take in order to provision (i.e. rent) a namespace.
	   You can find a detailed description of namespaces in the chapter <a href="#namespaces">Namespaces</a>.
		Suppose you want to claim the root namespace 'alice' and the sub-namespace 'alice.vouchers'. The first action
		would be to issue an <a href="#provisionNamespaceTransaction">ProvisionNamespaceTransaction</a>. As usual this is done
		by sending a RequestPrepareAnnounce JSON object to NIS which in this case would look like this:
	</p>
<pre><code class="JSON">
{
            "transaction":
            {
                "timeStamp": 9111526,
                "fee": 108000000,
                "type": 8193,
                "deadline": 9154726,
                "version": -1744830463,
                "signer": "d99e88c90da71a4b0d848454e59e296c9ef7a8f018f3eaa3a198dc460b6621a4",
                "rentalFeeSink": "3e82e1c1e4a75adaa3cba8c101c3cd31d9817a2eb966eb3b511fb2ed45b8e262",
                "rentalFee": 50000000000,
                "newPart": "alice",
                "parent": null
            },
            "privateKey": "00983bb01d05edecfaef55df9486c111abb6299c754a002069b1d0ef4537441bda"
}
        </code></pre>
<p>The field 'parent' is set to null indicating that you want to rent a root namespace. You also have to be sure that no one else
        has already rented that root namespace or NIS will return an error. The high rental fee is there to prevent users from squatting all
        kinds of root namespaces. This fee is not given to the harvesters because this would encourage harvesters to wait until they are
        allowed to harvest a block, include their provision namespace transaction in that block and thus essentially getting the namespace
        for free. Instead all rental fees are collected in a special multisig account.<br>
        The most common error responses from NIS will be:
        <li>The namespace is already owned by another account.</li>
<li>The namespace contains illegal character or a reserved namespace part.</li>
<li>The public key of the rental fee sink is invalid.</li>
<li>The rental fee is invalid (i.e. too low).</li>
        If NIS responses with a success message, the transaction is broadcasted to the network and will get included in a future block.
        After the transaction is included in a block you can check that you are the owner of that namespace by issuing an /account/namespaces
        request, see chapter xyz.
    </br></p>
<p>To rent the sub-namespace 'alice.vouchers' you need again send a RequestPrepareAnnounce JSON object to NIS which this time looks like this:</p>
<pre><code class="JSON">
{
         "transaction":
         {
             "timeStamp": 9111526,
             "fee": 108000000,
             "type": 8193,
             "deadline": 9154726,
             "version": -1744830463,
             "signer": "d99e88c90da71a4b0d848454e59e296c9ef7a8f018f3eaa3a198dc460b6621a4",
             "rentalFeeSink": "3e82e1c1e4a75adaa3cba8c101c3cd31d9817a2eb966eb3b511fb2ed45b8e262",
             "rentalFee": 5000000000,
             "newPart": "vouchers",
             "parent": "alice"
         },
         "privateKey": "00983bb01d05edecfaef55df9486c111abb6299c754a002069b1d0ef4537441bda"
}
         </code></pre>
<p>This time the parent is set to the parent namespace, in this case the root namespace 'alice'. The rental fee for a sub-namespace
        is 10% of the fee for a root namespace, i.e. 5000 XEM. Be sure to wait until you own the root namespace or NIS will respond with
        an error message. Once the transaction is included in a block, you own the sub-namespace 'alice.vouchers' as long as the root namespace 'alice'
        does not expire.</p>
<p>If you want to rent the sub-namespace 'alice.vouchers.special' you have to issue a RequestPrepareAnnounce object again, this time with
    parent set to 'alice.vouchers'. and the newPart being 'special'.</p>
<p>After a year the root namespace expires. In order not to let this happen you need to send a provision namespace transaction for the root namespace
        within one month before it expires. The RequestPrepareAnnounce object is the same as if you were renting the namespace for the first time.
        The renewal of the root namespace also automatically renews any sub-namespace of that root namespace that the account already owns.
    </p>
<h2 id="creating-mosaics">Creating mosaics</h2>
<h3 id="creating-a-mosaic-definition">Creating a mosaic definition</h3>
<p>The basics of the NEM mosaic concept can be found in the chapter <a href="#mosaics">Mosaics</a>.<br>
        To define and create a mosaic type you need to issue a <a href="#mosaicDefinitionCreationTransaction">MosaicDefinitionCreationTransaction</a>.
        As usual this is done by sending a RequestPrepareAnnounce JSON object to NIS which in this case would look like this:
    </br></p>
<pre><code class="JSON">
{
        "transaction":
        {
            "timeStamp": 9111526,
            "fee": 108000000,
            "type": 16385,
            "deadline": 9154726,
            "version": -1744830463,
            "signer": "cbda3edb771d42801a5c6ce0725f9374efade19a8933d6ac22ccfa50c777d0f9",
            "creationFee": 50000000000,
            "creationFeeSink": "53e140b5947f104cabc2d6fe8baedbc30ef9a0609c717d9613de593ec2a266d3",
            "mosaicDefinition": {
                "creator": "cbda3edb771d42801a5c6ce0725f9374efade19a8933d6ac22ccfa50c777d0f9",
                "description": "precious vouchers",
                "id": {
                    "namespaceId": "alice.vouchers",
                    "name": "Alice's gift vouchers"
                },
                "properties": [{
                    "name": "divisibility",
                    "value": "0"
                },{
                    "name": "initialSupply",
                    "value": "1000"
                },{
                    "name": "supplyMutable",
                    "value": "true"
                },{
                    "name": "transferable",
                    "value": "false"
                }
            ],
            "levy": {
                "type": 1,
                "recipient": "TD3RXTHBLK6J3UD2BH2PXSOFLPWZOTR34WCG4HXH",
                "mosaicId": {
                    "namespaceId": "nem",
                    "name": "xem"
                },
                "fee": 10
                }
            }
        },
        "privateKey": "00983bb01d05edecfaef55df9486c111abb6299c754a002069b1d0ef4537441bda"
}
        </code></pre>
<p>With the above transaction a mosaic with id 'alice.vouchers * Alice's gift vouchers' is created within the namespace 'alice.vouchers'. The account must
        own that namespace in order to be able to create a mosaic in it. There is a high creation fee for creating mosaic definition in order to discourage
        squatting. As stated in the previous chapter, the fee is not transferred to the block harvester but to a special account whose public key is
        provided in the field 'creationFeeSink'.</p>
<p>The mosaic has the following properties:
        <li>It is not divisible, i.e. the vouchers that the mosaic represents can only be transferred as a whole, not partially.</li>
<li>There will be initially 1000 vouchers (mosaics of that type).</li>
<li>The supply (the number of mosaics of that type) can be changed at a later point.</li>
<li>The vouchers are not transferable among accounts. Only the creator of the mosaic can transfer vouchers to other accounts and once an account
            owns a voucher it can only be transferred back to the creator.</li>
        The definition also implies a levy with each transfer. The levy section states that there is an additional fee of 10 XEM for each transfer. That fee
        is send to the recipient with address TD3RXTHBLK6J3UD2BH2PXSOFLPWZOTR34WCG4HXH.<br>
        This levy part of the transaction is optional. If that part is ommited no additional fee arises from transferring the mosaics.
    </br></p>
<p>Reasons for NIS now accepting the transactions are most likely:
        <li>The transaction signer does not own the namespace that is specified in the mosaic definition or the namespace has expired.</li>
<li>A mosaic definition with the specified mosaic id already exists (see discussion below about altering mosaic definitions).</li>
<li>The public key of the creation fee sink is invalid or the creation fee is too low.</li>
<li>The mosaic id in the levy part of the transaction is unknown to NIS.</li>
</p>
<p>When the transaction gets included into a block and the block is executed, The creator will be credited the amount of mosaics stated in the
    'initialSupply' field (in the example 1000).</p>
<h3 id="altering-a-mosaic-definition">Altering a mosaic definition</h3>
<p>There might be the need to alter a mosaic definition, either because you want to change the description or because you supplied faulty properties or
        faulty levy data. This is done simply by issuing another mosaic definition creation transaction as described above with the same mosaic id but
        different description/properties/levy. However there are some restriction when doing so:
        <li>The description can be changed at any point even if the creator does not own the entire supply.</li>
<li>Properties and the levy data can <b>only</b> be changed if the creator owns every single mosaic of that type. This is necessary to prevent
        the creator from secretly introducing a levy or inflating the mosaic by increasing the supply.</li>
        Keep in mind that renewing the mosaic definition costs you 50000 XEM again, so it is worthwhile to double check the data before issuing the
        transaction.
    </p>
<h3 id="changing-the-mosaic-supply">Changing the mosaic supply</h3>
<p>In case you created a mosaic definition with 'supplyMutable' set to true, you are able to change the mosaic supply. To do so, you must
       issue a <a href="#mosaicSupplyChangeTransaction">MosaicSupplyChangeTransaction</a>. This is done by sending a RequestPrepareAnnounce JSON object
        to NIS which in this case would look like this:
    </p>
<pre><code class="JSON">
{
        "transaction":
        {
            "timeStamp": 9111526,
            "fee": 108000000,
            "type": 16386,
            "deadline": 9154726,
            "version": -1744830463,
            "signer": "d99e88c90da71a4b0d848454e59e296c9ef7a8f018f3eaa3a198dc460b6621a4",
            "supplyType": 1,
            "delta": 100,
            "mosaicId": {
                "namespaceId": "alice.vouchers",
                "name": "Alice's gift vouchers"
            }
        },
        "privateKey": "00983bb01d05edecfaef55df9486c111abb6299c754a002069b1d0ef4537441bda"
}
        </code></pre>
<p>In the above example the supply for an existing mosaic with id 'alice.vouchers * Alice's gift vouchers' is changed. Specifically
        <li>the supplyType 1 means the supply is increased (a supply type of 2 means a supply decrease).</li>
<li>the delta of 100 means that another 100 units are credited to the creators account.</li>
</p>
<p>Reasons for NIS now accepting the transactions are most likely:
        <li>The transaction signer is not the creator os the mosaic.</li>
<li>The mosaic definition states that the supply is immutable.</li>
<li>When attempting to increase the supply, the total supply must not exceed 9,000,000,000 mosaics.</li>
<li>When attempting to decrease the supply, the creator must own the number of mosaics that he wants to delete.</li>
</p>
<p>After the transaction gets included into the block chain, the supply change is realized.</p>
<h2 id="creating-a-signed-transaction">Creating a signed transaction</h2>
<p>This chapter explains which data from the transactions you need to sign and what JSON object
        you to send to NIS.</p>
<h3 id="gathering-data-for-the-signature">Gathering data for the signature</h3>
<p>To create a transaction signature you need to sign an array of bytes extracted from the transaction.
       Since there is more than one type of transaction the byte array will have a different structure for
       different types of transactions. Nevertheless the first part of the byte array has the same structure
       for every transaction.
       Note that:</p>
<li>
        when the field denotes a number the endianess matters.
    </li>
<li>
        the order in which the fields are concatenated matters.
    </li>
<h4colored>Common transaction part of the byte array</h4colored>
<li>
<b>Transaction type:</b> 4 bytes (integer). The following types are supported:
        <ul>
<li>0x0101 (transfer transaction)</li>
<li>0x0801 (importance transfer transaction)</li>
<li>0x1001 (multisig aggregate modification transfer transaction)</li>
<li>0x1002 (multisig signature transaction)</li>
<li>0x1004 (multisig transaction)</li>
<b>example (importance transfer transaction): </b> 0x01, 0x08, 0x00, 0x00
        </ul>
</li>
<li>
<b>Version:</b> 4 bytes (integer). The following versions are supported:
        <ul>
<p>
				For transfer transaction, importance transfer transaction, multisig transactions and
				multisig signature transactions the version must be
			</p>
<li>0x68 &lt;&lt; 24 + 1 (main network)</li>
<li>0x98 &lt;&lt; 24 + 1 (test network)</li>
<b>Example (main network):</b> 0x01, 0x00, 0x00, 0x68
			<p></p><p>
				For multisig aggregate modification transactions the version must be
			</p>
<li>0x68 &lt;&lt; 24 + 2 (main network)</li>
<li>0x98 &lt;&lt; 24 + 2 (test network)</li>
<b>Example (main network):</b> 0x02, 0x00, 0x00, 0x68
        </ul>
</li>
<li>
<b>Timestamp:</b> 4 bytes (integer).
        <ul>
<b>Example (timestamp = 0x129623):</b> 0x23, 0x96, 0x12, 0x00
        </ul>
</li>
<li>
<b>Length of public key byte array (always 32):</b> 4 bytes (integer).
        <ul>
<b>Always:</b> 0x20, 0x00, 0x00, 0x00
        </ul>
</li>
<li>
<b>Public key bytes of signer:</b> 32 bytes.
        <ul>
<b>Example:</b> 0x6d, 0xa3, 0x76, 0x07, 0x13, 0x01, 0x9e, 0x26, 0xb1, 0x86, 0x24, 0x3a,
                            0xb6, 0xec, 0xba, 0x9f, 0x70, 0x78, 0x4c, 0x59, 0x92, 0x3d, 0x68, 0x9a,
                            0xb5, 0x4d, 0x4b, 0x2b, 0xf0, 0xe2, 0x0f, 0x5d
        </ul>
</li>
<li>
<b>Fee (micro nem):</b> 8 bytes (long).
        <ul>
<b>Example (12 nem):</b> 0x00, 0x1b, 0xb7, 0x00, 0x00, 0x00, 0x00, 0x00
        </ul>
</li>
<li>
<b>Deadline:</b> 4 bytes (integer).
        <ul>
<b>Example (deadline = 0x147824):</b> 0x24, 0x78, 0x14, 0x00
        </ul>
</li>
<h4colored>Transfer transaction part</h4colored>
<li>
<b>Length of recipient address (always 40):</b> 4 bytes (integer).
        <ul>
<b>Always:</b> 0x28, 0x00, 0x00, 0x00
        </ul>
</li>
<li>
<b>Recipient address:</b> 40 bytes (using UTF8 encoding).
        <ul>
<b>Example ("NACCH2WPJYVQ3PLGMVZVRK5JI6POTJXXHLUG3P4J"):</b> 0x4e, 0x41, 0x43, 0x43, 0x48, 0x32, 0x57, 0x50,
            0x4a, 0x59, 0x56, 0x51, 0x33, 0x50, 0x4c, 0x47, 0x4d, 0x56, 0x5a, 0x56, 0x52, 0x4b, 0x35, 0x4a, 0x49, 0x36,
            0x50, 0x4f, 0x54, 0x4a, 0x58, 0x58, 0x48, 0x4c, 0x55, 0x47, 0x33, 0x50, 0x34, 0x4a
        </ul>
</li>
<li>
<b>Amount (micro nem):</b> 8 bytes (long).
        <ul>
<b>Example (1234 NEM):</b> 0x80, 0x58, 0x8d, 0x49, 0x00, 0x00, 0x00, 0x00
        </ul>
</li>
<li>
<b>Length of message field:</b> 4 bytes (integer). Note: if the length is 0 then the following fields do not apply.
        <ul>
<b>Example:</b> 0x24, 0x00, 0x00, 0x00
        </ul>
</li>
<li>
<b>Message type:</b> 4 bytes (integer). The following message types are supported.
        <ul>
<li>0x01 (plain message)</li>
<li>0x02 (secure, i.e. encrypted, message)</li>
<b>Example:</b> 0x01, 0x00, 0x00, 0x00
        </ul>
</li>
<li>
<b>Length of payload:</b> 4 bytes (integer).
        <ul>
<b>Example:</b> 0x05, 0x00, 0x00, 0x00
        </ul>
</li>
<li>
<b>Payload:</b> UTF8 encoded string.
        <ul>
<b>Example ("Hello"):</b> 0x48, 0x65, 0x6c, 0x6c, 0x6f
        </ul>
</li>
<h4colored>Importance transfer transaction part</h4colored>
<li>
<b>Importance transfer mode:</b> 4 bytes (integer). The following modes are supported:
        <ul>
<li>0x01 (Activate)</li>
<li>0x02 (Deactivate)</li>
<b>Example (mode Activate):</b> 0x01, 0x00, 0x00, 0x00
        </ul>
</li>
<li>
<b>Length of remote account public key byte array (always 32):</b> 4 bytes (integer).
        <ul>
<b>Always:</b> 0x20, 0x00, 0x00, 0x00
        </ul>
</li>
<li>
<b>Public key bytes of remote account:</b> 32 bytes.
        <ul>
<b>Example:</b> 0x6d, 0xa3, 0x76, 0x07, 0x13, 0x01, 0x9e, 0x26, 0xb1, 0x86, 0x24, 0x3a,
            0xb6, 0xec, 0xba, 0x9f, 0x70, 0x78, 0x4c, 0x59, 0x92, 0x3d, 0x68, 0x9a,
            0xb5, 0x4d, 0x4b, 0x2b, 0xf0, 0xe2, 0x0f, 0x5d
        </ul>
</li>
<h4colored>Aggregate modification transaction part</h4colored>
<li>
<b>Number of cosignatory modifications:</b> 4 bytes (integer).
        <ul>
<b>Example:</b> 0x03, 0x00, 0x00, 0x00
        </ul>
</li>
<p>The following part is repeated for every cosignatory modification</p>
<li>
<b>Length of cosignatory modification structure:</b> 4 bytes (integer).
        <ul>
<b>Always:</b> 0x28, 0x00, 0x00, 0x00
        </ul>
</li>
<li>
<b>Modification type:</b> 4 bytes (integer). The following modification types are supported:
        <ul>
<li>0x01 (Add cosignatory)</li>
<li>0x02 (Delete cosignatory)</li>
<b>Example (Delete):</b> 0x02, 0x00, 0x00, 0x00
        </ul>
</li>
<li>
<b>Length of cosignatory's public key byte array (always 32):</b> 4 bytes (integer).
        <ul>
<b>Always:</b> 0x20, 0x00, 0x00, 0x00
        </ul>
</li>
<li>
<b>Public key bytes of cosignatory:</b> 32 bytes.
        <ul>
<b>Example:</b> 0x6d, 0xa3, 0x76, 0x07, 0x13, 0x01, 0x9e, 0x26, 0xb1, 0x86, 0x24, 0x3a,
            0xb6, 0xec, 0xba, 0x9f, 0x70, 0x78, 0x4c, 0x59, 0x92, 0x3d, 0x68, 0x9a,
            0xb5, 0x4d, 0x4b, 0x2b, 0xf0, 0xe2, 0x0f, 0x5d
        </ul>
</li>
<p>The following part describes the minimum cosignatories modification</p>
<li>
<b>Length of minimum cosignatories modification structure:</b> 4 bytes (integer).
		<ul>
<b>Always:</b> 0x04, 0x00, 0x00, 0x00
		</ul>
</li>
<li>
<b>Relative change:</b> 4 bytes (integer).
		<ul>
<b>Example (relative change of 2):</b> 0x02, 0x00, 0x00, 0x00
		</ul>
</li>
<h4colored>Multisig signature transaction part</h4colored>
<li>
<b>Length of hash object (hash of the corresponding multisig transaction):</b> 4 bytes (integer).
        <ul>
<b>Always:</b> 0x24, 0x00, 0x00, 0x00
        </ul>
</li>
<li>
<b>Length of hash:</b> 4 bytes (integer).
        <ul>
<b>Always:</b> 0x20, 0x00, 0x00, 0x00
        </ul>
</li>
<li>
<b>SHA3 hash bytes:</b> 32 bytes.
        <ul>
<b>Example:</b> 0x7d, 0x76, 0xfe, 0x26, 0xc4, 0x54, 0x61, 0xf7, 0x4b, 0xcb, 0x76, 0xac,
            0xae, 0xb0, 0x17, 0x39, 0x9e, 0xbe, 0x50, 0xaa, 0x71, 0x46, 0xe2, 0x62, 0x57, 0x39,
            0x5f,0xbb,0xc0,0x25,0xac,0xb7
        </ul>
</li>
<li>
<b>Length of address of the corresponding multisig account (always 40):</b> 4 bytes (integer).
        <ul>
<b>Always:</b> 0x28, 0x00, 0x00, 0x00
        </ul>
</li>
<li>
<b>Multisig account address:</b> 40 bytes (using UTF8 encoding).
        <ul>
<b>Example ("NACCH2WPJYVQ3PLGMVZVRK5JI6POTJXXHLUG3P4J"):</b> 0x4e, 0x41, 0x43, 0x43, 0x48, 0x32, 0x57, 0x50,
            0x4a, 0x59, 0x56, 0x51, 0x33, 0x50, 0x4c, 0x47, 0x4d, 0x56, 0x5a, 0x56, 0x52, 0x4b, 0x35, 0x4a, 0x49, 0x36,
            0x50, 0x4f, 0x54, 0x4a, 0x58, 0x58, 0x48, 0x4c, 0x55, 0x47, 0x33, 0x50, 0x34, 0x4a
        </ul>
</li>
<h4>Multisig transaction part</h4>
<li>
<b>Length of inner transaction object. This can be a transfer, an importance transfer or an aggregate modification transaction.</b>
<ul>
<b>Example:</b> 0x74, 0x00, 0x00, 0x00
        </ul>
</li>
<p>What follows here is the inner transaction object. The structure is one of the structures
        described above transactions (excluding signature transactions).</p>
<h4colored>Building the byte array</h4colored>
<p>To build the final byte array that needs to be signed, simply concatenate the common part for a transaction and the type specific part.
    For example if you want to build the byte array for a transfer transaction you have as common something that looks like</p>
<p>0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6f, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x68, 0x32, 0x03, 0xb4,
        0x55, 0x09, 0x0e, 0x2f, 0xfe, 0xd6, 0x48, 0x53, 0x6c, 0x99, 0x01, 0x4d, 0x1c, 0xa9, 0x2c, 0x10, 0x47, 0xaf, 0xbc, 0xae,
        0x58, 0x05, 0x7b, 0xb6, 0xa6, 0x98, 0xc8, 0x0b, 0x80, 0x84, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00</p>
<p>and a transfer transaction specific part</p>
<p>0x28, 0x00, 0x00, 0x00, 0x54, 0x41, 0x49, 0x34, 0x35, 0x32, 0x53, 0x37, 0x44, 0x4c, 0x36, 0x57, 0x48, 0x57, 0x54, 0x5a,
        0x5a, 0x32, 0x57, 0x33, 0x44, 0x49, 0x4d, 0x34, 0x32, 0x36, 0x58, 0x57, 0x49, 0x4a, 0x4b, 0x4c, 0x55, 0x4e, 0x58, 0x4e,
        0x4b, 0x54, 0x37, 0x4c, 0x40, 0x2f, 0x07, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00</p>
<p>which gives you the final array</p>
<p>0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6f, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x68, 0x32, 0x03, 0xb4,
        0x55, 0x09, 0x0e, 0x2f, 0xfe, 0xd6, 0x48, 0x53, 0x6c, 0x99, 0x01, 0x4d, 0x1c, 0xa9, 0x2c, 0x10, 0x47, 0xaf, 0xbc, 0xae,
        0x58, 0x05, 0x7b, 0xb6, 0xa6, 0x98, 0xc8, 0x0b, 0x80, 0x84, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        0x28, 0x00, 0x00, 0x00, 0x54, 0x41, 0x49, 0x34, 0x35, 0x32, 0x53, 0x37, 0x44, 0x4c, 0x36, 0x57, 0x48, 0x57, 0x54, 0x5a,
        0x5a, 0x32, 0x57, 0x33, 0x44, 0x49, 0x4d, 0x34, 0x32, 0x36, 0x58, 0x57, 0x49, 0x4a, 0x4b, 0x4c, 0x55, 0x4e, 0x58, 0x4e,
        0x4b, 0x54, 0x37, 0x4c, 0x40, 0x2f, 0x07, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00</p>
<p>Signing this array will give you the 64 byte long signature.</p>
<h4colored>Calculating the hash of a transaction</h4colored>
<p>NIS uses the SHA3-256 hash function. To create a hash of a transaction you need to hash the byte array of the transaction.
       See the section above to learn how to build the byte array from a transaction.</p>
<h3 id="sending-the-data-to-NIS">Sending the data to NIS</h3>
<p>After preparing the data as described in the last section you can send the array and the corresponding signature via a
        RequestAnnounce request</p>
<table class="NemApiGrid"><tr><td>API path:</td><td class="post" rowspan="2">Request type: <b>POST</b></td></tr><tr><td class="path">/transaction/announce</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Creates and broadcasts a transaction. The private key is not involved.</p>

<h4>Parameter:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">requestAnnounce</p>
</td>
<td>
<p class="NemNoSpacing">A RequestAnnounce JSON object as described in <span><em>Appendix A:</em> <a href="#requestAnnounce">RequestAnnounce</a></span>.</p>
</td>
</tr>
</table>
<h4>Example:</h4>
<p class="NemNoSpacing">Request cannot be performed in a browser.</p>
<h4>Example of returned JSON <a href="#nemAnnounceResult">NemAnnounceResult</a> object:</h4>
<pre><samp class="JSON">{
        "type":1,
        "code":1,
        "message":"SUCCESS",
        "transactionHash": {
        "data":"c1786437336da077cd572a27710c40c378610e8d33880bcb7bdb0a42e3d35586"
        },
        "innerTransactionHash": {
        "data":"cc317a7674d56352b4c711096a7594bd11908bf518293a191fc2faa12eac0fbb"
        }
}</samp></pre>
<h4>Possible Errors:</h4>
<p>The possible erros are described in chapter 6.1.</p>
<h2 id="transaction-fees">Transaction fees</h2>
<p>In order for the harvesters to have an incentive to run a node that is harvesting blocks,
        users have to pay a fee for every transaction that is going to be included in a block chain.</p>
<p>Different transaction types have different fees. In order to get a transaction
        validated by a NIS, the fee provided must be at least the minimum fee.</p>
<p>The following chart summarizes the minimum fees for each transaction type.
		All calculation are done with rounded amounts of XEM (i.e. micro XEM are ignored):</p>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">Transfer transaction</p>
</td>
<td>
<p>The fee is the sum of the fee for transferring an amount of
					XEM and the fee for appending a message to the transaction.</p>
<p>1) Fees for transferring XEM to another account:<br/>
                    a) If the amount transferred is less than 8 XEM then the
                    fee is 10  amount XEM.<br/>
                    Example:<br/>
					Transferring 6 XEM costs 4 XEM fee.<br/>
					b) If the amount transferred is greater or equal 8 XEM
                    then the fee is<br/>
					max(2, 99 * arctan(amount / 150000)) XEM.<br/>
                    Example:<br/>
					Transferring 100000 XEM costs 58 XEM.</p>
<p>2) Fees for appending a message to a transaction:<br/>
                    If no message or an empty message is append it costs
                    0 XEM. Else the fee is calculated as<br/>
                    2 * max(1, message length / 16)<br/>
                    Example:<br/>
                    The unencrypted message The New Economy
                    Movement will change the world!!! has a length 49
                    characters and thus will cost 2 * 49/16 = 6 XEM.</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">Importance transfer transaction</p>
</td>
<td>
<p>6 XEM</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">Aggregate modification transaction</p>
</td>
<td>
<p>10 + 6 * number of modifications + 6 (if a min cosignatory change is involved)<br/>
					Adding 3 cosignatories to an account without changing the min cosignatories will cost<br/>
                    10 + 6 * 3 = 28 XEM.<br/>
					Adding 3 cosignatories to an account and changing the min cosignatories will cost<br/>
					10 + 6 * 3 + 6 = 34 XEM.<br/>
</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">Multisig transaction</p>
</td>
<td>
<p>6 XEM</p>
</td>
</tr>
<tr>
<td>
<p class="JSON">Multisig signature transaction</p>
</td>
<td>
<p>6 XEM</p>
</td>
</tr>
</table>
<h1 id="requests-for-additional-information-from-NIS">Requests for additional information from NIS</h1>
<p>Several requests supply additional information about the internal status of NIS.</p>
<div class="warning">Those requests may get dropped in future versions of NIS
        without further notice, you should not rely on their existence.</div>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h2 id="monitoring-the-network-time">Monitoring the network time</h2>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/debug/time-synchronization</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets an array of time synchronization
	results as described in <span><em>Appendix A:</em> <a href="#timeSynchronizationResult">TimeSynchronizationResult</a></span>. You can monitor the change in network time with this information.</p>

<h4>No parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/debug/time-synchronization">http://127.0.0.1:7890/debug/time-synchronization</a></p>
<h4>Example of returned array of JSON <a href="#timeSynchronizationResult">TimeSynchronizationResult</a> objects:</h4>
<pre><samp class="JSON">{
       "data": [
       {
              "dateTime": "2014-11-19 19:23:04",
              "currentTimeOffset": 1747,
              "change": 57
       },
       {
              "dateTime": "2014-11-19 19:24:17",
              "currentTimeOffset": 1776,
              "change": 29
       },
       {
              "dateTime": "2014-11-19 19:25:18",
              "currentTimeOffset": 1729,
              "change": -47
       }]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">None.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h2 id="monitoring-incoming-and-outgoing-calls">Monitoring incoming and outgoing calls</h2>
<!-- ---- ---- ---- ---- ---- ---- -->
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/debug/connections/incoming</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets an audit collection of incoming
	calls as described in <span><em>Appendix A:</em> <a href="#auditCollection">AuditCollection</a></span>. You can monitor the
	outstanding and recent incoming requests with this information.</p>

<h4>No parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/debug/connections/incoming">http://127.0.0.1:7890/debug/connections/incoming</a></p>
<h4>Example of returned JSON <a href="#auditCollection">AuditCollection</a> object:</h4>
<pre><samp class="JSON">{
       "outstanding": [
       {
              "path": "/debug/connections/incoming",
              "start-time": 9317306,
              "host": "127.0.0.1",
              "elapsed-time": 0,
              "id": 4070
       }],
       "most-recent": [
       {
              "path": "/debug/connections/incoming",
              "start-time": 9317306,
              "host": "127.0.0.1",
              "elapsed-time": 0,
              "id": 4070
       },
       {
              "path": "/chain/score",
              "start-time": 9317303,
              "host": "95.16.203.168",
              "elapsed-time": 3,
              "id": 4069
       }]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">None.</p>
<!-- ---- ---- ---- ---- ---- ---- -->
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/debug/connections/outgoing</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets an audit collection of outgoing
	calls as described in <span><em>Appendix A:</em> <a href="#auditCollection">AuditCollection</a></span>. You can monitor the
	outstanding and recent outgoing requests with this information.</p>

<h4>No parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/debug/connections/outgoing">http://127.0.0.1:7890/debug/connections/outgoing</a></p>
<h4>Example of returned JSON <a href="#auditCollection">AuditCollection</a> object:</h4>
<pre><samp class="JSON">{
       "outstanding": [
       {
              "path": "/chain/blocks-after",
              "start-time": 9317511,
              "host": "88.12.55.125",
              "elapsed-time": 6,
              "id": 6452
       }],
       "most-recent": [
       {
              "path": "/chain/blocks-after",
              "start-time": 9317511,
              "host": "88.12.55.125",
              "elapsed-time": 6,
              "id": 6452
       },
       {
              "path": "/chain/hashes-from",
              "start-time": 9317511,
              "host": "88.12.55.125",
              "elapsed-time": 6,
              "id": 6451
       }]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">None.</p>
<!-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- -->
<h2 id="monitoring-timers">Monitoring timers</h2>
<table class="NemApiGrid"><tr><td>API path:</td><td class="get" rowspan="2">Request type: <b>GET</b></td></tr><tr><td class="path">/debug/connections/timers</td></tr></table>
<h4>Description:</h4>
<p class="NemNoSpacing">Gets an array of task monitor structures
	as described in <span><em>Appendix A:</em> <a href="#nemAsyncTimerVisitor">NemAsyncTimerVisitor</a></span>. You can monitor
	the statistics for periodic tasks with this information.</p>

<h4>No parameter:</h4>
<h4>Example:</h4>
<p><a href="http://127.0.0.1:7890/debug/timers">http://127.0.0.1:7890/debug/timers</a></p>
<h4>Example of returned array of JSON <a href="#nemAsyncTimerVisitor">NemAsyncTimerVisitor</a> objects:</h4>
<pre><samp class="JSON">{
       "data": [
       {
              "last-delay-time": 3000,
              "executions": 1024,
              "failures": 0,
              "successes": 1024,
              "last-operation-start-time": 9317695,
              "is-executing": 0,
              "name": "FORAGING",
              "average-operation-time": 0,
              "last-operation-time": 0
       },
       {
              "last-delay-time": 74181,
              "executions": 71,
              "failures": 0,
              "successes": 71,
              "last-operation-start-time": 9317654,
              "is-executing": 0,
              "name": "REFRESH",
              "average-operation-time": 6,
              "last-operation-time": 7
       }]
}</samp></pre>
<h4>Possible Errors:</h4>
<p class="NemNoSpacing">None.</p>
<h1 id="appendix-A:-description-of-the-JSON-structures">Appendix A: Description of the JSON Structures</h1>
<h2 id="accountHistoricalDataViewModel">AccountHistoricalDataViewModel</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">Nodes can support a feature for retrieving historical data of accounts.
            If a node supports this feature, it will return an array of AccountHistoricalDataViewModel objects.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
        "height": 8976,
        "address": "NALICELGU3IVY4DPJKHYLSSVYFFWYS5QPLYEZDJJ",
        "balance": 80670000000,
        "vestedBalance": 13949175142,
        "unvestedBalance": 66720824858,
        "importance": 0.00008166760846617221,
        "pageRank": 0.0006944567083595363
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>height</td><td>The height for which the data is valid.</td></tr><tr><td>address</td><td>The address of the account.</td></tr><tr><td>balance</td><td>The balance of the account.</td></tr><tr><td>vestedBalance</td><td>The vested part of the balance.</td></tr><tr><td>unvestedBalance</td><td>The unvested part of the balance.</td></tr><tr><td>importance</td><td>The importance of the account.</td></tr><tr><td>pageRank</td><td>The page rank part of the importance.</td></tr></table>
<h2 id="accountImportanceViewModel">AccountImportanceViewModel</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">Each account is assigned an importance
	in the NEM network. The ability of an account to generate new blocks is
	proportional to its importance. The importance is a number between 0 and 1.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
       "address": "TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS"
       "importance":
       {
           "isSet": 1,
           "score": 0.0011561555164258449,
           "ev": 0.004367936531009263,
           "height": 38413
       }
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>address</td><td>The address of the account.</td></tr><tr><td>importance</td><td>Substructure that describes the importance of the account.</td></tr><tr><td>isSet</td><td>Indicates if the fields "score", "ev" and "height" are available.isSet can have the values 0 or 1. In case isSet is 0 the fields are not available.</td></tr><tr><td>score</td><td>The importance of the account. The importance ranges between 0 and 1.</td></tr><tr><td>ev</td><td>The page rank portion of the importance. The page rank ranges between 0 and 1.</td></tr><tr><td>height</td><td>The height at which the importance calculation was performed.</td></tr></table>
<h2 id="accountInfo">AccountInfo</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">The account structure describes basic information for an account.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
       "address": "TALICELCD3XPH4FFI5STGGNSNSWPOTG5E4DS2TOS",
       "balance": 124446551689680,
       "vestedBalance": 1041345514976241,
       "importance": 0.010263666447108395,
       "publicKey": "a11a1a6c17a24252e674d151713cdf51991ad101751e4af02a20c61b59f1fe1a",
       "label": null,
       "harvestedBlocks": 645
}</samp></pre>
<h4>Description of the fields:</h4>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>address</td><td>The address of the account.</td></tr><tr><td>balance</td><td>The balance of the account in micro NEM.</td></tr><tr><td>vestedBalance</td><td>The vested part of the balance of the account in micro NEM.</td></tr><tr><td>importance</td><td>The importance of the account.</td></tr><tr><td>publicKey</td><td>The public key of the account.</td></tr><tr><td>label</td><td>The label of the account (not used, always null).</td></tr><tr><td>harvestedBlocks</td><td>The number blocks that the account already harvested.</td></tr></table>
<h2 id="accountMetaData">AccountMetaData</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">The account meta data describes
	additional information for the account. See <a href="#account-related-requests">Account related requests</a> for details.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
       "status": "LOCKED",
       "remoteStatus": "ACTIVE",
        "cosignatoryOf" : [
            &lt;AccountInfo&gt;,
            &lt;AccountInfo&gt;
        ],
        "cosignatories" : [
            &lt;AccountInfo&gt;,
            &lt;AccountInfo&gt;
        ]
}</samp></pre>
<h4>Description of the fields:</h4>
<table class="NemTableGrid">
<tr>
<td>
<p class="JSON">status</p>
</td>
<td>
<p>The harvesting status of a queried account.</p>
<p>The harvesting status can be one of the following values:</p>
<div class="FakeList"><p class="NemNoSpacing">"UNKNOWN":<span class="sep"> </span> The harvesting status of the account is not known.</p><p class="NemNoSpacing">"LOCKED":<span class="sep"> </span> The account is not harvesting.</p><p class="NemNoSpacing">"UNLOCKED":<span class="sep"> </span> The account is harvesting.</p></div>
</td>
</tr>
<tr>
<td>
<p class="JSON">remoteStatus</p>
</td>
<td>
<p>The status of remote harvesting of a queried account.</p>
<p>The remote harvesting status can be one of the following values:</p>
<div class="FakeList"><p class="NemNoSpacing">"REMOTE":<span class="sep"> </span> The account is a remote account and therefore remoteStatus is not applicable for it.</p><p class="NemNoSpacing">"ACTIVATING":<span class="sep"> </span> The account has activated remote harvesting but it is not yet active.</p><p class="NemNoSpacing">"ACTIVE":<span class="sep"> </span> The account has activated remote harvesting and remote harvesting is active.</p><p class="NemNoSpacing">"DEACTIVATING":<span class="sep"> </span> The account has deactivated remote harvesting but remote harvesting is still active.</p><p class="NemNoSpacing">"INACTIVE":<span class="sep"> </span> The account has inactive remote harvesting, or it has deactivated remote harvesting and deactivation is operational.</p></div>
</td>
</tr>
<tr>
<td><p class="JSON">cosignatoryOf</p></td>
<td>
<p>JSON array of  AccountInfo structures. The account is cosignatory for each of the accounts in the array.</p>
</td>
</tr>
<tr>
<td><p class="JSON">cosignatories</p></td>
<td>
<p>JSON array of  AccountInfo structures. The array holds all accounts that are a cosignatory for this account.</p>
</td>
</tr>
</table>
<h2 id="accountMetaDataPair">AccountMetaDataPair</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">The account meta data pair includes
	durable information for an account and additional information about its state.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
    "account":
        &lt;AccountInfo&gt;,
    "meta":
        &lt;AccountMetaData&gt;
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>account</td><td>Contains the account object.</td></tr><tr><td>&lt;AccountInfo&gt;</td><td>The account object as described in <a href="#accountInfo">AccountInfo</a>.</td></tr><tr><td>meta</td><td>Contains the account meta data object.</td></tr><tr><td>&lt;AccountMetaData&gt;</td><td>The account meta data object as described in <a href="#accountMetaData">AccountMetaData</a>.</td></tr></table>
<h2 id="accountPrivateKeyTransactionsPage">AccountPrivateKeyTransactionsPage</h2>
<h4>Description:</h4>
<p>The account private key transactions page contains data that NIS needs to
        retrieve a set of transactions from the database. The data includes the private
        key of the account for which transactions are retrieved. Use requests that use
        this structure only when NIS is running locally.</p>
<p>The fields "hash" and "id" are optional.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
    "value": "68e4f79f886927de698df4f857de2aada41ccca6617e56bb0d61623b35b08cc0",
    "hash": "44e4968e5aa35fe182d4def5958e23cf941c4bf809364afb4431ebbf6a18c039",
    "id": "12345"
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>value</td><td>The private key as hexadecimal string.</td></tr><tr><td>hash</td><td>The optional hash value.</td></tr><tr><td>id</td><td>The optional transaction id.</td></tr></table>
<h2 id="applicationMetaData">ApplicationMetaData</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">The application meta data object
	supplies additional information about the application running on a node.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
       "currentTime": 9189086,
       "application": "NEM Infrastructure Server",
       "startTime": 9060202,
       "version": "0.4.30-BETA",
       "signer": "CN=NEM Community,OU=Development Team,O=NEM,L=Internet,ST=web,C=WD"
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>currentTime</td><td>The current network time, i.e. the number of seconds that have elapsed since the creation of the nemesis block.</td></tr><tr><td>application</td><td>The name of the application running on the node.</td></tr><tr><td>startTime</td><td>The network time when the application was started.</td></tr><tr><td>version</td><td>The application version.</td></tr><tr><td>signer</td><td>The signer of the certificate used by the application.</td></tr></table>
<h2 id="auditCollection">AuditCollection</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">An audit collection consists of two
	arrays, containing information about incoming requests from other nodes. The
	first array contains information about outstanding (i.e. not yet processed
	requests) and the second array contains information about the most recent
	requests. The audit collection is for debug purposes.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
       "outstanding": [{
              "path": "/chain/score",
              "start-time": 9020618,
              "host": "86.124.91.183",
              "elapsed-time": 5,
              "id": 797725
       }],
       "most-recent": [{
              "path": "/push/transaction",
              "start-time": 9020621,
              "host": "hachi.nem.ninja",
              "elapsed-time": 2,
              id": 797750
       }]
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>path</td><td>The relative URL path.</td></tr><tr><td>start-time</td><td>The number of seconds elapsed since the creation of the nemesis block.</td></tr><tr><td>host</td><td>The host which initiated the request.</td></tr><tr><td>elapsed-time</td><td>The time in seconds that has elapsed since the request was received.</td></tr><tr><td>id</td><td>The unique id of the request.</td></tr></table>
<h2 id="block">Block</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">A block is the structure that contains
	the transaction information. A block can contain up to 120 transactions. Blocks
	are generated and signed by accounts and are the instrument by which
	information is spread in the network.</p>

<h4>JSON structure by example (main network):</h4>
<pre><samp class="JSON">{
       "timeStamp": 9022656,
       "signature": "256ebcfa4f92e2881963359c51095a390b9f4d1b3fee75ae19f96d5e6bcf055abbcaae3e55bcc17e6214924e4e6a9ebbe77357236b1a235e944950b851bda804",
       "prevBlockHash":
       {
              "data": "0a3d6bea020bb1a503364c37d57392342f368389bb23b05799c54d536d94749b"
       },
       "type": 1,
       "transactions": [
              Transaction1, Transaction2, , Transaction11
       ],
       "version": 1744830465,
       "signer": "6c66ea288522990db7a0a63c9c20f532cdcb68dc3c9544fb20f7322c92ceadbb",
       "height": 39324
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>timeStamp</td><td>The number of seconds elapsed since the creation of the nemesis block.</td></tr><tr><td>Signature</td><td>The signature of the block. The signature was generated by the
			signer and can be used to validate that the block data was not modified by a
			node.</td></tr><tr><td>prevBlockHash</td><td>The sha3-256 hash of the last block as hex-string.</td></tr><tr><td>type</td><td>The block type. There are currently two block types used:
			<div class="FakeList"><p class="NemNoSpacing">-1:<span class="sep"> </span> Only the nemesis block has this type.</p><p class="NemNoSpacing">1:<span class="sep"> </span> Regular block type.</p></div>
</td></tr><tr><td>transactions</td><td>The array of transaction structures. See <span><em>Appendix A:</em> <a href="#transaction">Transaction</a></span> for more details about this structure.</td></tr><tr><td>version</td><td>The block version. The following versions are supported.
			<li>0x68 &lt;&lt; 24 + 1 (1744830465 as 4 byte integer): the main network version</li>
<li>0x98 &lt;&lt; 24 + 1 (-1744830463 as 4 byte integer): the test network version</li></td></tr><tr><td>signer</td><td>The public key of the harvester of the block as hexadecimal number.</td></tr><tr><td>height</td><td>The height of the block. Each block has a unique height.
			Subsequent blocks differ in height by 1.</td></tr></table>
<h2 id="blockChainScore">BlockChainScore</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">The block chain score is a measure how
	good the block chain is. The higher the score, the better the block chain is.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
       "score": "17a3077c927d9a7e"
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>score</td><td>The score is an integer greater or equal to zero. It is submitted in hexadecimal format.</td></tr></table>
<h2 id="blockHeight">BlockHeight</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">The block height describes the position
	of the block within the block chain. The first block of the chain has height
	one. Each subsequent block has a height which is one higher than the previous
	block.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
       "height": 2649
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>height</td><td>The height is an integer greater than zero.</td></tr></table>
<h2 id="bootNodeRequest">BootNodeRequest</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">The BootNodeRequest JSNON object is used
	to transfer the relevant data for booting a local node to NIS. With the boot
	data NIS can create the local node object and connect to the network.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
       "metaData":
       {
              "application":"NIS"
       },
       "endpoint":
       {
              "protocol":"http",
              "port":7890,
              "host":"localhost"
       },
       "identity":
       {
              "private-key":"a6cbd01d04edecfaef51df9486c111abb6299c764a00206eb1d01f4587491b3f",
              "name":"Alice"
       }
}</samp></pre>
<h4>Description of the fields:</h4>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>metaData</td><td>Denotes the beginning of the metaData substructure.</td></tr><tr><td>application</td><td>The application name.</td></tr><tr><td>endpoint</td><td>Denotes the beginning of the endpoint substructure.</td></tr><tr><td>protocol</td><td>The protocol to use (only HTTP supported as for now).</td></tr><tr><td>port</td><td>The port to use.</td></tr><tr><td>host</td><td>The IP address to use.</td></tr><tr><td>identity</td><td>Denotes the fof the identity substructure.</td></tr><tr><td>private-key</td><td>The private key used for creating the identity.</td></tr><tr><td>name</td><td>The name of the node (can be anything).</td></tr></table>
<h2 id="communicationTimeStamps">CommunicationTimeStamps</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">Communication timestamps contain
	information about the network time of a remote NIS. NEM uses a time
	synchronization mechanism to synchronize time across the network. Each node
	maintains a network time which is the time of the computer clock plus an offset
	which compensates for the deviation from the computer clocks of other nodes.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
       "sendTimeStamp": 9145477789,
       "receiveTimeStamp": 9145477789
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>sendTimeStamp</td><td>The network time at the moment the reply was sent.</td></tr><tr><td>receiveTimeStamp</td><td>The network time at the moment the request was received.</td></tr></table>
<h2 id="explorerBlockViewModel">ExplorerBlockViewModel</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">The following structure is used by the
	NEM block chain explorer for convenience reason. The data is similar but not
	identical to that of a <a href="#block">Block</a>.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
        "data":[
            {
                "txes":[
                    &lt;ExplorerTransferViewModel&gt;,
                    &amp;vellip;
                    &lt;ExplorerTransferViewModel&gt;
                ],
                "block": &lt;Block&gt; ,
                "hash":"a6f62c62eedf4fafe6991e5cf31eae440963577c919f4eae86b4db8f8e572dce",
                "difficulty": 23456345897
            },
            
        ]
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>txes</td><td>Array containing the transactions of the block.</td></tr><tr><td>&lt;ExplorerTransferViewModel&gt;</td><td>The ExplorerBlockViewModel object as described in <a href="#explorerTransferViewModel">ExplorerTransferViewModel</a></td></tr><tr><td>block</td><td>Entry containing a JSON block object.</td></tr><tr><td>&lt;Block&gt;</td><td>The Block object as described in <span><em>Appendix A:</em> <a href="#block">Block</a></span></td></tr><tr><td>hash</td><td>The hash of the block as hexadecimal string.</td></tr><tr><td>difficulty</td><td>The block difficulty.</td></tr></table>
<h2 id="explorerTransferViewModel">ExplorerTransferViewModel</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">The following structure is used by the
	NEM block chain explorer for convenience reason. The data is similar but not
	identical to that of a <a href="#transaction">Transaction</a> structure.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
       "tx": &lt;Transaction&gt;,
       "hash": "5cba4614e52af19417fb53c4bdf442a57b9f558aee17ece530a5220da55cf47d",
       "innerHash": "ae3b107f1216e1ccf12b6f3c3c555bc1d95311747338ce66f539ea2c18c0aa57"
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>tx</td><td>Entry containing the JSON Transaction object.</td></tr><tr><td>&lt;Transaction&gt;</td><td>The Transaction object. Depending on the type of the transaction the structure will look different. See <span><em>Appendix A:</em> <a href="#transaction-objects">Transaction objects</a></span> for the different transaction types.</td></tr><tr><td>hash</td><td>The hash of the transaction.</td></tr><tr><td>innerHash</td><td>The hash of the inner transaction. This entry is only available for multisig transactions</td></tr></table>
<h2 id="extendedNodeExperiencePair">ExtendedNodeExperiencePair</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">When exchanging data with other nodes
	the result of the communication is divided into three different outcomes:
	success, neutral and failure. In the cases of success and failure the result is
	saved to be able to judge the quality of a node. This has influence on the
	probability that a certain node is selected as partner.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{ 
       "node": 
       { 
              &lt;Node&gt; 
       }, 
       "syncs": 822, 
       "experience": 
       { 
              "s": 357, 
              "f": 0 
       } 
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>node</td><td>Denotes the beginning of the of the Node substructure.</td></tr><tr><td>&lt;Node&gt;</td><td>The remote Node object as described in <a href="#node">Node</a>.</td></tr><tr><td>syncs</td><td>The number of synchronization attempts the node had with the remote node.</td></tr><tr><td>experience</td><td>Denotes the beginning of the of the NodeExperience substructure.</td></tr><tr><td>s</td><td>The number of successful communications with the remote node.</td></tr><tr><td>f</td><td>The number of failed communications with the remote node.</td></tr></table>
<h2 id="harvestInfo">HarvestInfo</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">A HarvestInfo object contains
	information about a block that an account harvested.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{ 
       "timeStamp": 8963798, 
       "id": 254378,
       "difficulty": 46534789865332,
       "totalFee": 2041299054, 
       "height": 38453 
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>timeStamp</td><td>The number of seconds elapsed since the creation of the nemesis block.</td></tr><tr><td>id</td><td>The database id for the harvested block.</td></tr><tr><td>difficulty</td><td>The block difficulty. The initial difficulty was set to 100000000000000. The block difficulty is always between one tenth and ten times the initial difficulty.</td></tr><tr><td>totalFee</td><td>The total fee collected by harvesting the block.</td></tr><tr><td>height</td><td>The height of the harvested block.</td></tr></table>
<h2 id="keyPairViewModel">KeyPairViewModel</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">A KeyPairViewModel object contains
            information about a new account. Information includes the private key,
            the public key and the address</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
    "privateKey": "0962c6505d02123c40e858ff8ef21e2b7b5466be12c4770e3bf557aae828390f",
    "publicKey": "c2e19751291d01140e62ece9ee3923120766c6302e1099b04014fe1009bc89d3",
    "address": "NCKMNCU3STBWBR7E3XD2LR7WSIXF5IVJIDBHBZQT"
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>privateKey</td><td>The private key of the account as hexadeciaml string.</td></tr><tr><td>publicKey</td><td>The public key of the account as hexadeciaml string.</td></tr><tr><td>address</td><td>The address of the account.</td></tr></table>
<h2 id="transaction-objects">Transaction objects</h2>
<h3 id="importanceTransferTransaction">ImportanceTransferTransaction</h3>
<h4>Description:</h4>
<p class="NemNoSpacing">NIS has the ability to transfer the importance of one
        account to another account for harvesting. The account receiving the
        importance is called the remote account. Importance transfer transactions
        are part of the secure harvesting feature of NEM. Once an importance
        transaction has been included in a block it needs 6 hours to become active.</p>

<h4>JSON structure by example (main network):</h4>
<pre><samp class="JSON">{
    "timeStamp": 9111526,
    "signature": "651a19ccd09c1e0f8b25f6a0aac5825b0a20f158ca4e0d78f2abd904a3966b6e3599a47b9ff199a3a6e1152231116fa4639fec684a56909c22cbf6db66613901",
    "fee": 3000000,
    "mode": 1,
    "remoteAccount": "cc6c9485d15b992501e57fe3799487e99de272f79c5442de94eeb998b45e0144",
    "type": 2049,
    "deadline": 9154726,
    "version": 1744830465,
    "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>timeStamp</td><td>The number of seconds elapsed since the creation of
            the nemesis block.</td></tr><tr><td>signature</td><td>The transaction signature (missing if part of a multisig
            transaction).</td></tr><tr><td>fee</td><td>The fee for the transaction. The higher the fee, the higher the
            priority of the transaction. Transactions with high priority get included in
            a block before transactions with lower priority.</td></tr><tr><td>mode</td><td>
            The mode. Possible values are:
            <div class="FakeList"><p class="NemNoSpacing">1:<span class="sep"> </span> Activate remote harvesting.</p><p class="NemNoSpacing">2:<span class="sep"> </span> Deactivate remote harvesting.</p></div>
</td></tr><tr><td>remoteAccount</td><td>The public key of the receiving account as
            hexadecimal string.</td></tr><tr><td>type</td><td>The transaction type.</td></tr><tr><td>deadline</td><td>The deadline of the transaction. The deadline is given as
            the number of seconds elapsed since the creation of the nemesis block.
            If a transaction does not get included in a block before the deadline is
            reached, it is deleted.</td></tr><tr><td>version</td><td>The version of the structure.</td></tr><tr><td>signer</td><td>The public key of the account that created the transaction.</td></tr></table>
<h3 id="mosaicDefinitionCreationTransaction">MosaicDefinitionCreationTransaction</h3>
<h4>Description:</h4>
<p class="NemNoSpacing">Before a mosaic can be created or transferred, a corresponding definition of the mosaic
            has to be created and published to the network. This is done via a mosaic definition creation transaction.</p>

<h4>JSON structure by example (test network):</h4>
<pre><samp class="JSON">{
        "timeStamp": 9111526,
        "signature": "651a19ccd09c1e0f8b25f6a0aac5825b0a20f158ca4e0d78f2abd904a3966b6e3599a47b9ff199a3a6e1152231116fa4639fec684a56909c22cbf6db66613901",
        "fee": 108000000,
        "type": 16385,
        "deadline": 9154726,
        "version": -1744830463,
        "signer": "cbda3edb771d42801a5c6ce0725f9374efade19a8933d6ac22ccfa50c777d0f9",
        "creationFee": 50000000000,
        "creationFeeSink": "53e140b5947f104cabc2d6fe8baedbc30ef9a0609c717d9613de593ec2a266d3",
        "mosaicDefinition": {
            "creator": "cbda3edb771d42801a5c6ce0725f9374efade19a8933d6ac22ccfa50c777d0f9",
            "description": "precious vouchers",
            "id": {
                "namespaceId": "alice.vouchers",
                "name": "Alice's gift vouchers"
            },
            "properties": [{
                    "name": "divisibility",
                    "value": "3"
                },{
                    "name": "initialSupply",
                    "value": "1000"
                },{
                    "name": "supplyMutable",
                    "value": "false"
                },{
                    "name": "transferable",
                    "value": "true"
                }
            ],
            "levy": {
                "type": 1,
                "recipient": "TD3RXTHBLK6J3UD2BH2PXSOFLPWZOTR34WCG4HXH",
                "mosaicId": {
                    "namespaceId": "nem",
                    "name": "xem"
                },
                "fee": 1000
            }
        }
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>timeStamp</td><td>The number of seconds elapsed since the creation of the nemesis block.</td></tr><tr><td>signature</td><td>The transaction signature (missing if part of a multisig transaction).</td></tr><tr><td>fee</td><td>The fee for the transaction. The higher the fee, the higher the
            priority of the transaction. Transactions with high priority get included in
            a block before transactions with lower priority.</td></tr><tr><td>type</td><td>The transaction type.</td></tr><tr><td>deadline</td><td>The deadline of the transaction. The deadline is given as
            the number of seconds elapsed since the creation of the nemesis block.
            If a transaction does not get included in a block before the deadline is
            reached, it is deleted.</td></tr><tr><td>version</td><td>The version of the structure.</td></tr><tr><td>signer</td><td>The public key of the account that created the transaction.</td></tr><tr><td>creationFee</td><td>The fee for the creation of the mosaic.</td></tr><tr><td>creationFeeSink</td><td>The public key of the account to which the creation fee is tranferred.</td></tr><tr><td>mosaicDefinition</td><td>The actual mosaic definition. See <a href="#mosaicDefinition">MosaicDefinition</a> for details.</td></tr></table>
<h3 id="mosaicSupplyChangeTransaction">MosaicSupplyChangeTransaction</h3>
<h4>Description:</h4>
<p class="NemNoSpacing">In case a mosaic definition has the property 'supplyMutable' set to true, the creator of the mosaic definition
        can change the supply, i.e. increase or decrease the supply.</p>

<h4>JSON structure by example (test network):</h4>
<pre><samp class="JSON">{
        "timeStamp": 9111526,
        "signature": "651a19ccd09c1e0f8b25f6a0aac5825b0a20f158ca4e0d78f2abd904a3966b6e3599a47b9ff199a3a6e1152231116fa4639fec684a56909c22cbf6db66613901",
        "fee": 108000000,
        "type": 16386,
        "deadline": 9154726,
        "version": -1744830463,
        "signer": "d99e88c90da71a4b0d848454e59e296c9ef7a8f018f3eaa3a198dc460b6621a4",
        "supplyType": 1,
        "delta": 123,
        "mosaicId": {
            "namespaceId": "alice.vouchers",
            "name": "gift vouchers"
        }
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>timeStamp</td><td>The number of seconds elapsed since the creation of the nemesis block.</td></tr><tr><td>signature</td><td>The transaction signature (missing if part of a multisig transaction).</td></tr><tr><td>fee</td><td>The fee for the transaction. The higher the fee, the higher the
            priority of the transaction. Transactions with high priority get included in
            a block before transactions with lower priority.</td></tr><tr><td>type</td><td>The transaction type.</td></tr><tr><td>deadline</td><td>The deadline of the transaction. The deadline is given as
            the number of seconds elapsed since the creation of the nemesis block.
            If a transaction does not get included in a block before the deadline is
            reached, it is deleted.</td></tr><tr><td>version</td><td>The version of the structure.</td></tr><tr><td>signer</td><td>The public key of the account that created the transaction.</td></tr><tr><td>supplyType</td><td>The supply type. Supported supply types are:
            <li>1: Increase in supply.</li>
<li>2: Decrease in supply.</li>
</td></tr><tr><td>delta</td><td>The supply change in units for the mosaic.</td></tr><tr><td>mosaicId</td><td>The mosaic id. See <a href="#mosaicId">MosaicId</a> for details.</td></tr></table>
<h3 id="multisigAggregateModificationTransaction">MultisigAggregateModificationTransaction</h3>
<h4>Description:</h4>
<p>Multisig aggregate modification transactions are part of the NEM's multisig
            account system. A multisig aggregate modification transaction holds an array
            of multisig cosignatory modifications and a single multisig minimum cosignatories
			modification inside the transaction. A multisig aggregate
            modification transaction can be wrapped by a multisig transaction.
			Aggregate modification transactions that use the minCosignatories field need to have
			version 0x68000002 (decimal 1744830466) for mainnet and 0x98000002 (decimal -1744830462)
			for testnet.
		</p>

<h4>JSON structure by example (main network):</h4>
<pre><samp class="JSON">{
	"timeStamp": 9111526,
	"signature": "651a19ccd09c1e0f8b25f6a0aac5825b0a20f158ca4e0d78f2abd904a3966b6e3599a47b9ff199a3a6e1152231116fa4639fec684a56909c22cbf6db66613901",
	"fee": 3000000,
	"type": 257,
	"deadline": 9154726,
	"version": 1744830466,
	"signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a",
	"modifications": [
		&lt;MultisigCosignatoryModification&gt;,
		&lt;MultisigCosignatoryModification&gt;
	],
	"minCosignatories" : {
		"relativeChange" : 2
	}
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>timeStamp</td><td>The number of seconds elapsed since the creation of the nemesis block.</td></tr><tr><td>signature</td><td>The transaction signature (missing if part of a multisig transaction).</td></tr><tr><td>fee</td><td>The fee for the transaction. The higher the fee, the higher the priority of the transaction. Transactions with high priority get included in a block before transactions with lower priority.</td></tr><tr><td>type</td><td>The transaction type.</td></tr><tr><td>deadline</td><td>The deadline of the transaction. The deadline is given as the number of seconds elapsed since the creation of the nemesis block. If a transaction does not get included in a block before the deadline is reached, it is deleted.</td></tr><tr><td>version</td><td>The version of the structure.</td></tr><tr><td>signer</td><td>The public key of the account that created the transaction.</td></tr><tr><td>modifications</td><td>The JSON array of multisig modifications.</td></tr><tr><td>minCosignatories</td><td>JSON object that holds the minimum cosignatories modification.</td></tr><tr><td>relativeChange</td><td>Value indicating the relative change of the minimum cosignatories.</td></tr></table>
<h3 id="multisigCosignatoryModification">MultisigCosignatoryModification</h3>
<h4>Description:</h4><p>Multisig cosignatory modifications are part of the NEM's multisig account system.
		With a multisig cosignatory modification a cosignatory is added to or deleted from a multisig
		account. Multisig cosignatory modifications are part of a multisig aggregate modification
		transactions, see details there.</p>
<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
	"modificationType": 1,
	"cosignatoryAccount": "213150649f51d6e9113316cbec5bf752ef7968c1e823a28f19821e91daf848be"
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>modificationType</td><td>The type of modification. Possible values are:
			<div class="FakeList"><p class="NemNoSpacing">1:<span class="sep"> </span> Add a new cosignatory.</p><p class="NemNoSpacing">2:<span class="sep"> </span> Delete an existing cosignatory.</p></div></td></tr><tr><td>cosignatoryAccount</td><td>The public key of the cosignatory account as hexadecimal string</td></tr></table>
<h3 id="multisigSignatureTransaction">MultisigSignatureTransaction</h3>
<h4>Description:</h4><p>Multisig signature transactions are part of the NEM's multisig account
        system. Multisig signature transactions are included in the corresponding
        multisig transaction and are the way a cosignatory of a multisig account can
        sign a multisig transaction for that account.</p>
<h4>JSON structure by example (test network):</h4>
<pre><samp class="JSON">{
	"timeStamp": 9111526,
	"signature": "651a19ccd09c1e0f8b25f6a0aac5825b0a20f158ca4e0d78f2abd904a3966b6e3599a47b9ff199a3a6e1152231116fa4639fec684a56909c22cbf6db66613901",
	"fee": 3000000,
	"type": 257,
	"deadline": 9154726,
	"version": -1744830463,
	"signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a",
	"otherHash": {
		"data": "44e4968e5aa35fe182d4def5958e23cf941c4bf809364afb4431ebbf6a18c039"
	},
	"otherAccount": "TDGIMREMR5NSRFUOMPI5OOHLDATCABNPC5ID2SVA"
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>timeStamp</td><td>The number of seconds elapsed since the creation of the nemesis block.</td></tr><tr><td>signature</td><td>The transaction signature.</td></tr><tr><td>fee</td><td>The fee for the transaction.</td></tr><tr><td>type</td><td>The transaction type.</td></tr><tr><td>deadline</td><td>The deadline of the transaction. The deadline is given as the number of seconds elapsed since the creation of the nemesis block. If a transaction does not get included in a block before the deadline is reached, it is deleted.</td></tr><tr><td>version</td><td>The version of the structure.</td></tr><tr><td>signer</td><td>The public key of the account that created the transaction.</td></tr><tr><td>otherHash</td><td>The hash of the inner transaction of the corresponding multisig transaction.</td></tr><tr><td>otherAccount</td><td>The address of the corresponding multisig account.</td></tr></table>
<h3 id="multisigTransaction">MultisigTransaction</h3>
<h4>Description:</h4><p>Multisig transaction are the only way to make transaction from
        a multisig account to another account. A multisig transaction carries another
        transaction inside (often referred to as "inner" transaction). The inner
        transaction can be a transfer, an importance transfer or an aggregate
        modification transaction. A multisig transaction also has multisig signature
        transactions from the cosignatories of the multisig account inside.</p>
<h4>JSON structure by example (test network):</h4>
<pre><samp class="JSON">{
	"timeStamp": 9111526,
	"signature": "651a19ccd09c1e0f8b25f6a0aac5825b0a20f158ca4e0d78f2abd904a3966b6e3599a47b9ff199a3a6e1152231116fa4639fec684a56909c22cbf6db66613901",
	"fee": 3000000,
	"type": 257,
	"deadline": 9154726,
	"version": -1744830463,
	"signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a",
	"otherTrans": &lt;inner transaction&gt;,
	"signatures":[
		&lt;MultisigSignatureTransaction&gt;,
		&lt;MultisigSignatureTransaction&gt;
	]
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>timeStamp</td><td> The number of seconds elapsed since the creation of the nemesis block.</td></tr><tr><td>signature</td><td> The transaction signature.</td></tr><tr><td>fee</td><td> The fee for the transaction.</td></tr><tr><td>type</td><td> The transaction type.</td></tr><tr><td>deadline</td><td> The deadline of the transaction. The deadline is given as the number of seconds elapsed since the creation of the nemesis block. If a transaction does not get included in a block before the deadline is reached, it is deleted.</td></tr><tr><td>version</td><td> The version of the structure.</td></tr><tr><td>signer</td><td> The public key of the account that created the transaction.</td></tr><tr><td>otherTrans</td><td> The inner transaction. The inner transaction can be a transfer transaction, an importance transfer transaction or a multisig aggregate modification transaction. The inner transaction does not have a  valid signature.</td></tr><tr><td>signatures</td><td> The JSON array of MulsigSignatureTransaction objects.</td></tr></table>
<h3 id="provisionNamespaceTransaction">ProvisionNamespaceTransaction</h3>
<h4>Description:</h4>
<p class="NemNoSpacing">Accounts can rent a namespace for one year and after a year renew the contract.
            This is done via a ProvisionNamespaceTransaction.</p>

<h4>JSON structure by example (test network):</h4>
<pre><samp class="JSON">{
        "timeStamp": 9111526,
        "signature": "651a19ccd09c1e0f8b25f6a0aac5825b0a20f158ca4e0d78f2abd904a3966b6e3599a47b9ff199a3a6e1152231116fa4639fec684a56909c22cbf6db66613901",
        "fee": 108000000,
        "type": 8193,
        "deadline": 9154726,
        "version": -1744830463,
        "signer": "d99e88c90da71a4b0d848454e59e296c9ef7a8f018f3eaa3a198dc460b6621a4",
        "rentalFeeSink": "3e82e1c1e4a75adaa3cba8c101c3cd31d9817a2eb966eb3b511fb2ed45b8e262",
        "rentalFee": 5000000000,
        "newPart": "voucher",
        "parent": "alice"
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>timeStamp</td><td>The number of seconds elapsed since the creation of the nemesis block.</td></tr><tr><td>signature</td><td>The transaction signature (missing if part of a multisig transaction).</td></tr><tr><td>fee</td><td>The fee for the transaction. The higher the fee, the higher the
            priority of the transaction. Transactions with high priority get included in
            a block before transactions with lower priority.</td></tr><tr><td>type</td><td>The transaction type.</td></tr><tr><td>deadline</td><td>The deadline of the transaction. The deadline is given as
            the number of seconds elapsed since the creation of the nemesis block.
            If a transaction does not get included in a block before the deadline is
            reached, it is deleted.</td></tr><tr><td>version</td><td>The version of the structure.</td></tr><tr><td>signer</td><td>The public key of the account that created the transaction.</td></tr><tr><td>rentalFeeSink</td><td>The public key of the account to which the rental fee is transferred.</td></tr><tr><td>rentalFee</td><td>The fee for renting the namespace.</td></tr><tr><td>newPart</td><td>The new part which is concatenated to the parent with a '.' as separator.</td></tr><tr><td>parent</td><td>The parent namespace. This can be null if the transaction rents a root namespace.</td></tr></table>
<h3 id="transferTransaction">TransferTransaction</h3>
<h4>Description:</h4> <p class="NemNoSpacing">Transfer transactions contain data about transfers of XEM or mosaics to another account.
        There are two version of transfer transactions, version 1 and version 2. Version 1 transfer transaction are only capable of transferring XEM and
        a message while version 2 transfer transactions additionally can transfer a set of mosaics.
    </p>
<h4>JSON structure by example (v1 transfer transaction, test network):</h4>
<pre><samp class="JSON">{
        "timeStamp": 9111526,
        "amount": 1000000000,
        "signature": "651a19ccd09c1e0f8b25f6a0aac5825b0a20f158ca4e0d78f2abd904a3966b6e3599a47b9ff199a3a6e1152231116fa4639fec684a56909c22cbf6db66613901",
        "fee": 3000000,
        "recipient": "TDGIMREMR5NSRFUOMPI5OOHLDATCABNPC5ID2SVA",
        "type": 257,
        "deadline": 9154726,
        "message":
        {
        "payload": "74657374207472616e73616374696f6e",
        "type": 1
        },
        "version": -1744830463,
        "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a"
}</samp></pre>
<h4>JSON structure by example (v2 transfer transaction, test network):</h4>
<pre><samp class="JSON">{
        "timeStamp": 9111526,
        "amount": 123000000,
        "signature": "fad7ea2b5df5f7846f45fd9983a75ad8d333af3660f4f0d355864420f4482605d675e89d97177385338b226097342b4222add52c5397423f9eaf6b01fe3ef70c",
        "fee": 3000000,
        "recipient": "TBEH27FNRS43FNH3PXE4XN3H7HXA37H77APSZW46",
        "type": 257,
        "deadline": 9154726,
        "message":
        {
            "payload": "74657374207472616e73616374696f6e",
            "type": 1
        },
        "version": -1744830462,
        "signer": "cb4ef3709d25ccd0c022b2d53e4ce31478ebc4bf177b1b54482afb8e55692521",
        "mosaics":[{
            "mosaicId":{
                "namespaceId": "id0",
                "name": "name0"
            },
            "quantity": 10
        },{
            "mosaicId":{
                "namespaceId": "id1",
                "name": "name1"
            },
            "quantity": 11
        }]
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>timeStamp</td><td>The number of seconds elapsed since the creation of the nemesis block.</td></tr><tr><td>amount</td><td>The amount of micro NEM that is transferred from sender to recipient.</td></tr><tr><td>signature</td><td>The transaction signature.</td></tr><tr><td>fee</td><td>The fee for the transaction. The higher the fee, the higher the
				priority of the transaction. Transactions with high priority get included in
				a block before transactions with lower priority.</td></tr><tr><td>recipient</td><td>The address of the recipient.</td></tr><tr><td>type</td><td>The transaction type.</td></tr><tr><td>deadline</td><td>The deadline of the transaction. The deadline is given as the
				number of seconds elapsed since the creation of the nemesis block. If a
				transaction does not get included in a block before the deadline is reached, it
				is deleted.</td></tr><tr><td>message</td><td>Optionally a transaction can contain a message. In this case the
				transaction contains a message substructure. If not the field is null.</td></tr><tr><td>payload</td><td>
				Optional field in case the transaction contains a message. The
				payload is the actual (possibly encrypted) message data.</td></tr><tr><td>type</td><td>
				Optional field in case the transaction contains a message. The
				field holds the message type information. Possible message types are:
				<div class="FakeList"><p class="NemNoSpacing">1:<span class="sep"> </span> The message is not encrypted.</p><p class="NemNoSpacing">2:<span class="sep"> </span> The message is encrypted.</p></div>
</td></tr><tr><td>version</td><td>The version of the structure.</td></tr><tr><td>signer</td><td>The public key of the account that created the transaction.</td></tr><tr><td>mosaics</td><td>The array of <a href="#mosaic">Mosaic</a> objects.</td></tr></table>
<h2 id="mosaic">Mosaic</h2>
<h4>Description:</h4><p>A mosaic describes an instance of a mosaic definition.
        Mosaics can be transferred by means of a transfer transaction.</p>
<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
        "mosaicId": {
            "namespaceId": "alice.drinks",
            "name": "orange juice"
        },
        "quantity": 123000
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>mosaicId</td><td>The mosaic id. See <a href="#mosaicId">MosaicId</a></td></tr><tr><td>quantity</td><td>The mosaic quantity. The quantity is always given in smallest units for the mosaic,
            i.e. if it has a divisibility of 3 the quantity is given in millis.</td></tr></table>
<h2 id="mosaicDefinition">MosaicDefinition</h2>
<h4>Description:</h4><p>A mosaic definition describes an asset class.
        Some fields are mandatory while others are optional.
        The properties of a mosaic definition always have a default value and only need to be supplied if they differ from the default value.</p>
<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
        "creator": "10cfe522fe23c015b8ab24ef6a0c32c5de78eb55b2152ed07b6a092121187100",
        "id": {
            "namespaceId": "alice.drinks",
            "name": "orange juice"
        },
        "description": "A healthy drink with lots of vitamins",
        "properties": [{
            "name": "divisibility",
            "value": "3"
        },{
            "name": "initialSupply",
            "value": "1000"
        },{
            "name": "supplyMutable",
            "value": "false"
        },{
            "name": "transferable",
            "value": "true"
        }],
        "levy": {
            "type": 1,
            "recipient": "TD3RXTHBLK6J3UD2BH2PXSOFLPWZOTR34WCG4HXH",
            "mosaicId": {
                "namespaceId": "alice.drinks",
                "name": "orange juice"
            },
            "fee": 1000
        }
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>creator</td><td>The public key of the mosaic definition creator.</td></tr><tr><td>id</td><td>The mosaic id. See <a href="#mosaicId">MosaicId</a>.</td></tr><tr><td>description</td><td>The mosaic description. The description may have a length of up to 512 characters and cannot be empty.</td></tr><tr><td>properties</td><td>The mosaic properties.
            The properties may be an empty array in which case default values for all properties are applied.
            See <a href="#mosaicProperties">MosaicProperties</a> for further details.</td></tr><tr><td>levy</td><td>The optional levy for the mosaic. A creator can demand that each mosaic transfer induces an additional fee.
            See <a href="#mosaicLevy">MosaicLevy</a> for further details.</td></tr></table>
<h2 id="mosaicDefinitionMetaDataPair">MosaicDefinitionMetaDataPair</h2>
<h4>Description:</h4><p>A mosaic definition consists of a database id and a mosaic definition object. The id is needed for requests that support paging.</p>
<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
        "meta" {
            "id": 3541
        }
        "mosaic": {
            "creator": "10cfe522fe23c015b8ab24ef6a0c32c5de78eb55b2152ed07b6a092121187100",
            "id": {
                "namespaceId": "alice.drinks",
                "name": "orange juice"
            },
            "description": "A healthy drink with lots of vitamins",
            "properties": [
            ]
        }
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>meta</td><td>The label for the meta data object.</td></tr><tr><td>id</td><td>The id for the mosaic definition object.</td></tr><tr><td>mosaic</td><td>The label for the mosaic definition object. See <a href="#mosaicDefinition">MosaicDefinition</a> for a detailed
            description of the object.</td></tr><tr><td>creator</td><td>The public key of the mosaic definition creator.</td></tr><tr><td>id</td><td>The mosaic id. See <a href="#mosaicId">MosaicId.</a></td></tr><tr><td>description</td><td>The mosaic description. The description may have a length of up to 512 characters and cannot be empty.</td></tr><tr><td>properties</td><td>The mosaic properties.</td></tr></table>
<h2 id="mosaicProperties">MosaicProperties</h2>
<h4>Description:</h4><p>Each mosaic definition comes with a set of properties.
        Each property has a default value which will be applied in case it was not specified.
        Future release may add additional properties to the set of available properties.
        The available properties and their default values are:
        <li>
<b>divisibility:</b> defines the smallest sub-unit that a mosaic can be divided into.
        A divisibility of 0 means that only entire units can be transferred while a divisibility of 3 means the mosaic can be transferred in milli-units.
        </li>
<li>
<b>initialSupply:</b> defines how many units of the mosaic are initially created. These mosaics are credited to the creator of the mosaic.
            The initial supply has an upper limit of 9,000,000,000 units.
        </li>
<li>
<b>supplyMutable:</b> determines whether or not the supply can be changed by the creator at a later point using a
            <a href="#mosaicSupplyChangeTransaction">MosaicSupplyChangeTransaction</a>. Possible values are "true" and "false",
            the former meaning the supply can be changed and the latter that the supply is fixed for all times.
        </li>
<li>
<b>transferable:</b> determines whether or not the a mosaic can be transferred to a user other than the creator.
            In certain scenarios it is not wanted that user are able to trade the mosaic (for example when the mosaic represents bonus points which
            the company does not want to be tranferable to other users).
            Possible values are "true" and "false", the former meaning the mosaic can be arbitrarily transferred among users
            and the latter meaning the mosaic can only be transferred to and from the creator.
        </li>
</p>
<h4>JSON structure by example:</h4>
<pre><samp class="JSON">[{
        "name": "divisibility",
        "value": "3"
        },{
        "name": "initialSupply",
        "value": "1000"
        },{
        "name": "supplyMutable",
        "value": "false"
        },{
        "name": "transferable",
        "value": "true"
}]</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>name</td><td>The name of the mosaic property.</td></tr><tr><td>value</td><td>The name of the mosaic property.</td></tr></table>
<h2 id="mosaicLevy">MosaicLevy</h2>
<h4>Description:</h4><p>A mosaic definition can optionally specify a levy for transferring those mosaics.
    This might be needed by legal entities needing to collect some taxes for transfers.</p>
<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
        "type": 1,
        "recipient": "TD3RXTHBLK6J3UD2BH2PXSOFLPWZOTR34WCG4HXH",
        "mosaicId":  {
            "namespaceId": "nem",
            "name": "xem"
        },
        "fee": 1000
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>type</td><td>The levy type. The following types are supported:
            <li>1: The levy is an absolute fee. The field 'fee' states how many sub-units of the specified mosaic will be transferred to the recipient.</li>
<li>2: The levy is calculated from the transferred amount.
                The field 'fee' states how many percentiles of the transferred quantity will transferred to the recipient.
            </li>
</td></tr><tr><td>recipient</td><td>The recipient of the levy.</td></tr><tr><td>mosaicId</td><td>The mosaic in which the levy is paid.</td></tr><tr><td>recipient</td><td>The fee. The interpretation is dependent on the type of the levy</td></tr></table>
<h2 id="mosaicId">MosaicId</h2>
<h4>Description:</h4><p>A mosaic id uniquely identifies an underlying mosaic definition.</p>
<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
        "namespaceId": "alice.drinks",
        "name": "orange juice"
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>namespaceId</td><td>The corresponding namespace id. See the description of the structure <a href="#namespace">Namespace.</a> for details.</td></tr><tr><td>name</td><td>The name of the mosaic definition.</td></tr></table>
<h2 id="namespace">Namespace</h2>
<h4>Description:</h4><p>A namespace is the NEM version of a domain. You can rent a namespace for the duration of a year by paying a fee.
        The naming of the parts of a namespace has certain restrictions, see the corresponding chapter on namespaces.</p>
<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
        "fqn": "makoto.metal.coins",
        "owner": TD3RXTHBLK6J3UD2BH2PXSOFLPWZOTR34WCG4HXH",
        "height": 13465
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>fqn</td><td>The fully qualified name of the namespace, also named namespace id.</td></tr><tr><td>owner</td><td>The owner of the namespace.</td></tr><tr><td>height</td><td>The height at which the ownership begins.</td></tr></table>
<h2 id="namespaceMetaDataPair">NamespaceMetaDataPair</h2>
<h4>Description:</h4><p>A namespace consists of a namespace object and a database id. the id is needed for requests that support paging.</p>
<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
        "meta":{
            "id":26264,
        },
        "namespace":{
            "fqn": "makoto.metal.coins",
            "owner": TD3RXTHBLK6J3UD2BH2PXSOFLPWZOTR34WCG4HXH",
            "height": 13465
        }
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>meta</td><td>The label for the meta data object.</td></tr><tr><td>id</td><td>The database id for the namespace object.</td></tr><tr><td>namespace</td><td>The label for the namespace object.</td></tr><tr><td>fqn</td><td>The fully qualified name of the namespace, also named namespace id.</td></tr><tr><td>owner</td><td>The owner of the namespace.</td></tr><tr><td>height</td><td>The height at which the ownership begins.</td></tr></table>
<h2 id="nemAnnounceResult">NemAnnounceResult</h2>
<h4>Description:</h4><p>The NemAnnounceResult extends the <a href="#nemRequestResult">NemRequestResult</a>
        by supplying the additional fields 'transactionHash' and in case of a multisig transaction 'innerTransactionHash'.</p>
<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
        "type": 4,
        "code": 6,
        "message": "status",
        "transactionHash": {
        "data":"c1786437336da077cd572a27710c40c378610e8d33880bcb7bdb0a42e3d35586"
        },
        "innerTransactionHash": {
        "data": "44e4968e5aa35fe182d4def5958e23cf941c4bf809364afb4431ebbf6a18c039"
        }
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>type</td><td> See description of <a href="#nemRequestResult">NemRequestResult</a>.</td></tr><tr><td>code</td><td> See description of <a href="#nemRequestResult">NemRequestResult</a>.</td></tr><tr><td>message</td><td> See description of <a href="#nemRequestResult">NemRequestResult</a>.</td></tr><tr><td>transactionHash</td><td> The JSON hash object of the transaction.</td></tr><tr><td>innerTransactionHash</td><td> The JSON hash object of the inner transaction or null if the transaction is not a multisig transaction.</td></tr></table>
<h2 id="nemAsyncTimerVisitor">NemAsyncTimerVisitor</h2>
<h4>Description:</h4><p>NIS uses timers to schedule periodic
	tasks. Those tasks are monitored and their result is memorized. The
	NemAsyncTimeVisitor structure holds  the information.</p>
<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{ 
       "last-delay-time": 3000, 
       "executions": 1024, 
       "failures": 0, 
       "successes": 1024, 
       "last-operation-start-time": 9317695, 
       "is-executing": 0, 
       "name": "FORAGING", 
       "average-operation-time": 0, 
       "last-operation-time": 0 
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>last-delay-time</td><td>The number of milliseconds since the last execution of the timer.</td></tr><tr><td>executions</td><td>The number of times the task was executed.</td></tr><tr><td>failures</td><td>The number times the task failed.</td></tr><tr><td>successes</td><td>The number times the task was successful.</td></tr><tr><td>last-operation-start-time</td><td>The time at which the task started last time.</td></tr><tr><td>is-executing</td><td>True if the task is executing, false otherwise.</td></tr><tr><td>name</td><td>The name of the task.</td></tr><tr><td>average-operation-time</td><td>The number of seconds the task needed on average.</td></tr><tr><td>last-operation-time</td><td>The number of seconds the task needed the last time.</td></tr></table>
<h2 id="nemRequestResult">NemRequestResult</h2>
<p>Some requests such as announcing a new
	transaction return detailed information about the outcome of the request. In
	those cases the result of the request is returned in a special JSON object
	called NemRequestResult. The structure is typically used for requests that
	perform validation or return a status.</p>
<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{ 
       "type": 4, 
       "code": 6, 
       "message": "status" 
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>type</td><td><p>The type is dependent on the request which was answered.</p>
<p>The interpretation of the code field depends on the type. Currently the following
			types are supported:</p>
<p> </p>
<div class="FakeList"><p class="NemNoSpacing">1:<span class="sep"> </span> The result is a validation result.</p><p class="NemNoSpacing">2:<span class="sep"> </span> The result is a heart beat result.</p><p class="NemNoSpacing">4:<span class="sep"> </span> The result indicates a status.</p></div>
</td></tr><tr><td>code</td><td>The meaning of the code is dependent on the type.
			For type 1 (validation result) only 0 and 1 mean there was no
			failure. For a complete list of validation results see <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a>
			The following codes are the most frequent ones occurring:
			<div class="FakeList"><p class="NemNoSpacing">0:<span class="sep"> </span>Neutral result. A typical example would be that a node validates an incoming transaction and realizes that it already knows about the transaction. In this case it is neither a success (meaning the node has a new transaction) nor a failure (because the transaction itself is valid).</p><p class="NemNoSpacing">1:<span class="sep"> </span>Success result. A typical example would be that a node validates a new valid transaction.</p><p class="NemNoSpacing">2:<span class="sep"> </span>Unknown failure. The validation failed for unknown reasons.</p><p class="NemNoSpacing">3:<span class="sep"> </span>The entity that was validated has already past its deadline.</p><p class="NemNoSpacing">4:<span class="sep"> </span>The entity used a deadline which lies too far in the future.</p><p class="NemNoSpacing">5:<span class="sep"> </span>There was an account involved which had an insufficient balance to perform the operation.</p><p class="NemNoSpacing">6:<span class="sep"> </span>The message supplied with the transaction is too large.</p><p class="NemNoSpacing">7:<span class="sep"> </span>The hash of the entity which got validated is already in the database.</p><p class="NemNoSpacing">8:<span class="sep"> </span>The signature of the entity could not be validated.</p><p class="NemNoSpacing">9:<span class="sep"> </span>The entity used a timestamp that lies too far in the past.</p><p class="NemNoSpacing">10:<span class="sep"> </span>The entity used a timestamp that lies in the future which is not acceptable.</p><p class="NemNoSpacing">11:<span class="sep"> </span>The entity is unusable.</p><p class="NemNoSpacing">12:<span class="sep"> </span>The score of the remote block chain is inferior (although a superior score was promised).</p><p class="NemNoSpacing">13:<span class="sep"> </span>The remote block chain failed validation.</p><p class="NemNoSpacing">14:<span class="sep"> </span>There was a conflicting importance transfer detected.</p><p class="NemNoSpacing">15:<span class="sep"> </span>There were too many transaction in the supplied block.</p><p class="NemNoSpacing">16:<span class="sep"> </span>The block contains a transaction that was signed by the harvester.</p><p class="NemNoSpacing">17:<span class="sep"> </span>A previous importance transaction conflicts with a new transaction.</p><p class="NemNoSpacing">18:<span class="sep"> </span>An importance transfer activation was attempted while previous one is active.</p><p class="NemNoSpacing">19:<span class="sep"> </span>An importance transfer deactivation was attempted but is not active.</p></div>
<p> </p>
<p>For type 2 the following codes are supported:</p>
<div class="FakeList"><p class="NemNoSpacing">1:<span class="sep"> </span>Successful heart beat detected.</p></div>
<p></p>
<p>For type 3 the following codes are supported:</p>
<div class="FakeList"><p class="NemNoSpacing">0:<span class="sep"> </span>Unknown status.</p><p class="NemNoSpacing">1:<span class="sep"> </span>NIS is stopped.</p><p class="NemNoSpacing">2:<span class="sep"> </span>NIS is starting.</p><p class="NemNoSpacing">3:<span class="sep"> </span>NIS is running.</p><p class="NemNoSpacing">4:<span class="sep"> </span>NIS is booting the local node (implies NIS is running).</p><p class="NemNoSpacing">5:<span class="sep"> </span>The local node is booted (implies NIS is running).</p><p class="NemNoSpacing">6:<span class="sep"> </span>The local node is synchronized (implies NIS is running and the local node is booted).</p><p class="NemNoSpacing">7:<span class="sep"> </span>There is no remote node available (implies NIS is running and the local node is booted).</p><p class="NemNoSpacing">8:<span class="sep"> </span>NIS is currently loading the block chain.</p></div>
</td></tr></table>
<h2 id="nisNodeInfo">NisNodeInfo</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">The NisNodeInfo object provides detailed information about a node.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{ 
       "node": { 
              &lt;Node&gt; 
       }, 
       "nisInfo": { 
              &lt;ApplicationMetaData&gt; 
       } 
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>node</td><td>Denotes the beginning of the node substructure.</td></tr><tr><td>&lt;Node&gt;</td><td>The Node object as described in <a href="#node">Node</a>.</td></tr><tr><td>nisInfo</td><td>Denotes the beginning of the application meta data substructure.</td></tr><tr><td>&lt;ApplicationMetaData&gt;</td><td>The ApplicationMetaData object as described in <a href="#applicationMetaData">ApplicationMetaData</a>.</td></tr></table>
<h2 id="node">Node</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">Nodes are the entities that perform
	communication in the network like sending and receiving data. A node has an
	identity which is tied to an account through which the node can identify itself
	to the network. The communication is done through the endpoint of the node.
	Additionally a node provides meta data information.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{ 
       "metaData": 
       {
              "features": 1,
              "networkId": 104,
              "application": "NIS", 
              "version": "0.4.30-BETA", 
              "platform": "Oracle Corporation (1.8.0_05) on Windows 8.1" 
       }, 
       "endpoint": 
       { 
              "protocol": "http", 
              "port": 7890, 
              "host": "85.25.36.97" 
       }, 
       "identity": 
       { 
              "name": "Hi, I am Alice2", 
              "public-key": "3302e7703ee9f364c25bbfebb9c12ac91fa9dcd69e09a5d4f3830d71505a2350" 
       } 
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>metaData</td><td>Denotes the beginning of the meta data substructure.</td></tr><tr><td>features</td><td>The number of features the nodes has.</td></tr><tr><td>networkId</td><td><p>The network id. The following network ids are supported:</p>
<li>104 (hex 0x68): The main network id.</li>
<li>152 (hex 0x98): The test network id.</li>
</td></tr><tr><td>application</td><td>The name of the application that is running the node.</td></tr><tr><td>version</td><td>The version of the application.</td></tr><tr><td>platform</td><td>The underlying platform (OS, java version).</td></tr><tr><td>endpoint</td><td>Denotes the beginning of the endpoint substructure.</td></tr><tr><td>protocol</td><td>The protocol used for the communication (HTTP or HTTPS).</td></tr><tr><td>port</td><td>The port used for the communication.</td></tr><tr><td>host</td><td>The IP address of the endpoint.</td></tr><tr><td>identity</td><td>Denotes the beginning of the identity substructure.</td></tr><tr><td>name</td><td>The name of the node.</td></tr><tr><td>public-key</td><td>The public key used to identify the node.</td></tr></table>
<h2 id="nodeCollection">NodeCollection</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">A NodeCollection object holds arrays of nodes
	with different statuses. The following statuses are supported:</p>

<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>inactive</td><td>A connection to the node cannot be established.</td></tr><tr><td>active</td><td>A connection can be established and the remote node responds in a timely manner.</td></tr><tr><td>busy</td><td>A connection can be established but the node cannot provide
			information within the timeout limits.</td></tr><tr><td>failure</td><td>A fatal error occurs when trying to establish a connection or the
			node couldn't authenticate itself correctly.</td></tr><tr><td>data</td><td>Generic status indicating the node collection just lists nodes without
			saying anything about the status of the node.</td></tr></table>
<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{ 
       "inactive": [ 
              &lt;Node&gt;, 
              &lt;Node&gt; 
       ], 
       "active": [ 
              &lt;Node&gt;, 
              &lt;Node&gt; 
       ], 
       "busy": [ 
              &lt;Node&gt;, 
              &lt;Node&gt; 
       ], 
       "failure": [ 
              &lt;Node&gt;, 
              &lt;Node&gt; 
       ], 
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>inactive</td><td>Denotes the beginning of the array of inactive nodes.</td></tr><tr><td>active</td><td>Denotes the beginning of the array of active nodes.</td></tr><tr><td>busy</td><td>Denotes the beginning of the array of busy nodes.</td></tr><tr><td>failure</td><td>Denotes the beginning of the array of failing nodes.</td></tr><tr><td>&lt;Node&gt;</td><td>The Node object as described in <a href="#node">Node</a>.</td></tr></table>
<h2 id="privateKey">PrivateKey</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">A private key is a key to an account.
	Anyone having the private key to an account can initiate any account related
	action. <strong>Therefore a private key must be kept secret at all costs.</strong></p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
	"value": "68e4f79f886927de698df4f857de2aada41ccca6617e56bb0d61623b35b08cc0",
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>value</td><td>The 256 bit value of the private key as hexadecimal string.</td></tr></table>
<h2 id="requestAnnounce">RequestAnnounce</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">A RequestAnnounce object is used
            to transfer the transaction data and the signature to NIS in order to initiate and
            broadcast a transaction.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{
        "data": "010100000100000000000000200000002b76078fa709bbe675
                 2222b215abc7ec0152ffe831fb4f9aed3e7749a425900a0009
                 3d0000000000000000002800000054444e46555946584f5353
                 334e4e4c4f35465a5348535a49354c33374b4e514945485055
                 4d584c54c0d45407000000000b00000001000000030000000c
                 3215",
        "signature": "db2473513c7f0ce9f8de6345f0fbe773
                      dc687eb571123d08eab4d98f96849eae
                      b63fa8756fb6c59d9b9d0e551537c1cd
                      ad4a564747ff9291db4a88b65c97c10d"
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>data</td><td>The transaction data as string. The string is created by
			first creating the corresponding byte array (see chapter 6.7)
			and then converting the byte array to a hexadecimal string.</td></tr><tr><td>signature</td><td>The signature for the transaction as hexadecimal string.</td></tr></table>
<h2 id="requestPrepareAnnounce">RequestPrepareAnnounce</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">A RequestPrepareAnnounce object is used
	to transfer transaction data and a private key to NIS in order to initiate and
	broadcast a transaction.</p>

<h4>JSON structure by example (test network):</h4>
<pre><samp class="JSON">{ 
       "transaction": 
       { 
              "timeStamp": 9111526, 
              "amount": 1000000000, 
              "fee": 3000000, 
              "recipient": "TDGIMREMR5NSRFUOMPI5OOHLDATCABNPC5ID2SVA", 
              "type": 257, 
              "deadline": 9154726, 
              "message": 
              { 
                     "payload": "74657374207472616e73616374696f6e", 
                     "type": 1 
              }, 
              "version": -1744830463,
              "signer": "a1aaca6c17a24252e674d155713cdf55996ad00175be4af02a20c67b59f9fe8a" 
       }, 
       "privateKey": "68e4f79f886927de698df4f857de2aada41ccca6617e56bb0d61623b35b08cc0"
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>transaction</td><td>Denotes the beginning of the transaction data part. The
			transaction data is described in <span><em>Appendix A:</em> <a href="#transaction">Transaction</a></span>. The field 'signature is
			missing since the transaction is not signed at this point.</td></tr><tr><td>privateKey</td><td>The private key which NIS will use to sign the transaction.</td></tr></table>
<h2 id="timeSynchronizationResult">TimeSynchronizationResult</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">A time synchronization result is the
	outcome of the network time synchronization of a node with other remote nodes.
	To agree upon a common time nodes need to synchronize time every hour.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{ 
       "dateTime": "2014-11-16 20:47:06", 
       "currentTimeOffset": 2786, 
       "change": 36 
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>dateTime</td><td>The date and time when the synchronization was performed.</td></tr><tr><td>currentTimeOffset</td><td>The current offset to the local computer clock in milliseconds.</td></tr><tr><td>change</td><td>The change in milliseconds compared to the last synchronization.</td></tr></table>
<h2 id="transactionMetaData">TransactionMetaData</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">Transactions meta data object contains
	additional information about the transaction.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{ 
       "height": 40706,
        "id": 2769,
        "hash": {
            "data":"37c34ead4c3fe6af42d994135798262f785ba2d807c02ac3608bc10da12e5f87"
        }
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>height</td><td>The height of the block in which the transaction was included.</td></tr><tr><td>id</td><td>The id of the transaction.</td></tr><tr><td>hash</td><td>The transaction hash.</td></tr></table>
<h2 id="transactionMetaDataPair">TransactionMetaDataPair</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">Transactions meta data object contains
	additional information about the transaction.</p>

<h4>JSON structure by example:</h4>
<pre><samp class="JSON">{ 
       "meta": 
              &lt;TransactionMetaData&gt;, 
       "transaction": 
              &lt;Transaction&gt; 
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>meta</td><td>Contains the transaction meta data object.</td></tr><tr><td>&lt;TransactionMetaData&gt;</td><td>The transaction meta data object as described in <a href="#transactionMetaData">TransactionMetaData</a>.</td></tr><tr><td>Transaction</td><td>Contains the transaction object.</td></tr><tr><td>&lt;Transaction&gt;</td><td>The transaction object as described in <a href="#transaction">Transaction</a>.</td></tr></table>
<h2 id="unconfirmedTransactionMetaData">UnconfirmedTransactionMetaData</h2>
<h4>Description:</h4>The unconfirmed transaction meta data contains the hash of the inner transaction in case the transaction is a multisig transaction. This data is need to initiate a multisig signature transaction.
<pre><samp class="JSON">{
	data": "d7c9e33421e43bf4a5d6e21304c8096c599142755d581bd6e9037f41545a5873"
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>data</td><td>The hash of the inner transaction or null if the transaction is not a multisig transaction.</td></tr></table>
<h2 id="unconfirmedTransactionMetaDataPair">UnconfirmedTransactionMetaDataPair</h2>
<h4>Description:</h4>Transactions meta data object contains additional information about the transaction.
<pre><samp class="JSON">{
	"meta":
		&lt;UnconfirmedTransactionMetaData&gt;,
	"transaction":
		&lt;Transaction&gt;
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>meta</td><td> Contains the transaction meta data object.</td></tr><tr><td>&lt;UnconfirmedTransactionMetaData&gt;</td><td> The transaction meta data object as described in UnconfirmedTransactionMetaData.</td></tr><tr><td>transaction</td><td> Contains the transaction object.</td></tr><tr><td>&lt;Transaction&gt;</td><td> The transaction object as described in Transaction.</td></tr></table>
<h2 id="error-object">Error object</h2>
<h4>Description:</h4>
<p class="NemNoSpacing">If NIS encounters an error due to either
	invalid requests or internal problems, it returns a JSON error object. The
	interpretation of the error object is dependant on the context. See <a href="#appendix-B:-NIS-errors">Appendix B: NIS Errors</a> for detailed information about possible errors.</p>

<h4>JSON structure by example</h4>
<pre><samp class="JSON">{ 
       "timeStamp": 9108808, 
       "error": "Bad Request", 
       "message": "address must be valid", 
       "status": 400 
}</samp></pre>
<h4>Description of the fields:</h4><table class="NemParamsGrid"><tr><td>timeStamp</td><td>The number of seconds elapsed since the creation of the nemesis block.</td></tr><tr><td>error</td><td>The general description of the error.</td></tr><tr><td>message</td><td>The detailed error message.</td></tr><tr><td>Status</td><td>The HTTP status.</td></tr></table>
<h1 id="appendix-B:-NIS-errors">Appendix B: NIS Errors</h1>
<p>In case NIS encounters an error while
	processing a request it returns a JSON error object whose structure is
	described in <span><em>Appendix A:</em> <a href="#error-object">Error object</a></span>. This chapter describes the
	errors messages that can be returned from NIS.</p>
<h2 id="error-messages">Error messages</h2>
<dl>
<dt>Request method 'GET' not supported</dt>
<dd>The request was performed as GET request but was expected to be a POST request.</dd>
<dt>address must be valid:</dt>
<dd>At least one address supplied in the request was invalid. Addresses are validated before processing a request. If validation fails, an error containing this message is returned.</dd>
<dt>FAILURE_SERVER_LIMIT:</dt>
<dd>The number of accounts that are allowed to harvest on NIS was exceeded.</dd>
<dt>JSON Object was expected:</dt>
<dd>A parameter is missing in the request.</dd>
<dt>FAILURE_UNKNOWN_ACCOUNT:</dt>
<dd>The account specified in the request is not known.</dd>
<dt>block not found in the db</dt>
<dd>The block that was requested could not be found in the database.</dd>
<dt>height must be positive</dt>
<dd>The block height supplied in a request was zero or negative. Block height must always be greater than zero.</dd>
<dt>network has not been booted yet</dt>
<dd>Most requests need the node that should answer the request to be already booted. If node is not booted yet, this error message will be returned.</dd>
<dt>network boot was already attempted</dt>
<dd>It was attempted to boot an already booted node. Nodes can only be booted once.</dd>
<dt>remote 123.45.67.89 attempted to call local /node/boot</dt>
<dd>It was attempted to boot a remote node.  Only local node can be booted.</dd>
<dt>FAILURE_PAST_DEADLINE</dt>
<dd>The deadline for the entity has already expired. The deadline must always lie in the future.</dd>
<dt>FAILURE_FUTURE_DEADLINE</dt>
<dd>The deadline lies too far in the future.  Deadlines are only allowed to lie up to 24 hours in the future.</dd>
<dt>FAILURE_INSUFFICIENT_BALANCE</dt>
<dd>The account does not have enough funds.</dd>
<dt>FAILURE_MESSAGE_TOO_LARGE</dt>
<dd>The message for the transaction exceeds the limit of 512 bytes.</dd>
<dt>FAILURE_HASH_EXISTS</dt>
<dd>The hash of the entity already exists either in the cache or in the database.</dd>
<dt>FAILURE_SIGNATURE_NOT_VERIFIABLE</dt>
<dd>The signature of the entity failed upon verification.</dd>
<dt>FAILURE_TIMESTAMP_TOO_FAR_IN_PAST</dt>
<dd>The timestamp of the entity lies to far in the past.</dd>
<dt>FAILURE_TIMESTAMP_TOO_FAR_IN_FUTURE</dt>
<dd>The timestamp of the entity lies too far in the future.</dd>
<dt>FAILURE_INELIGIBLE_BLOCK_SIGNER</dt>
<dd>Validation failed because the block had an ineligible signer. This usually occurs when remote harvesting is in the process of being activated or deactivated.</dd>
<dt>FAILURE_ENTITY_UNUSABLE_OUT_OF_SYNC</dt>
<dd>The entity cannot be processed because the remote node is out of synchronization with the local node. This happens frequently when a node is not fully synchronized and receives a new block with much larger height than its own chain.</dd>
<dt>FAILURE_INSUFFICIENT_FEE</dt>
<dd>The supplied transaction has an insufficient fee.</dd>
<dt>FAILURE_NEMESIS_ACCOUNT_TRANSACTION_AFTER_NEMESIS_BLOCK</dt>
<dd>The supplied transaction has the nemesis account as sender and cannot be included in a normal block.</dd>
<dt>FAILURE_TRANSACTION_CACHE_TOO_FULL</dt>
<dd>The transaction was rejected because the transaction cache is too full. This happens when an account tries to send too many transactions in a short time. To improve the chance that the transaction gets accepted you can try to raise the transaction fee.</dd>
<dt>FAILURE_WRONG_NETWORK</dt>
<dd>Entity was rejected because it has the wrong network specified.</dd>
<dt>FAILURE_CANNOT_HARVEST_FROM_BLOCKED_ACCOUNT</dt>
<dd>Block was rejected because it was harvested by a blocked account (typically a reserved NEM fund).</dd>
<dt>FAILURE_DESTINATION_ACCOUNT_HAS_NONZERO_BALANCE</dt>
<dd>The importance cannot be transferred to an account with nonzero balance.</dd>
<dt>FAILURE_IMPORTANCE_TRANSFER_IN_PROGRESS</dt>
<dd>The transaction is conflicting because there is already a transfer of importance in progress.</dd>
<dt>FAILURE_IMPORTANCE_TRANSFER_NEEDS_TO_BE_DEACTIVATED</dt>
<dd>The transaction is conflicting because the importance was already transferred.</dd>
<dt>FAILURE_IMPORTANCE_TRANSFER_IS_NOT_ACTIVE</dt>
<dd>The transaction is conflicting because no importance has been transferred yet.</dd>
<dt>FAILURE_TRANSACTION_NOT_ALLOWED_FOR_REMOTE</dt>
<dd>Validation failed because transaction is using remote account in an improper way.</dd>
<dt>FAILURE_MULTISIG_NOT_A_COSIGNER</dt>
<dd>The multisig transaction was rejected because the signer of the transaction is not a cosignatory of the sender account of the inner transaction.</dd>
<dt>FAILURE_MULTISIG_INVALID_COSIGNERS</dt>
<dd>Validation failed because the cosignatories attached to a multisig transaction were invalid.</dd>
<dt>FAILURE_MULTISIG_NO_MATCHING_MULTISIG</dt>
<dd>The signature transaction was rejected because the corresponding multisig transaction was not found.</dd>
<dt>FAILURE_TRANSACTION_NOT_ALLOWED_FOR_MULTISIG</dt>
<dd>The transaction was rejected because the signer is a multisig account. Multisig accounts are not allowed to initiate any transaction (only cosignatories are allowed to do so).</dd>
<dt>FAILURE_MULTISIG_ALREADY_A_COSIGNER</dt>
<dd>The transaction was rejected because it tried to add a cosignatory to a multisig account which already has this cosignatory.</dd>
<dt>FAILURE_MULTISIG_MODIFICATION_MULTIPLE_DELETES</dt>
<dd>The transaction was rejected because it tried to remove multiple cosignatories at once. It is only allowed to remove one cosignatory at a time.</dd>
<dt>FAILURE_MULTISIG_MODIFICATION_REDUNDANT_MODIFICATIONS</dt>
<dd>The transaction was rejected because it tried to do redundant modifications. This can happen if a transaction tries to add the same cosignatory two time.</dd>
<dt>FAILURE_CONFLICTING_MULTISIG_MODIFICATION</dt>
<dd>The transaction was rejected because it contained conflicting modifications to a multisig account. This can for instance happen if a transaction tries to add and then delete the same cosignatory.</dd>
<dt>FAILURE_TOO_MANY_MULTISIG_COSIGNERS</dt>
<dd>The transaction was rejected because it contains too many cosignatories. The maximum number of cosignatories allowed for a multisig account is 32.</dd>
<dt>FAILURE_MULTISIG_ACCOUNT_CANNOT_BE_COSIGNER</dt>
<dd>Validation failed because a multisig modification would result in a multisig account being a cosigner.</dd>
<dt>FAILURE_MULTISIG_MIN_COSIGNATORIES_OUT_OF_RANGE</dt>
<dd>Validation failed because the minimum number of cosignatories is negative or larger than the number of cosignatories.</dd>
</dl>
</div>
</body>
</html>
